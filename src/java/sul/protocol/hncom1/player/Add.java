/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
package sul.protocol.hncom1.player;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

import sul.utils.*;

/**
 * Adds a player to the node.
 */
public class Add extends Packet {

	public static final byte ID = (byte)14;

	public static final boolean CLIENTBOUND = true;
	public static final boolean SERVERBOUND = false;

	// reason
	public static final byte FIRST_JOIN = 0;
	public static final byte TRANSFERRED = 1;
	public static final byte FORCIBLY_TRANSFERRED = 2;

	public int hubId;

	/**
	 * Reason why the player has joined the node.
	 */
	public byte reason;

	/**
	 * Game of the client, which could either be Minecraft or Minecraft: Pocket Edition.
	 */
	public byte type;

	/**
	 * Version of the protocol used by the client.
	 */
	public int protocol;

	/**
	 * Version of the game used by the client, usually in the format major.minor[.patch],
	 * calculated by the server or passed by the client during the authentication process.
	 * The node should verify that the version exists and matches the protocol in the previous
	 * field.
	 */
	public String version;

	/**
	 * Username of the player.
	 */
	public String username;

	/**
	 * Display name of the player, which can contain formatting codes. By default it's
	 * equals to the username but it can be updated by the node using UpdateDisplayName.
	 */
	public String displayName;

	/**
	 * Dimension in which the player was playing before being transferred. It could diffent
	 * from client's game type and version because the dimension's ids are different in
	 * Minecraft and Minecraft: Pocket Edition.
	 * It's used to send the game's change dimension packet to despawn old entities and
	 * delete old chunks.
	 */
	public byte dimension;

	/**
	 * Remote address of the client.
	 */
	public sul.protocol.hncom1.types.Address clientAddress;

	/**
	 * Ip used by the client to connect to the server. The value of this field is the address
	 * the client has saved in its servers list. For example a client that joins through
	 * `localhost` and a client that joins through `127.0.0.1` will connect to the same
	 * server but the field of this value will be different (`localhost` for the first
	 * client and `127.0.0.1` for the second).
	 */
	public String serverAddress;

	/**
	 * Port used by the client to connect to the server.
	 */
	public short serverPort;

	/**
	 * Client's UUID, given by Mojang's or Microsoft's services if the server is in online
	 * mode or given by the client (and not verified) if the server is in offline mode.
	 */
	public UUID uuid;

	/**
	 * Client's skin, given by the client or downloaded from Mojang's services in online
	 * mode.
	 */
	public sul.protocol.hncom1.types.Skin skin;

	/**
	 * Client's latency (ping time).
	 */
	public int latency;

	/**
	 * Client's language, in the same format as HubInfo.language, which should be updated
	 * from the node when the client changes it.
	 */
	public String language;

	public Add() {}

	public Add(int hubId, byte reason, byte type, int protocol, String version, String username, String displayName, byte dimension, sul.protocol.hncom1.types.Address clientAddress, String serverAddress, short serverPort, UUID uuid, sul.protocol.hncom1.types.Skin skin, int latency, String language) {
		this.hubId = hubId;
		this.reason = reason;
		this.type = type;
		this.protocol = protocol;
		this.version = version;
		this.username = username;
		this.displayName = displayName;
		this.dimension = dimension;
		this.clientAddress = clientAddress;
		this.serverAddress = serverAddress;
		this.serverPort = serverPort;
		this.uuid = uuid;
		this.skin = skin;
		this.latency = latency;
		this.language = language;
	}

	@Override
	public int length() {
		return Buffer.varuintLength(hubId) + Buffer.varuintLength(protocol) + Buffer.varuintLength(version.getBytes(StandardCharsets.UTF_8).length) + version.getBytes(StandardCharsets.UTF_8).length + Buffer.varuintLength(username.getBytes(StandardCharsets.UTF_8).length) + username.getBytes(StandardCharsets.UTF_8).length + Buffer.varuintLength(displayName.getBytes(StandardCharsets.UTF_8).length) + displayName.getBytes(StandardCharsets.UTF_8).length + clientAddress.length() + Buffer.varuintLength(serverAddress.getBytes(StandardCharsets.UTF_8).length) + serverAddress.getBytes(StandardCharsets.UTF_8).length + skin.length() + Buffer.varuintLength(latency) + Buffer.varuintLength(language.getBytes(StandardCharsets.UTF_8).length) + language.getBytes(StandardCharsets.UTF_8).length + 22;
	}

	@Override
	public byte[] encode() {
		return this.encodeImpl();
	}

	private byte[] encodeImpl() {
		this._buffer = new byte[this.length()];
		this.writeBigEndianByte(ID);
		this.writeVaruint(hubId);
		this.writeBigEndianByte(reason);
		this.writeBigEndianByte(type);
		this.writeVaruint(protocol);
		byte[] dmvyc2lvbg=version.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)dmvyc2lvbg.length); this.writeBytes(dmvyc2lvbg);
		byte[] dxnlcm5hbwu=username.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)dxnlcm5hbwu.length); this.writeBytes(dxnlcm5hbwu);
		byte[] zglzcgxheu5hbwu=displayName.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)zglzcgxheu5hbwu.length); this.writeBytes(zglzcgxheu5hbwu);
		if(reason!=0){ this.writeBigEndianByte(dimension); }
		this.writeBytes(clientAddress.encode());
		byte[] c2vydmvyqwrkcmvz=serverAddress.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)c2vydmvyqwrkcmvz.length); this.writeBytes(c2vydmvyqwrkcmvz);
		this.writeBigEndianShort(serverPort);
		this.writeBigEndianLong(uuid.getLeastSignificantBits()); this.writeBigEndianLong(uuid.getMostSignificantBits());
		this.writeBytes(skin.encode());
		this.writeVaruint(latency);
		byte[] bgfuz3vhz2u=language.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)bgfuz3vhz2u.length); this.writeBytes(bgfuz3vhz2u);
		return this.getBuffer();
	}

	@Override
	public void decode(byte[] buffer) {
		this._buffer = buffer;
		readBigEndianByte();
		hubId=this.readVaruint();
		reason=readBigEndianByte();
		type=readBigEndianByte();
		protocol=this.readVaruint();
		int bgvudmvyc2lvbg=this.readVaruint(); version=new String(this.readBytes(bgvudmvyc2lvbg), StandardCharsets.UTF_8);
		int bgvudxnlcm5hbwu=this.readVaruint(); username=new String(this.readBytes(bgvudxnlcm5hbwu), StandardCharsets.UTF_8);
		int bgvuzglzcgxheu5h=this.readVaruint(); displayName=new String(this.readBytes(bgvuzglzcgxheu5h), StandardCharsets.UTF_8);
		if(reason!=0){ dimension=readBigEndianByte(); }
		clientAddress=new sul.protocol.hncom1.types.Address(); clientAddress._index=this._index; clientAddress.decode(this._buffer); this._index=clientAddress._index;
		int bgvuc2vydmvyqwrk=this.readVaruint(); serverAddress=new String(this.readBytes(bgvuc2vydmvyqwrk), StandardCharsets.UTF_8);
		serverPort=readBigEndianShort();
		long bxv1awq=readBigEndianLong(); long bhv1awq=readBigEndianLong(); uuid=new UUID(bxv1awq,bhv1awq);
		skin=new sul.protocol.hncom1.types.Skin(); skin._index=this._index; skin.decode(this._buffer); this._index=skin._index;
		latency=this.readVaruint();
		int bgvubgfuz3vhz2u=this.readVaruint(); language=new String(this.readBytes(bgvubgfuz3vhz2u), StandardCharsets.UTF_8);
	}

	private byte[] remainingBuffer() {
		return java.util.Arrays.copyOfRange(this._buffer, this._index, this._buffer.length);
	}

	public static Add fromBuffer(byte[] buffer) {
		Add ret = new Add();
		ret.decode(buffer);
		return ret;
	}

	@Override
	public String toString() {
		return "Add(hubId: " + this.hubId + ", reason: " + this.reason + ", type: " + this.type + ", protocol: " + this.protocol + ", version: " + this.version + ", username: " + this.username + ", displayName: " + this.displayName + ", dimension: " + this.dimension + ", clientAddress: " + this.clientAddress.toString() + ", serverAddress: " + this.serverAddress + ", serverPort: " + this.serverPort + ", uuid: " + this.uuid.toString() + ", skin: " + this.skin.toString() + ", latency: " + this.latency + ", language: " + this.language + ")";
	}

	/**
	 * A Minecraft: Pocket Edition client.
	 */
	public class Pocket extends Packet {

		public static final byte TYPE = (byte)1;

		// device os
		public static final byte UNKNOWN = 0;
		public static final byte ANDROID = 2;

		/**
		 * XBOX Live id, which is a unique identifier for authenticated players or 0 if the
		 * server is in offline mode.
		 */
		public long xuid;

		/**
		 * Indicates whether the client is using the Education Edition variant of the game.
		 */
		public boolean edu;

		/**
		 * Client's packet loss calculated from the hub in the range 0 (no packet lost) to
		 * 100 (every packet lost).
		 */
		public float packetLoss;

		/**
		 * Client's operative system, if supplied by the client. This field's value may be
		 * used to divide players that play from a phone from players that play on a computer.
		 */
		public byte deviceOs;

		/**
		 * Client's device model, if supplied by the client. This field is usually a string
		 * in the format `MANUFACTURES MODEL`: for example, the Oneplus one is `ONEPLUS A0001`.
		 * This field's value may be used to exclude devices with bad performances.
		 */
		public String deviceModel;

		public Pocket() {}

		public Pocket(long xuid, boolean edu, float packetLoss, byte deviceOs, String deviceModel) {
			this.xuid = xuid;
			this.edu = edu;
			this.packetLoss = packetLoss;
			this.deviceOs = deviceOs;
			this.deviceModel = deviceModel;
		}

		@Override
		public int length() {
			return Buffer.varlongLength(xuid) + Buffer.varuintLength(deviceModel.getBytes(StandardCharsets.UTF_8).length) + deviceModel.getBytes(StandardCharsets.UTF_8).length + 6;
		}

		@Override
		public byte[] encode() {
			byte[] _encode = encodeImpl();
			this._buffer = new byte[_encode.length + this.length()];
			this.writeBytes(_encode);
			this.writeVarlong(xuid);
			this.writeBool(edu);
			this.writeBigEndianFloat(packetLoss);
			this.writeBigEndianByte(deviceOs);
			byte[] zgv2awnltw9kzww=deviceModel.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)zgv2awnltw9kzww.length); this.writeBytes(zgv2awnltw9kzww);
			return this.getBuffer();
		}

		@Override
		public void decode(byte[] buffer) {
			this._buffer = buffer;
			xuid=this.readVarlong();
			edu=this.readBool();
			packetLoss=readBigEndianFloat();
			deviceOs=readBigEndianByte();
			int bgvuzgv2awnltw9k=this.readVaruint(); deviceModel=new String(this.readBytes(bgvuzgv2awnltw9k), StandardCharsets.UTF_8);
		}

		public void decode() {
			this.decode(remainingBuffer());
		}

		@Override
		public String toString() {
			return "Add.Pocket(xuid: " + this.xuid + ", edu: " + this.edu + ", packetLoss: " + this.packetLoss + ", deviceOs: " + this.deviceOs + ", deviceModel: " + this.deviceModel + ")";
		}

	}

	/**
	 * A Minecraft client. Currently there are no additional fields.
	 */
	public class Minecraft extends Packet {

		public static final byte TYPE = (byte)2;

		@Override
		public int length() {
			return 0;
		}

		@Override
		public byte[] encode() {
			byte[] _encode = encodeImpl();
			this._buffer = new byte[_encode.length + this.length()];
			this.writeBytes(_encode);
			return this.getBuffer();
		}

		@Override
		public void decode(byte[] buffer) {
			this._buffer = buffer;
		}

		public void decode() {
			this.decode(remainingBuffer());
		}

		@Override
		public String toString() {
			return "Add.Minecraft()";
		}

	}

}
