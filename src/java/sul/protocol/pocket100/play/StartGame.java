/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket100.xml
 */
package sul.protocol.pocket100.play;

import java.nio.charset.StandardCharsets;

import sul.utils.*;

public class StartGame extends Packet {

	public final static byte ID = (byte)12;

	public final static boolean CLIENTBOUND = true;
	public final static boolean SERVERBOUND = false;

	// dimension
	public final static int OVERWORLD = 0;
	public final static int NETHER = 1;
	public final static int END = 2;

	// generator
	public final static int OLD = 0;
	public final static int INFINITE = 1;
	public final static int FLAT = 2;

	// world gamemode
	public final static int SURVIVAL = 0;
	public final static int CREATIVE = 1;

	// difficulty
	public final static int PEACEFUL = 0;
	public final static int EASY = 1;
	public final static int NORMAL = 2;
	public final static int HARD = 3;

	// edition
	public final static byte CLASSIC = 0;
	public final static byte EDUCATION = 1;

	public long entityId;
	public long runtimeId;
	public Tuples.FloatXYZ position;
	public float yaw;
	public float pitch;
	public int seed;
	public int dimension;
	public int generator;
	public int worldGamemode;
	public int difficulty;
	public Tuples.IntXYZ spawnPosition;
	public boolean loadedInCreative;
	public int time;
	public byte edition;
	public float rainLevel;
	public float lightingLevel;
	public boolean cheatsEnabled;
	public boolean textureRequired;
	public String levelId;
	public String worldName;

	public StartGame() {}

	public StartGame(long entityId, long runtimeId, Tuples.FloatXYZ position, float yaw, float pitch, int seed, int dimension, int generator, int worldGamemode, int difficulty, Tuples.IntXYZ spawnPosition, boolean loadedInCreative, int time, byte edition, float rainLevel, float lightingLevel, boolean cheatsEnabled, boolean textureRequired, String levelId, String worldName) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.seed = seed;
		this.dimension = dimension;
		this.generator = generator;
		this.worldGamemode = worldGamemode;
		this.difficulty = difficulty;
		this.spawnPosition = spawnPosition;
		this.loadedInCreative = loadedInCreative;
		this.time = time;
		this.edition = edition;
		this.rainLevel = rainLevel;
		this.lightingLevel = lightingLevel;
		this.cheatsEnabled = cheatsEnabled;
		this.textureRequired = textureRequired;
		this.levelId = levelId;
		this.worldName = worldName;
	}

	@Override
	public int length() {
		return Var.Long.length(entityId) + Var.Long.length(runtimeId) + position.length() + Var.Int.length(seed) + Var.Int.length(dimension) + Var.Int.length(generator) + Var.Int.length(worldGamemode) + Var.Int.length(difficulty) + spawnPosition.length() + Var.Int.length(time) + Var.Uint.length(levelId.getBytes(StandardCharsets.UTF_8).length) + levelId.getBytes(StandardCharsets.UTF_8).length + Var.Uint.length(worldName.getBytes(StandardCharsets.UTF_8).length) + worldName.getBytes(StandardCharsets.UTF_8).length + 21;
	}

	@Override
	public byte[] encode() {
		this._buffer = new byte[this.length()];
		this.writeBigEndianByte(ID);
		this.writeVarlong(entityId);
		this.writeVarlong(runtimeId);
		this.writeLittleEndianFloat(position.x);this.writeLittleEndianFloat(position.y);this.writeLittleEndianFloat(position.z);
		this.writeLittleEndianFloat(yaw);
		this.writeLittleEndianFloat(pitch);
		this.writeVarint(seed);
		this.writeVarint(dimension);
		this.writeVarint(generator);
		this.writeVarint(worldGamemode);
		this.writeVarint(difficulty);
		this.writeVarint(spawnPosition.x);this.writeVarint(spawnPosition.y);this.writeVarint(spawnPosition.z);
		this._buffer[this._index++]=(byte)(loadedInCreative?1:0);
		this.writeVarint(time);
		this.writeBigEndianByte(edition);
		this.writeLittleEndianFloat(rainLevel);
		this.writeLittleEndianFloat(lightingLevel);
		this._buffer[this._index++]=(byte)(cheatsEnabled?1:0);
		this._buffer[this._index++]=(byte)(textureRequired?1:0);
		byte[] bgv2zwxjza=levelId.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)bgv2zwxjza.length); this.writeBytes(bgv2zwxjza);
		byte[] d29ybgroyw1l=worldName.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)d29ybgroyw1l.length); this.writeBytes(d29ybgroyw1l);
		return this._buffer;
	}

	@Override
	public void decode(byte[] buffer) {
		this._buffer = buffer;
		readBigEndianByte();
		entityId=varlong.decode(_buffer, _index);
		runtimeId=varlong.decode(_buffer, _index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		seed=varint.decode(_buffer, _index);
		dimension=varint.decode(_buffer, _index);
		generator=varint.decode(_buffer, _index);
		worldGamemode=varint.decode(_buffer, _index);
		difficulty=varint.decode(_buffer, _index);
		spawnPosition.x=varint.decode(_buffer, _index); spawnPosition.y=varint.decode(_buffer, _index); spawnPosition.z=varint.decode(_buffer, _index);
		loadedInCreative=this._index<this._buffer.length&&this._buffer[this._index++]!=0;
		time=varint.decode(_buffer, _index);
		edition=readBigEndianByte();
		rainLevel=readLittleEndianFloat();
		lightingLevel=readLittleEndianFloat();
		cheatsEnabled=this._index<this._buffer.length&&this._buffer[this._index++]!=0;
		textureRequired=this._index<this._buffer.length&&this._buffer[this._index++]!=0;
		int bgvubgv2zwxjza=varuint.decode(_buffer, _index); levelId=new String(this.readBytes(bgvubgv2zwxjza), StandardCharsets.UTF_8);
		int bgvud29ybgroyw1l=varuint.decode(_buffer, _index); worldName=new String(this.readBytes(bgvud29ybgroyw1l), StandardCharsets.UTF_8);
	}

	public static StartGame fromBuffer(byte[] buffer) {
		StartGame ret = new StartGame();
		ret.decode(buffer);
		return ret;
	}

}
