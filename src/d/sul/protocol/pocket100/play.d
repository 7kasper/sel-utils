/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket100.xml
 */
module sul.protocol.pocket100.play;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.pocket100.types;

alias Packets = TypeTuple!(Login, PlayStatus, ServerHandshake, ClientMagic, Disconnect, Batch, ResourcePacksInfo, ResourcePackClientResponse, Text, SetTime, StartGame, AddPlayer, AddEntity, RemoveEntity, AddItemEntity, AddHangingEntity, TakeItemEntity, MoveEntity, MovePlayer, RiderJump, RemoveBlock, UpdateBlock, AddPainting, Explode, LevelSoundEvent, LevelEvent, BlockEvent, EntityEvent, MobEffect, UpdateAttributes, MobEquipment, MobArmorEquipment, Interact, UseItem, PlayerAction, PlayerFall, HurtArmor, SetEntityData, SetEntityMotion, SetEntityLink, SetHealth, SetSpawnPosition, Animate, Respawn, DropItem, InventoryAction, ContainerOpen, ContainerClose, ContainerSetSlot, ContainerSetData, ContainerSetContent, CraftingData, CraftingEvent, AdventureSettings, BlockEntityData, PlayerInput, FullChunkData, SetCheatsEnabled, SetDifficulty, ChangeDimension, SetPlayerGametype, PlayerList, SpawnExperienceOrb, MapInfoRequest, RequestChunkRadius, ChunkRadiusUpdated, ItemFrameDropItem, ReplaceSelectedItem, Camera, AddItem, BossEvent, ShowCredits, AvailableCommands, CommandStep);

struct Login {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public uint protocol;
	public ubyte edition;
	public ubyte[] body_;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, protocol, buffer.length-uint.sizeof);
		buffer~=edition;
		buffer~=varuint.encode(body.length.to!uint);buffer~=body;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=uint.sizeof){ protocol=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ edition=read!(ubyte, Endian.bigEndian)(buffer); }
		body.length=varuint.decode(buffer);if(buffer.length>=body.length){ body=buffer[0..body.length]; buffer=buffer[body.length..$]; }
		return this;
	}

}

struct PlayStatus {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum uint OK = 0;
	public enum uint OUTDATED_CLIENT = 1;
	public enum uint OUTDATED_SERVER = 2;
	public enum uint SPAWNED = 3;
	public enum uint INVALID_TENANT = 4;
	public enum uint EDITION_MISMATCH = 5;

	public uint status;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, status, buffer.length-uint.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=uint.sizeof){ status=read!(uint, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ServerHandshake {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string serverPublicKey;
	public ubyte[] token;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		ubyte[] c2VydmVyUHVibGlj=cast(ubyte[])serverPublicKey; buffer~=varuint.encode(c2VydmVyUHVibGlj.length.to!uint);buffer~=c2VydmVyUHVibGlj;
		buffer~=varuint.encode(token.length.to!uint);buffer~=token;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		ubyte[] c2VydmVyUHVibGlj; c2VydmVyUHVibGlj.length=varuint.decode(buffer);if(buffer.length>=c2VydmVyUHVibGlj.length){ c2VydmVyUHVibGlj=buffer[0..c2VydmVyUHVibGlj.length]; buffer=buffer[c2VydmVyUHVibGlj.length..$]; }; serverPublicKey=cast(string)c2VydmVyUHVibGlj;
		token.length=varuint.decode(buffer);if(buffer.length>=token.length){ token=buffer[0..token.length]; buffer=buffer[token.length..$]; }
		return this;
	}

}

struct ClientMagic {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		return this;
	}

}

struct Disconnect {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool hideDisconnectionScreen;
	public string message;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, hideDisconnectionScreen, buffer.length-bool.sizeof);
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);buffer~=bWVzc2FnZQ;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=bool.sizeof){ hideDisconnectionScreen=read!(bool, Endian.bigEndian)(buffer); }
		ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(buffer);if(buffer.length>=bWVzc2FnZQ.length){ bWVzc2FnZQ=buffer[0..bWVzc2FnZQ.length]; buffer=buffer[bWVzc2FnZQ.length..$]; }; message=cast(string)bWVzc2FnZQ;
		return this;
	}

}

struct Batch {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(data.length.to!uint);buffer~=data;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		data.length=varuint.decode(buffer);if(buffer.length>=data.length){ data=buffer[0..data.length]; buffer=buffer[data.length..$]; }
		return this;
	}

}

struct ResourcePacksInfo {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool mustAccept;
	public types.Pack[] behaviourPacks;
	public types.Pack[] resourcePacks;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, mustAccept, buffer.length-bool.sizeof);
		buffer~=varuint.encode(behaviourPacks.length.to!uint);foreach(YmVoYXZpb3VyUGFj;behaviourPacks){ YmVoYXZpb3VyUGFj.encode(buffer); }
		buffer~=varuint.encode(resourcePacks.length.to!uint);foreach(cmVzb3VyY2VQYWNr;resourcePacks){ cmVzb3VyY2VQYWNr.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=bool.sizeof){ mustAccept=read!(bool, Endian.bigEndian)(buffer); }
		behaviourPacks.length=varuint.decode(buffer);foreach(ref YmVoYXZpb3VyUGFj;behaviourPacks){ YmVoYXZpb3VyUGFj.decode(buffer); }
		resourcePacks.length=varuint.decode(buffer);foreach(ref cmVzb3VyY2VQYWNr;resourcePacks){ cmVzb3VyY2VQYWNr.decode(buffer); }
		return this;
	}

}

struct ResourcePackClientResponse {

	public enum ubyte ID = 9;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte status;
	public ushort resourcePackVersion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=status;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, resourcePackVersion, buffer.length-ushort.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ status=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ resourcePackVersion=read!(ushort, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Text {

	public enum ubyte ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte type;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=type;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ type=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SetTime {

	public enum ubyte ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int time;
	public bool daylightCycle;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(time);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, daylightCycle, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		time=varint.decode(buffer);
		if(buffer.length>=bool.sizeof){ daylightCycle=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct StartGame {

	public enum ubyte ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	// generator
	public enum int OLD = 0;
	public enum int INFINITE = 1;
	public enum int FLAT = 2;

	// world gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	// difficulty
	public enum int PEACEFUL = 0;
	public enum int EASY = 1;
	public enum int NORMAL = 2;
	public enum int HARD = 3;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float yaw;
	public float pitch;
	public int seed;
	public int dimension;
	public int generator;
	public int worldGamemode;
	public int difficulty;
	public Tuple!(int, "x", int, "y", int, "z") spawnPosition;
	public bool loadedInCreative;
	public int time;
	public ubyte edition;
	public float rainLevel;
	public float lightingLevel;
	public bool cheatsEnabled;
	public bool textureRequired;
	public string levelId;
	public string worldName;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, yaw, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, pitch, buffer.length-float.sizeof);
		buffer~=varint.encode(seed);
		buffer~=varint.encode(dimension);
		buffer~=varint.encode(generator);
		buffer~=varint.encode(worldGamemode);
		buffer~=varint.encode(difficulty);
		buffer~=varint.encode(spawnPosition.x);buffer~=varint.encode(spawnPosition.y);buffer~=varint.encode(spawnPosition.z);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, loadedInCreative, buffer.length-bool.sizeof);
		buffer~=varint.encode(time);
		buffer~=edition;
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, rainLevel, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, lightingLevel, buffer.length-float.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, cheatsEnabled, buffer.length-bool.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, textureRequired, buffer.length-bool.sizeof);
		ubyte[] bGV2ZWxJZA=cast(ubyte[])levelId; buffer~=varuint.encode(bGV2ZWxJZA.length.to!uint);buffer~=bGV2ZWxJZA;
		ubyte[] d29ybGROYW1l=cast(ubyte[])worldName; buffer~=varuint.encode(d29ybGROYW1l.length.to!uint);buffer~=d29ybGROYW1l;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.littleEndian)(buffer); }
		seed=varint.decode(buffer);
		dimension=varint.decode(buffer);
		generator=varint.decode(buffer);
		worldGamemode=varint.decode(buffer);
		difficulty=varint.decode(buffer);
		spawnPosition.x=varint.decode(buffer);spawnPosition.y=varint.decode(buffer);spawnPosition.z=varint.decode(buffer);
		if(buffer.length>=bool.sizeof){ loadedInCreative=read!(bool, Endian.bigEndian)(buffer); }
		time=varint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ edition=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ rainLevel=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ lightingLevel=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ cheatsEnabled=read!(bool, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ textureRequired=read!(bool, Endian.bigEndian)(buffer); }
		ubyte[] bGV2ZWxJZA; bGV2ZWxJZA.length=varuint.decode(buffer);if(buffer.length>=bGV2ZWxJZA.length){ bGV2ZWxJZA=buffer[0..bGV2ZWxJZA.length]; buffer=buffer[bGV2ZWxJZA.length..$]; }; levelId=cast(string)bGV2ZWxJZA;
		ubyte[] d29ybGROYW1l; d29ybGROYW1l.length=varuint.decode(buffer);if(buffer.length>=d29ybGROYW1l.length){ d29ybGROYW1l=buffer[0..d29ybGROYW1l.length]; buffer=buffer[d29ybGROYW1l.length..$]; }; worldName=cast(string)d29ybGROYW1l;
		return this;
	}

}

struct AddPlayer {

	public enum ubyte ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public UUID uuid;
	public string username;
	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float headYaw;
	public float yaw;
	public types.Slot heldItem;
	public types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=uuid.data;
		ubyte[] dXNlcm5hbWU=cast(ubyte[])username; buffer~=varuint.encode(dXNlcm5hbWU.length.to!uint);buffer~=dXNlcm5hbWU;
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, pitch, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, headYaw, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, yaw, buffer.length-float.sizeof);
		heldItem.encode(buffer);
		metadata.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		ubyte[] dXNlcm5hbWU; dXNlcm5hbWU.length=varuint.decode(buffer);if(buffer.length>=dXNlcm5hbWU.length){ dXNlcm5hbWU=buffer[0..dXNlcm5hbWU.length]; buffer=buffer[dXNlcm5hbWU.length..$]; }; username=cast(string)dXNlcm5hbWU;
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ motion.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ headYaw=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.littleEndian)(buffer); }
		heldItem.decode(buffer);
		metadata.decode(buffer);
		return this;
	}

}

struct AddEntity {

	public enum ubyte ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public uint type;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float yaw;
	public types.Attribute[] attributes;
	public types.Metadata metadata;
	public long[] links;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		buffer~=varuint.encode(type);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, pitch, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, yaw, buffer.length-float.sizeof);
		buffer~=varuint.encode(attributes.length.to!uint);foreach(YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.encode(buffer); }
		metadata.encode(buffer);
		buffer~=varuint.encode(links.length.to!uint);foreach(bGlua3M;links){ buffer~=varlong.encode(bGlua3M); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		type=varuint.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ motion.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.littleEndian)(buffer); }
		attributes.length=varuint.decode(buffer);foreach(ref YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.decode(buffer); }
		metadata.decode(buffer);
		links.length=varuint.decode(buffer);foreach(ref bGlua3M;links){ bGlua3M=varlong.decode(buffer); }
		return this;
	}

}

struct RemoveEntity {

	public enum ubyte ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		return this;
	}

}

struct AddItemEntity {

	public enum ubyte ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public types.Slot item;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		item.encode(buffer);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.z, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		item.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ motion.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.z=read!(float, Endian.littleEndian)(buffer); }
		return this;
	}

}

struct AddHangingEntity {

	public enum ubyte ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public types.BlockPosition position;
	public int ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		position.encode(buffer);
		buffer~=varint.encode(?);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		position.decode(buffer);
		?=varint.decode(buffer);
		return this;
	}

}

struct TakeItemEntity {

	public enum ubyte ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long taken;
	public long collector;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(taken);
		buffer~=varlong.encode(collector);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		taken=varlong.decode(buffer);
		collector=varlong.decode(buffer);
		return this;
	}

}

struct MoveEntity {

	public enum ubyte ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, pitch, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, headYaw, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, yaw, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ headYaw=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.littleEndian)(buffer); }
		return this;
	}

}

struct MovePlayer {

	public enum ubyte ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// animation
	public enum ubyte FULL = 0;
	public enum ubyte NONE = 1;
	public enum ubyte ROTATION = 2;

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;
	public ubyte animation;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, pitch, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, headYaw, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, yaw, buffer.length-float.sizeof);
		buffer~=animation;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, onGround, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ headYaw=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ animation=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ onGround=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct RiderJump {

	public enum ubyte ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public long rider;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(rider);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		rider=varlong.decode(buffer);
		return this;
	}

}

struct RemoveBlock {

	public enum ubyte ID = 22;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public types.BlockPosition position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		position.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		position.decode(buffer);
		return this;
	}

}

struct UpdateBlock {

	public enum ubyte ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags and meta
	public enum uint NEIGHBORS = 1;
	public enum uint NETWORK = 2;
	public enum uint NO_GRAPHIC = 4;
	public enum uint PRIORITY = 8;

	public types.BlockPosition position;
	public uint block;
	public uint flagsAndMeta;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		position.encode(buffer);
		buffer~=varuint.encode(block);
		buffer~=varuint.encode(flagsAndMeta);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		position.decode(buffer);
		block=varuint.decode(buffer);
		flagsAndMeta=varuint.decode(buffer);
		return this;
	}

}

struct AddPainting {

	public enum ubyte ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public types.BlockPosition position;
	public int direction;
	public string title;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		position.encode(buffer);
		buffer~=varint.encode(direction);
		ubyte[] dGl0bGU=cast(ubyte[])title; buffer~=varuint.encode(dGl0bGU.length.to!uint);buffer~=dGl0bGU;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		position.decode(buffer);
		direction=varint.decode(buffer);
		ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(buffer);if(buffer.length>=dGl0bGU.length){ dGl0bGU=buffer[0..dGl0bGU.length]; buffer=buffer[dGl0bGU.length..$]; }; title=cast(string)dGl0bGU;
		return this;
	}

}

struct Explode {

	public enum ubyte ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public types.BlockPosition[] destroyedBlocks;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, radius, buffer.length-float.sizeof);
		buffer~=varuint.encode(destroyedBlocks.length.to!uint);foreach(ZGVzdHJveWVkQmxv;destroyedBlocks){ ZGVzdHJveWVkQmxv.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ radius=read!(float, Endian.littleEndian)(buffer); }
		destroyedBlocks.length=varuint.decode(buffer);foreach(ref ZGVzdHJveWVkQmxv;destroyedBlocks){ ZGVzdHJveWVkQmxv.decode(buffer); }
		return this;
	}

}

struct LevelSoundEvent {

	public enum ubyte ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte sound;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public uint volume;
	public int pitch;
	public bool ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=sound;
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer~=varuint.encode(volume);
		buffer~=varint.encode(pitch);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, ?, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ sound=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		volume=varuint.decode(buffer);
		pitch=varint.decode(buffer);
		if(buffer.length>=bool.sizeof){ ?=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct LevelEvent {

	public enum ubyte ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum int START_RAIN = 3001;
	public enum int START_THUNDER = 3002;
	public enum int STOP_RAIN = 3003;
	public enum int STOP_THUNDER = 3004;
	public enum int SET_DATA = 4000;
	public enum int PLAYERS_SLEEPING = 9800;

	public int eventId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(eventId);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer~=varint.encode(data);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		eventId=varint.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		data=varint.decode(buffer);
		return this;
	}

}

struct BlockEvent {

	public enum ubyte ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public types.BlockPosition position;
	public int[2] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		position.encode(buffer);
		foreach(ZGF0YQ;data){ buffer~=varint.encode(ZGF0YQ); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		position.decode(buffer);
		foreach(ref ZGF0YQ;data){ ZGF0YQ=varint.decode(buffer); }
		return this;
	}

}

struct EntityEvent {

	public enum ubyte ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// event id
	public enum ubyte HURT_ANIMATION = 2;
	public enum ubyte DEATH_ANIMATION = 3;
	public enum ubyte TAME_FAIL = 6;
	public enum ubyte TAME_SUCCESS = 7;
	public enum ubyte SHAKE_WET = 8;
	public enum ubyte USE_ITEM = 9;
	public enum ubyte EAT_GRASS_ANIMATION = 10;
	public enum ubyte FISH_HOOK_BUBBLES = 11;
	public enum ubyte FISH_HOOK_POSITION = 12;
	public enum ubyte FISH_HOOK_HOOK = 13;
	public enum ubyte FISH_HOOK_TEASE = 14;
	public enum ubyte SQUID_INK_CLOUD = 15;
	public enum ubyte AMBIENT_SOUND = 16;
	public enum ubyte RESPAWN = 17;

	public long entityId;
	public ubyte eventId;
	public int ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=eventId;
		buffer~=varint.encode(?);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ eventId=read!(ubyte, Endian.bigEndian)(buffer); }
		?=varint.decode(buffer);
		return this;
	}

}

struct MobEffect {

	public enum ubyte ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum ubyte ADD = 0;
	public enum ubyte MODIFY = 1;
	public enum ubyte REMOVE = 2;

	public long entityId;
	public ubyte eventId;
	public int effect;
	public int amplifier;
	public bool particles;
	public int duration;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=eventId;
		buffer~=varint.encode(effect);
		buffer~=varint.encode(amplifier);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, particles, buffer.length-bool.sizeof);
		buffer~=varint.encode(duration);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ eventId=read!(ubyte, Endian.bigEndian)(buffer); }
		effect=varint.decode(buffer);
		amplifier=varint.decode(buffer);
		if(buffer.length>=bool.sizeof){ particles=read!(bool, Endian.bigEndian)(buffer); }
		duration=varint.decode(buffer);
		return this;
	}

}

struct UpdateAttributes {

	public enum ubyte ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public types.Attribute[] attributes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varuint.encode(attributes.length.to!uint);foreach(YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		attributes.length=varuint.decode(buffer);foreach(ref YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.decode(buffer); }
		return this;
	}

}

struct MobEquipment {

	public enum ubyte ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public long entityId;
	public types.Slot item;
	public ubyte slot;
	public ubyte selectedSlot;
	public ubyte ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		item.encode(buffer);
		buffer~=slot;
		buffer~=selectedSlot;
		buffer~=?;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		item.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ slot=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ selectedSlot=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ ?=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct MobArmorEquipment {

	public enum ubyte ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public long entityId;
	public types.Slot[4] armor;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		foreach(YXJtb3I;armor){ YXJtb3I.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		foreach(ref YXJtb3I;armor){ YXJtb3I.decode(buffer); }
		return this;
	}

}

struct Interact {

	public enum ubyte ID = 34;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte ATTACK = 1;
	public enum ubyte INTERACT = 2;
	public enum ubyte LEAVE_VEHICLE = 3;
	public enum ubyte HOVER = 4;

	public ubyte action;
	public long target;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=action;
		buffer~=varlong.encode(target);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		target=varlong.decode(buffer);
		return this;
	}

}

struct UseItem {

	public enum ubyte ID = 35;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public types.BlockPosition blockPosition;
	public uint hotbarSlot;
	public int face;
	public Tuple!(float, "x", float, "y", float, "z") facePosition;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int slot;
	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		blockPosition.encode(buffer);
		buffer~=varuint.encode(hotbarSlot);
		buffer~=varint.encode(face);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, facePosition.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, facePosition.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, facePosition.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer~=varint.encode(slot);
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		blockPosition.decode(buffer);
		hotbarSlot=varuint.decode(buffer);
		face=varint.decode(buffer);
		if(buffer.length>=float.sizeof){ facePosition.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ facePosition.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ facePosition.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		slot=varint.decode(buffer);
		item.decode(buffer);
		return this;
	}

}

struct PlayerAction {

	public enum ubyte ID = 36;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum int START_BREAK = 0;
	public enum int ABORT_BREAK = 1;
	public enum int STOP_BREAK = 2;
	public enum int RELEASE_ITEM = 5;
	public enum int STOP_SLEEPING = 6;
	public enum int RESPAWN = 7;
	public enum int JUMP = 8;
	public enum int START_SPRINT = 9;
	public enum int STOP_SPRINT = 10;
	public enum int START_SNEAK = 11;
	public enum int STOP_SNEAK = 12;
	public enum int DIMENSION_CHANGE = 13;
	public enum int ABORT_DIMENSION_CHANGE = 14;
	public enum int START_GLIDING = 15;
	public enum int STOP_GLIDING = 16;

	public long entityId;
	public int action;
	public types.BlockPosition position;
	public int face;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varint.encode(action);
		position.encode(buffer);
		buffer~=varint.encode(face);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		action=varint.decode(buffer);
		position.decode(buffer);
		face=varint.decode(buffer);
		return this;
	}

}

struct PlayerFall {

	public enum ubyte ID = 37;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public float distance;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, distance, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=float.sizeof){ distance=read!(float, Endian.littleEndian)(buffer); }
		return this;
	}

}

struct HurtArmor {

	public enum ubyte ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int health;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(health);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		health=varint.decode(buffer);
		return this;
	}

}

struct SetEntityData {

	public enum ubyte ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		metadata.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		metadata.decode(buffer);
		return this;
	}

}

struct SetEntityMotion {

	public enum ubyte ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.z, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		if(buffer.length>=float.sizeof){ motion.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.z=read!(float, Endian.littleEndian)(buffer); }
		return this;
	}

}

struct SetEntityLink {

	public enum ubyte ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public long from;
	public long to;
	public ubyte action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(from);
		buffer~=varlong.encode(to);
		buffer~=action;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		from=varlong.decode(buffer);
		to=varlong.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SetHealth {

	public enum ubyte ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int health;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(health);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		health=varint.decode(buffer);
		return this;
	}

}

struct SetSpawnPosition {

	public enum ubyte ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int ?;
	public types.BlockPosition position;
	public bool ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(?);
		position.encode(buffer);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, ?, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		?=varint.decode(buffer);
		position.decode(buffer);
		if(buffer.length>=bool.sizeof){ ?=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Animate {

	public enum ubyte ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// action
	public enum int BREAKING = 1;
	public enum int WAKE_UP = 3;

	public int action;
	public long entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(action);
		buffer~=varlong.encode(entityId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		action=varint.decode(buffer);
		entityId=varlong.decode(buffer);
		return this;
	}

}

struct Respawn {

	public enum ubyte ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		return this;
	}

}

struct DropItem {

	public enum ubyte ID = 46;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte DROP = 0;

	public ubyte action;
	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=action;
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		item.decode(buffer);
		return this;
	}

}

struct InventoryAction {

	public enum ubyte ID = 47;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public int action;
	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(action);
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		action=varint.decode(buffer);
		item.decode(buffer);
		return this;
	}

}

struct ContainerOpen {

	public enum ubyte ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ubyte type;
	public int slotCount;
	public types.BlockPosition position;
	public long entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=window;
		buffer~=type;
		buffer~=varint.encode(slotCount);
		position.encode(buffer);
		buffer~=varlong.encode(entityId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ type=read!(ubyte, Endian.bigEndian)(buffer); }
		slotCount=varint.decode(buffer);
		position.decode(buffer);
		entityId=varlong.decode(buffer);
		return this;
	}

}

struct ContainerClose {

	public enum ubyte ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=window;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ContainerSetSlot {

	public enum ubyte ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public int slot;
	public int hotbarSlot;
	public types.Slot item;
	public ubyte ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=window;
		buffer~=varint.encode(slot);
		buffer~=varint.encode(hotbarSlot);
		item.encode(buffer);
		buffer~=?;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		slot=varint.decode(buffer);
		hotbarSlot=varint.decode(buffer);
		item.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ ?=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ContainerSetData {

	public enum ubyte ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public int property;
	public int value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=window;
		buffer~=varint.encode(property);
		buffer~=varint.encode(value);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		property=varint.decode(buffer);
		value=varint.decode(buffer);
		return this;
	}

}

struct ContainerSetContent {

	public enum ubyte ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public types.Slot[] slots;
	public int[] hotbar;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=window;
		buffer~=varuint.encode(slots.length.to!uint);foreach(c2xvdHM;slots){ c2xvdHM.encode(buffer); }
		buffer~=varuint.encode(hotbar.length.to!uint);foreach(aG90YmFy;hotbar){ buffer~=varint.encode(aG90YmFy); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		slots.length=varuint.decode(buffer);foreach(ref c2xvdHM;slots){ c2xvdHM.decode(buffer); }
		hotbar.length=varuint.decode(buffer);foreach(ref aG90YmFy;hotbar){ aG90YmFy=varint.decode(buffer); }
		return this;
	}

}

struct CraftingData {

	public enum ubyte ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public types.Recipe[] recipes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(recipes.length.to!uint);foreach(cmVjaXBlcw;recipes){ cmVjaXBlcw.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		recipes.length=varuint.decode(buffer);foreach(ref cmVjaXBlcw;recipes){ cmVjaXBlcw.decode(buffer); }
		return this;
	}

}

struct CraftingEvent {

	public enum ubyte ID = 54;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte window;
	public int type;
	public UUID uuid;
	public types.Slot[] input;
	public types.Slot[] output;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=window;
		buffer~=varint.encode(type);
		buffer~=uuid.data;
		buffer~=varuint.encode(input.length.to!uint);foreach(aW5wdXQ;input){ aW5wdXQ.encode(buffer); }
		buffer~=varuint.encode(output.length.to!uint);foreach(b3V0cHV0;output){ b3V0cHV0.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		type=varint.decode(buffer);
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		input.length=varuint.decode(buffer);foreach(ref aW5wdXQ;input){ aW5wdXQ.decode(buffer); }
		output.length=varuint.decode(buffer);foreach(ref b3V0cHV0;output){ b3V0cHV0.decode(buffer); }
		return this;
	}

}

struct AdventureSettings {

	public enum ubyte ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// flags
	public enum uint IMMUTABLE_WORLD = 1;
	public enum uint PVP_DISABLED = 2;
	public enum uint PVM_DISABLED = 4;
	public enum uint MVP_DISBALED = 8;
	public enum uint EVP_DISABLED = 16;
	public enum uint AUTO_JUMP = 32;
	public enum uint ALLOW_FLIGHT = 64;
	public enum uint NO_CLIP = 256;
	public enum uint FLYING = 1024;

	// permissions
	public enum uint USER = 0;
	public enum uint OPERATOR = 1;
	public enum uint HOST = 2;
	public enum uint AUTOMATION = 3;
	public enum uint ADMIN = 4;

	public uint flags;
	public uint permissions;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(flags);
		buffer~=varuint.encode(permissions);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		flags=varuint.decode(buffer);
		permissions=varuint.decode(buffer);
		return this;
	}

}

struct BlockEntityData {

	public enum ubyte ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public types.BlockPosition position;
	public ubyte[] nbt;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		position.encode(buffer);
		buffer~=nbt;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		position.decode(buffer);
		nbt=buffer.dup; buffer.length=0;
		return this;
	}

}

struct PlayerInput {

	public enum ubyte ID = 57;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public Tuple!(float, "x", float, "y", float, "z") motion;
	public ubyte flags;
	public bool ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, motion.z, buffer.length-float.sizeof);
		buffer~=flags;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, ?, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=float.sizeof){ motion.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ flags=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ ?=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct FullChunkData {

	public enum ubyte ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") position;
	public ubyte[] data;
	public ubyte[] tiles;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(position.x);buffer~=varint.encode(position.z);
		buffer~=varuint.encode(data.length.to!uint);buffer~=data;
		buffer~=varuint.encode(tiles.length.to!uint);buffer~=tiles;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		position.x=varint.decode(buffer);position.z=varint.decode(buffer);
		data.length=varuint.decode(buffer);if(buffer.length>=data.length){ data=buffer[0..data.length]; buffer=buffer[data.length..$]; }
		tiles.length=varuint.decode(buffer);if(buffer.length>=tiles.length){ tiles=buffer[0..tiles.length]; buffer=buffer[tiles.length..$]; }
		return this;
	}

}

struct SetCheatsEnabled {

	public enum ubyte ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool enabled;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, enabled, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=bool.sizeof){ enabled=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SetDifficulty {

	public enum ubyte ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum uint PEACEFUL = 0;
	public enum uint EASY = 1;
	public enum uint NORMAL = 2;
	public enum uint HARD = 3;

	public uint difficulty;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(difficulty);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		difficulty=varuint.decode(buffer);
		return this;
	}

}

struct ChangeDimension {

	public enum ubyte ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	public int dimension;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public bool ?;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(dimension);
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, ?, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		dimension=varint.decode(buffer);
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ ?=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SetPlayerGametype {

	public enum ubyte ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// gametype
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	public int gametype;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(gametype);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		gametype=varint.decode(buffer);
		return this;
	}

}

struct PlayerList {

	public enum ubyte ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=action;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SpawnExperienceOrb {

	public enum ubyte ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;
	public int count;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer~=varint.encode(count);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.littleEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.littleEndian)(buffer); }
		count=varint.decode(buffer);
		return this;
	}

}

struct MapInfoRequest {

	public enum ubyte ID = 67;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public long mapId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(mapId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		mapId=varlong.decode(buffer);
		return this;
	}

}

struct RequestChunkRadius {

	public enum ubyte ID = 68;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public int radius;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(radius);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		radius=varint.decode(buffer);
		return this;
	}

}

struct ChunkRadiusUpdated {

	public enum ubyte ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int radius;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varint.encode(radius);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		radius=varint.decode(buffer);
		return this;
	}

}

struct ItemFrameDropItem {

	public enum ubyte ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public types.BlockPosition position;
	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		position.encode(buffer);
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		position.decode(buffer);
		item.decode(buffer);
		return this;
	}

}

struct ReplaceSelectedItem {

	public enum ubyte ID = 71;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		item.decode(buffer);
		return this;
	}

}

struct Camera {

	public enum ubyte ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varlong.encode(runtimeId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		runtimeId=varlong.decode(buffer);
		return this;
	}

}

struct AddItem {

	public enum ubyte ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		item.decode(buffer);
		return this;
	}

}

struct BossEvent {

	public enum ubyte ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum uint ADD = 0;
	public enum uint UPDATE = 1;
	public enum uint REMOVE = 2;

	public long entityId;
	public uint eventId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varlong.encode(entityId);
		buffer~=varuint.encode(eventId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		entityId=varlong.decode(buffer);
		eventId=varuint.decode(buffer);
		return this;
	}

}

struct ShowCredits {

	public enum ubyte ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		return this;
	}

}

struct AvailableCommands {

	public enum ubyte ID = 77;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string commands;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		ubyte[] Y29tbWFuZHM=cast(ubyte[])commands; buffer~=varuint.encode(Y29tbWFuZHM.length.to!uint);buffer~=Y29tbWFuZHM;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		ubyte[] Y29tbWFuZHM; Y29tbWFuZHM.length=varuint.decode(buffer);if(buffer.length>=Y29tbWFuZHM.length){ Y29tbWFuZHM=buffer[0..Y29tbWFuZHM.length]; buffer=buffer[Y29tbWFuZHM.length..$]; }; commands=cast(string)Y29tbWFuZHM;
		return this;
	}

}

struct CommandStep {

	public enum ubyte ID = 78;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public string command;
	public string overload;
	public uint ?;
	public uint ?;
	public bool isOutput;
	public ulong ?;
	public string input;
	public string output;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		ubyte[] Y29tbWFuZA=cast(ubyte[])command; buffer~=varuint.encode(Y29tbWFuZA.length.to!uint);buffer~=Y29tbWFuZA;
		ubyte[] b3ZlcmxvYWQ=cast(ubyte[])overload; buffer~=varuint.encode(b3ZlcmxvYWQ.length.to!uint);buffer~=b3ZlcmxvYWQ;
		buffer~=varuint.encode(?);
		buffer~=varuint.encode(?);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, isOutput, buffer.length-bool.sizeof);
		buffer~=varulong.encode(?);
		ubyte[] aW5wdXQ=cast(ubyte[])input; buffer~=varuint.encode(aW5wdXQ.length.to!uint);buffer~=aW5wdXQ;
		ubyte[] b3V0cHV0=cast(ubyte[])output; buffer~=varuint.encode(b3V0cHV0.length.to!uint);buffer~=b3V0cHV0;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		ubyte[] Y29tbWFuZA; Y29tbWFuZA.length=varuint.decode(buffer);if(buffer.length>=Y29tbWFuZA.length){ Y29tbWFuZA=buffer[0..Y29tbWFuZA.length]; buffer=buffer[Y29tbWFuZA.length..$]; }; command=cast(string)Y29tbWFuZA;
		ubyte[] b3ZlcmxvYWQ; b3ZlcmxvYWQ.length=varuint.decode(buffer);if(buffer.length>=b3ZlcmxvYWQ.length){ b3ZlcmxvYWQ=buffer[0..b3ZlcmxvYWQ.length]; buffer=buffer[b3ZlcmxvYWQ.length..$]; }; overload=cast(string)b3ZlcmxvYWQ;
		?=varuint.decode(buffer);
		?=varuint.decode(buffer);
		if(buffer.length>=bool.sizeof){ isOutput=read!(bool, Endian.bigEndian)(buffer); }
		?=varulong.decode(buffer);
		ubyte[] aW5wdXQ; aW5wdXQ.length=varuint.decode(buffer);if(buffer.length>=aW5wdXQ.length){ aW5wdXQ=buffer[0..aW5wdXQ.length]; buffer=buffer[aW5wdXQ.length..$]; }; input=cast(string)aW5wdXQ;
		ubyte[] b3V0cHV0; b3V0cHV0.length=varuint.decode(buffer);if(buffer.length>=b3V0cHV0.length){ b3V0cHV0=buffer[0..b3V0cHV0.length]; buffer=buffer[b3V0cHV0.length..$]; }; output=cast(string)b3V0cHV0;
		return this;
	}

}
