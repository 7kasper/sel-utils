/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket100.xml
 */
module sul.protocol.pocket100.play;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.pocket100.types;

alias Packets = TypeTuple!(Login, PlayStatus, ServerHandshake, ClientMagic, Disconnect, Batch, ResourcePacksInfo, ResourcePackClientResponse, Text, SetTime, StartGame, AddPlayer, AddEntity, RemoveEntity, AddItemEntity, AddHangingEntity, TakeItemEntity, MoveEntity, MovePlayer, RiderJump, RemoveBlock, UpdateBlock, AddPainting, Explode, LevelSoundEvent, LevelEvent, BlockEvent, EntityEvent, MobEffect, UpdateAttributes, MobEquipment, MobArmorEquipment, Interact, UseItem, PlayerAction, PlayerFall, HurtArmor, SetEntityData, SetEntityMotion, SetEntityLink, SetHealth, SetSpawnPosition, Animate, Respawn, DropItem, InventoryAction, ContainerOpen, ContainerClose, ContainerSetSlot, ContainerSetData, ContainerSetContent, CraftingData, CraftingEvent, AdventureSettings, BlockEntityData, PlayerInput, FullChunkData, SetCheatsEnabled, SetDifficulty, ChangeDimension, SetPlayerGametype, PlayerList, SpawnExperienceOrb, MapInfoRequest, RequestChunkRadius, ChunkRadiusUpdated, ItemFrameDropItem, ReplaceSelectedItem, Camera, AddItem, BossEvent, ShowCredits, AvailableCommands, CommandStep);

struct Login {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public uint protocol;
	public ubyte edition;
	public ubyte[] body_;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, protocol, _buffer.length-uint.sizeof);
		_buffer~=edition;
		_buffer~=varuint.encode(body_.length.to!uint);_buffer~=body_;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+uint.sizeof){ protocol=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ edition=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		body_.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+body_.length){ body_=_buffer[*_index..*_index+body_.length].dup; *_index+=body_.length; }
		return this;
	}

}

struct PlayStatus {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum uint OK = 0;
	public enum uint OUTDATED_CLIENT = 1;
	public enum uint OUTDATED_SERVER = 2;
	public enum uint SPAWNED = 3;
	public enum uint INVALID_TENANT = 4;
	public enum uint EDITION_MISMATCH = 5;

	public uint status;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, status, _buffer.length-uint.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+uint.sizeof){ status=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct ServerHandshake {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string serverPublicKey;
	public ubyte[] token;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		ubyte[] c2VydmVyUHVibGlj=cast(ubyte[])serverPublicKey; _buffer~=varuint.encode(c2VydmVyUHVibGlj.length.to!uint);_buffer~=c2VydmVyUHVibGlj;
		_buffer~=varuint.encode(token.length.to!uint);_buffer~=token;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		ubyte[] c2VydmVyUHVibGlj; c2VydmVyUHVibGlj.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+c2VydmVyUHVibGlj.length){ c2VydmVyUHVibGlj=_buffer[*_index..*_index+c2VydmVyUHVibGlj.length].dup; *_index+=c2VydmVyUHVibGlj.length; }; serverPublicKey=cast(string)c2VydmVyUHVibGlj;
		token.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+token.length){ token=_buffer[*_index..*_index+token.length].dup; *_index+=token.length; }
		return this;
	}

}

struct ClientMagic {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		return this;
	}

}

struct Disconnect {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool hideDisconnectionScreen;
	public string message;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, hideDisconnectionScreen, _buffer.length-bool.sizeof);
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+bool.sizeof){ hideDisconnectionScreen=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
		return this;
	}

}

struct Batch {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varuint.encode(data.length.to!uint);_buffer~=data;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		data.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+data.length){ data=_buffer[*_index..*_index+data.length].dup; *_index+=data.length; }
		return this;
	}

}

struct ResourcePacksInfo {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool mustAccept;
	public sul.protocol.pocket100.types.Pack[] behaviourPacks;
	public sul.protocol.pocket100.types.Pack[] resourcePacks;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, mustAccept, _buffer.length-bool.sizeof);
		_buffer~=varuint.encode(behaviourPacks.length.to!uint);foreach(YmVoYXZpb3VyUGFj;behaviourPacks){ YmVoYXZpb3VyUGFj.encode(_buffer); }
		_buffer~=varuint.encode(resourcePacks.length.to!uint);foreach(cmVzb3VyY2VQYWNr;resourcePacks){ cmVzb3VyY2VQYWNr.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+bool.sizeof){ mustAccept=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		behaviourPacks.length=varuint.decode(_buffer, *_index);foreach(ref YmVoYXZpb3VyUGFj;behaviourPacks){ YmVoYXZpb3VyUGFj.decode(_buffer, _index); }
		resourcePacks.length=varuint.decode(_buffer, *_index);foreach(ref cmVzb3VyY2VQYWNr;resourcePacks){ cmVzb3VyY2VQYWNr.decode(_buffer, _index); }
		return this;
	}

}

struct ResourcePackClientResponse {

	public enum ubyte ID = 9;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte status;
	public ushort resourcePackVersion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=status;
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, resourcePackVersion, _buffer.length-ushort.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ status=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ resourcePackVersion=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Text {

	public enum ubyte ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte type;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=type;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ type=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

	public struct Raw {

		public enum typeof(type) TYPE = 0;

		public string message;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			return this;
		}

	}

	public struct Chat {

		public enum typeof(type) TYPE = 1;

		public string sender;
		public string message;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] c2VuZGVy=cast(ubyte[])sender; _buffer~=varuint.encode(c2VuZGVy.length.to!uint);_buffer~=c2VuZGVy;
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] c2VuZGVy; c2VuZGVy.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+c2VuZGVy.length){ c2VuZGVy=_buffer[*_index..*_index+c2VuZGVy.length].dup; *_index+=c2VuZGVy.length; }; sender=cast(string)c2VuZGVy;
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			return this;
		}

	}

	public struct Translation {

		public enum typeof(type) TYPE = 2;

		public string message;
		public string[] parameters;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
			_buffer~=varuint.encode(parameters.length.to!uint);foreach(cGFyYW1ldGVycw;parameters){ ubyte[] Y0dGeVlXMWxkR1Z5=cast(ubyte[])cGFyYW1ldGVycw; _buffer~=varuint.encode(Y0dGeVlXMWxkR1Z5.length.to!uint);_buffer~=Y0dGeVlXMWxkR1Z5; }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			parameters.length=varuint.decode(_buffer, *_index);foreach(ref cGFyYW1ldGVycw;parameters){ ubyte[] Y0dGeVlXMWxkR1Z5; Y0dGeVlXMWxkR1Z5.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+Y0dGeVlXMWxkR1Z5.length){ Y0dGeVlXMWxkR1Z5=_buffer[*_index..*_index+Y0dGeVlXMWxkR1Z5.length].dup; *_index+=Y0dGeVlXMWxkR1Z5.length; }; cGFyYW1ldGVycw=cast(string)Y0dGeVlXMWxkR1Z5; }
			return this;
		}

	}

	public struct Popup {

		public enum typeof(type) TYPE = 3;

		public string title;
		public string subtitle;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] dGl0bGU=cast(ubyte[])title; _buffer~=varuint.encode(dGl0bGU.length.to!uint);_buffer~=dGl0bGU;
			ubyte[] c3VidGl0bGU=cast(ubyte[])subtitle; _buffer~=varuint.encode(c3VidGl0bGU.length.to!uint);_buffer~=c3VidGl0bGU;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+dGl0bGU.length){ dGl0bGU=_buffer[*_index..*_index+dGl0bGU.length].dup; *_index+=dGl0bGU.length; }; title=cast(string)dGl0bGU;
			ubyte[] c3VidGl0bGU; c3VidGl0bGU.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+c3VidGl0bGU.length){ c3VidGl0bGU=_buffer[*_index..*_index+c3VidGl0bGU.length].dup; *_index+=c3VidGl0bGU.length; }; subtitle=cast(string)c3VidGl0bGU;
			return this;
		}

	}

	public struct Tip {

		public enum typeof(type) TYPE = 4;

		public string message;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			return this;
		}

	}

	public struct System {

		public enum typeof(type) TYPE = 5;

		public string message;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			return this;
		}

	}

	public struct Whisper {

		public enum typeof(type) TYPE = 6;

		public string sender;
		public string message;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] c2VuZGVy=cast(ubyte[])sender; _buffer~=varuint.encode(c2VuZGVy.length.to!uint);_buffer~=c2VuZGVy;
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);_buffer~=bWVzc2FnZQ;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] c2VuZGVy; c2VuZGVy.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+c2VuZGVy.length){ c2VuZGVy=_buffer[*_index..*_index+c2VuZGVy.length].dup; *_index+=c2VuZGVy.length; }; sender=cast(string)c2VuZGVy;
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			return this;
		}

	}

}

struct SetTime {

	public enum ubyte ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int time;
	public bool daylightCycle;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(time);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, daylightCycle, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		time=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+bool.sizeof){ daylightCycle=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct StartGame {

	public enum ubyte ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	// generator
	public enum int OLD = 0;
	public enum int INFINITE = 1;
	public enum int FLAT = 2;

	// world gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	// difficulty
	public enum int PEACEFUL = 0;
	public enum int EASY = 1;
	public enum int NORMAL = 2;
	public enum int HARD = 3;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float yaw;
	public float pitch;
	public int seed;
	public int dimension;
	public int generator;
	public int worldGamemode;
	public int difficulty;
	public Tuple!(int, "x", int, "y", int, "z") spawnPosition;
	public bool loadedInCreative;
	public int time;
	public ubyte edition;
	public float rainLevel;
	public float lightingLevel;
	public bool cheatsEnabled;
	public bool textureRequired;
	public string levelId;
	public string worldName;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		_buffer~=varint.encode(seed);
		_buffer~=varint.encode(dimension);
		_buffer~=varint.encode(generator);
		_buffer~=varint.encode(worldGamemode);
		_buffer~=varint.encode(difficulty);
		_buffer~=varint.encode(spawnPosition.x);_buffer~=varint.encode(spawnPosition.y);_buffer~=varint.encode(spawnPosition.z);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, loadedInCreative, _buffer.length-bool.sizeof);
		_buffer~=varint.encode(time);
		_buffer~=edition;
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, rainLevel, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, lightingLevel, _buffer.length-float.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, cheatsEnabled, _buffer.length-bool.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, textureRequired, _buffer.length-bool.sizeof);
		ubyte[] bGV2ZWxJZA=cast(ubyte[])levelId; _buffer~=varuint.encode(bGV2ZWxJZA.length.to!uint);_buffer~=bGV2ZWxJZA;
		ubyte[] d29ybGROYW1l=cast(ubyte[])worldName; _buffer~=varuint.encode(d29ybGROYW1l.length.to!uint);_buffer~=d29ybGROYW1l;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.littleEndian)(_buffer, _index); }
		seed=varint.decode(_buffer, *_index);
		dimension=varint.decode(_buffer, *_index);
		generator=varint.decode(_buffer, *_index);
		worldGamemode=varint.decode(_buffer, *_index);
		difficulty=varint.decode(_buffer, *_index);
		spawnPosition.x=varint.decode(_buffer, *_index);spawnPosition.y=varint.decode(_buffer, *_index);spawnPosition.z=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+bool.sizeof){ loadedInCreative=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		time=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ edition=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ rainLevel=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ lightingLevel=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ cheatsEnabled=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ textureRequired=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		ubyte[] bGV2ZWxJZA; bGV2ZWxJZA.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+bGV2ZWxJZA.length){ bGV2ZWxJZA=_buffer[*_index..*_index+bGV2ZWxJZA.length].dup; *_index+=bGV2ZWxJZA.length; }; levelId=cast(string)bGV2ZWxJZA;
		ubyte[] d29ybGROYW1l; d29ybGROYW1l.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+d29ybGROYW1l.length){ d29ybGROYW1l=_buffer[*_index..*_index+d29ybGROYW1l.length].dup; *_index+=d29ybGROYW1l.length; }; worldName=cast(string)d29ybGROYW1l;
		return this;
	}

}

struct AddPlayer {

	public enum ubyte ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public UUID uuid;
	public string username;
	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float headYaw;
	public float yaw;
	public sul.protocol.pocket100.types.Slot heldItem;
	public sul.protocol.pocket100.types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=uuid.data;
		ubyte[] dXNlcm5hbWU=cast(ubyte[])username; _buffer~=varuint.encode(dXNlcm5hbWU.length.to!uint);_buffer~=dXNlcm5hbWU;
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, headYaw, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		heldItem.encode(_buffer);
		metadata.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		ubyte[] dXNlcm5hbWU; dXNlcm5hbWU.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+dXNlcm5hbWU.length){ dXNlcm5hbWU=_buffer[*_index..*_index+dXNlcm5hbWU.length].dup; *_index+=dXNlcm5hbWU.length; }; username=cast(string)dXNlcm5hbWU;
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ motion.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ headYaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		heldItem.decode(_buffer, _index);
		metadata.decode(_buffer, _index);
		return this;
	}

}

struct AddEntity {

	public enum ubyte ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public uint type;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float yaw;
	public sul.protocol.pocket100.types.Attribute[] attributes;
	public sul.protocol.pocket100.types.Metadata metadata;
	public long[] links;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		_buffer~=varuint.encode(type);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		_buffer~=varuint.encode(attributes.length.to!uint);foreach(YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.encode(_buffer); }
		metadata.encode(_buffer);
		_buffer~=varuint.encode(links.length.to!uint);foreach(bGlua3M;links){ _buffer~=varlong.encode(bGlua3M); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		type=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ motion.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		attributes.length=varuint.decode(_buffer, *_index);foreach(ref YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.decode(_buffer, _index); }
		metadata.decode(_buffer, _index);
		links.length=varuint.decode(_buffer, *_index);foreach(ref bGlua3M;links){ bGlua3M=varlong.decode(_buffer, *_index); }
		return this;
	}

}

struct RemoveEntity {

	public enum ubyte ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct AddItemEntity {

	public enum ubyte ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket100.types.Slot item;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		item.encode(_buffer);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.z, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		item.decode(_buffer, _index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ motion.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		return this;
	}

}

struct AddHangingEntity {

	public enum ubyte ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket100.types.BlockPosition position;
	public int unknown3;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		position.encode(_buffer);
		_buffer~=varint.encode(unknown3);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		position.decode(_buffer, _index);
		unknown3=varint.decode(_buffer, *_index);
		return this;
	}

}

struct TakeItemEntity {

	public enum ubyte ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long taken;
	public long collector;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(taken);
		_buffer~=varlong.encode(collector);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		taken=varlong.decode(_buffer, *_index);
		collector=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct MoveEntity {

	public enum ubyte ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, headYaw, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ headYaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		return this;
	}

}

struct MovePlayer {

	public enum ubyte ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// animation
	public enum ubyte FULL = 0;
	public enum ubyte NONE = 1;
	public enum ubyte ROTATION = 2;

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;
	public ubyte animation;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, headYaw, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		_buffer~=animation;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, onGround, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ headYaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ animation=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ onGround=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct RiderJump {

	public enum ubyte ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public long rider;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(rider);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		rider=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct RemoveBlock {

	public enum ubyte ID = 22;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public sul.protocol.pocket100.types.BlockPosition position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		position.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		position.decode(_buffer, _index);
		return this;
	}

}

struct UpdateBlock {

	public enum ubyte ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags and meta
	public enum uint NEIGHBORS = 1;
	public enum uint NETWORK = 2;
	public enum uint NO_GRAPHIC = 4;
	public enum uint PRIORITY = 8;

	public sul.protocol.pocket100.types.BlockPosition position;
	public uint block;
	public uint flagsAndMeta;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		position.encode(_buffer);
		_buffer~=varuint.encode(block);
		_buffer~=varuint.encode(flagsAndMeta);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		position.decode(_buffer, _index);
		block=varuint.decode(_buffer, *_index);
		flagsAndMeta=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct AddPainting {

	public enum ubyte ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket100.types.BlockPosition position;
	public int direction;
	public string title;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		position.encode(_buffer);
		_buffer~=varint.encode(direction);
		ubyte[] dGl0bGU=cast(ubyte[])title; _buffer~=varuint.encode(dGl0bGU.length.to!uint);_buffer~=dGl0bGU;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		position.decode(_buffer, _index);
		direction=varint.decode(_buffer, *_index);
		ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+dGl0bGU.length){ dGl0bGU=_buffer[*_index..*_index+dGl0bGU.length].dup; *_index+=dGl0bGU.length; }; title=cast(string)dGl0bGU;
		return this;
	}

}

struct Explode {

	public enum ubyte ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public sul.protocol.pocket100.types.BlockPosition[] destroyedBlocks;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, radius, _buffer.length-float.sizeof);
		_buffer~=varuint.encode(destroyedBlocks.length.to!uint);foreach(ZGVzdHJveWVkQmxv;destroyedBlocks){ ZGVzdHJveWVkQmxv.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ radius=peek!(float, Endian.littleEndian)(_buffer, _index); }
		destroyedBlocks.length=varuint.decode(_buffer, *_index);foreach(ref ZGVzdHJveWVkQmxv;destroyedBlocks){ ZGVzdHJveWVkQmxv.decode(_buffer, _index); }
		return this;
	}

}

struct LevelSoundEvent {

	public enum ubyte ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte sound;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public uint volume;
	public int pitch;
	public bool unknown4;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=sound;
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer~=varuint.encode(volume);
		_buffer~=varint.encode(pitch);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, unknown4, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ sound=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		volume=varuint.decode(_buffer, *_index);
		pitch=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+bool.sizeof){ unknown4=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct LevelEvent {

	public enum ubyte ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum int START_RAIN = 3001;
	public enum int START_THUNDER = 3002;
	public enum int STOP_RAIN = 3003;
	public enum int STOP_THUNDER = 3004;
	public enum int SET_DATA = 4000;
	public enum int PLAYERS_SLEEPING = 9800;

	public int eventId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(eventId);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer~=varint.encode(data);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		eventId=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		data=varint.decode(_buffer, *_index);
		return this;
	}

}

struct BlockEvent {

	public enum ubyte ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public sul.protocol.pocket100.types.BlockPosition position;
	public int[2] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		position.encode(_buffer);
		foreach(ZGF0YQ;data){ _buffer~=varint.encode(ZGF0YQ); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		position.decode(_buffer, _index);
		foreach(ref ZGF0YQ;data){ ZGF0YQ=varint.decode(_buffer, *_index); }
		return this;
	}

}

struct EntityEvent {

	public enum ubyte ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// event id
	public enum ubyte HURT_ANIMATION = 2;
	public enum ubyte DEATH_ANIMATION = 3;
	public enum ubyte TAME_FAIL = 6;
	public enum ubyte TAME_SUCCESS = 7;
	public enum ubyte SHAKE_WET = 8;
	public enum ubyte USE_ITEM = 9;
	public enum ubyte EAT_GRASS_ANIMATION = 10;
	public enum ubyte FISH_HOOK_BUBBLES = 11;
	public enum ubyte FISH_HOOK_POSITION = 12;
	public enum ubyte FISH_HOOK_HOOK = 13;
	public enum ubyte FISH_HOOK_TEASE = 14;
	public enum ubyte SQUID_INK_CLOUD = 15;
	public enum ubyte AMBIENT_SOUND = 16;
	public enum ubyte RESPAWN = 17;

	public long entityId;
	public ubyte eventId;
	public int unknown2;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=eventId;
		_buffer~=varint.encode(unknown2);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ eventId=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		unknown2=varint.decode(_buffer, *_index);
		return this;
	}

}

struct MobEffect {

	public enum ubyte ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum ubyte ADD = 0;
	public enum ubyte MODIFY = 1;
	public enum ubyte REMOVE = 2;

	public long entityId;
	public ubyte eventId;
	public int effect;
	public int amplifier;
	public bool particles;
	public int duration;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=eventId;
		_buffer~=varint.encode(effect);
		_buffer~=varint.encode(amplifier);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, particles, _buffer.length-bool.sizeof);
		_buffer~=varint.encode(duration);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ eventId=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		effect=varint.decode(_buffer, *_index);
		amplifier=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+bool.sizeof){ particles=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		duration=varint.decode(_buffer, *_index);
		return this;
	}

}

struct UpdateAttributes {

	public enum ubyte ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public sul.protocol.pocket100.types.Attribute[] attributes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varuint.encode(attributes.length.to!uint);foreach(YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		attributes.length=varuint.decode(_buffer, *_index);foreach(ref YXR0cmlidXRlcw;attributes){ YXR0cmlidXRlcw.decode(_buffer, _index); }
		return this;
	}

}

struct MobEquipment {

	public enum ubyte ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public long entityId;
	public sul.protocol.pocket100.types.Slot item;
	public ubyte slot;
	public ubyte selectedSlot;
	public ubyte unknown4;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		item.encode(_buffer);
		_buffer~=slot;
		_buffer~=selectedSlot;
		_buffer~=unknown4;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		item.decode(_buffer, _index);
		if(_buffer.length>=*_index+ubyte.sizeof){ slot=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ selectedSlot=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ unknown4=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct MobArmorEquipment {

	public enum ubyte ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public long entityId;
	public sul.protocol.pocket100.types.Slot[4] armor;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		foreach(YXJtb3I;armor){ YXJtb3I.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		foreach(ref YXJtb3I;armor){ YXJtb3I.decode(_buffer, _index); }
		return this;
	}

}

struct Interact {

	public enum ubyte ID = 34;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte ATTACK = 1;
	public enum ubyte INTERACT = 2;
	public enum ubyte LEAVE_VEHICLE = 3;
	public enum ubyte HOVER = 4;

	public ubyte action;
	public long target;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=action;
		_buffer~=varlong.encode(target);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		target=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct UseItem {

	public enum ubyte ID = 35;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public sul.protocol.pocket100.types.BlockPosition blockPosition;
	public uint hotbarSlot;
	public int face;
	public Tuple!(float, "x", float, "y", float, "z") facePosition;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int slot;
	public sul.protocol.pocket100.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		blockPosition.encode(_buffer);
		_buffer~=varuint.encode(hotbarSlot);
		_buffer~=varint.encode(face);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, facePosition.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, facePosition.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, facePosition.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer~=varint.encode(slot);
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		blockPosition.decode(_buffer, _index);
		hotbarSlot=varuint.decode(_buffer, *_index);
		face=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ facePosition.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ facePosition.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ facePosition.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		slot=varint.decode(_buffer, *_index);
		item.decode(_buffer, _index);
		return this;
	}

}

struct PlayerAction {

	public enum ubyte ID = 36;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum int START_BREAK = 0;
	public enum int ABORT_BREAK = 1;
	public enum int STOP_BREAK = 2;
	public enum int RELEASE_ITEM = 5;
	public enum int STOP_SLEEPING = 6;
	public enum int RESPAWN = 7;
	public enum int JUMP = 8;
	public enum int START_SPRINT = 9;
	public enum int STOP_SPRINT = 10;
	public enum int START_SNEAK = 11;
	public enum int STOP_SNEAK = 12;
	public enum int DIMENSION_CHANGE = 13;
	public enum int ABORT_DIMENSION_CHANGE = 14;
	public enum int START_GLIDING = 15;
	public enum int STOP_GLIDING = 16;

	public long entityId;
	public int action;
	public sul.protocol.pocket100.types.BlockPosition position;
	public int face;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varint.encode(action);
		position.encode(_buffer);
		_buffer~=varint.encode(face);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		action=varint.decode(_buffer, *_index);
		position.decode(_buffer, _index);
		face=varint.decode(_buffer, *_index);
		return this;
	}

}

struct PlayerFall {

	public enum ubyte ID = 37;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public float distance;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, distance, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+float.sizeof){ distance=peek!(float, Endian.littleEndian)(_buffer, _index); }
		return this;
	}

}

struct HurtArmor {

	public enum ubyte ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int health;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(health);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		health=varint.decode(_buffer, *_index);
		return this;
	}

}

struct SetEntityData {

	public enum ubyte ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public sul.protocol.pocket100.types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		metadata.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		metadata.decode(_buffer, _index);
		return this;
	}

}

struct SetEntityMotion {

	public enum ubyte ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.z, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ motion.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		return this;
	}

}

struct SetEntityLink {

	public enum ubyte ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public long from;
	public long to;
	public ubyte action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(from);
		_buffer~=varlong.encode(to);
		_buffer~=action;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		from=varlong.decode(_buffer, *_index);
		to=varlong.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SetHealth {

	public enum ubyte ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int health;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(health);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		health=varint.decode(_buffer, *_index);
		return this;
	}

}

struct SetSpawnPosition {

	public enum ubyte ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int unknown0;
	public sul.protocol.pocket100.types.BlockPosition position;
	public bool unknown2;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(unknown0);
		position.encode(_buffer);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, unknown2, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		unknown0=varint.decode(_buffer, *_index);
		position.decode(_buffer, _index);
		if(_buffer.length>=*_index+bool.sizeof){ unknown2=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Animate {

	public enum ubyte ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// action
	public enum int BREAKING = 1;
	public enum int WAKE_UP = 3;

	public int action;
	public long entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(action);
		_buffer~=varlong.encode(entityId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		action=varint.decode(_buffer, *_index);
		entityId=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct Respawn {

	public enum ubyte ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		return this;
	}

}

struct DropItem {

	public enum ubyte ID = 46;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte DROP = 0;

	public ubyte action;
	public sul.protocol.pocket100.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=action;
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		item.decode(_buffer, _index);
		return this;
	}

}

struct InventoryAction {

	public enum ubyte ID = 47;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public int action;
	public sul.protocol.pocket100.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(action);
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		action=varint.decode(_buffer, *_index);
		item.decode(_buffer, _index);
		return this;
	}

}

struct ContainerOpen {

	public enum ubyte ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ubyte type;
	public int slotCount;
	public sul.protocol.pocket100.types.BlockPosition position;
	public long entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=window;
		_buffer~=type;
		_buffer~=varint.encode(slotCount);
		position.encode(_buffer);
		_buffer~=varlong.encode(entityId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ type=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		slotCount=varint.decode(_buffer, *_index);
		position.decode(_buffer, _index);
		entityId=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct ContainerClose {

	public enum ubyte ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=window;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct ContainerSetSlot {

	public enum ubyte ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public int slot;
	public int hotbarSlot;
	public sul.protocol.pocket100.types.Slot item;
	public ubyte unknown4;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=window;
		_buffer~=varint.encode(slot);
		_buffer~=varint.encode(hotbarSlot);
		item.encode(_buffer);
		_buffer~=unknown4;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		slot=varint.decode(_buffer, *_index);
		hotbarSlot=varint.decode(_buffer, *_index);
		item.decode(_buffer, _index);
		if(_buffer.length>=*_index+ubyte.sizeof){ unknown4=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct ContainerSetData {

	public enum ubyte ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public int property;
	public int value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=window;
		_buffer~=varint.encode(property);
		_buffer~=varint.encode(value);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		property=varint.decode(_buffer, *_index);
		value=varint.decode(_buffer, *_index);
		return this;
	}

}

struct ContainerSetContent {

	public enum ubyte ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public sul.protocol.pocket100.types.Slot[] slots;
	public int[] hotbar;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=window;
		_buffer~=varuint.encode(slots.length.to!uint);foreach(c2xvdHM;slots){ c2xvdHM.encode(_buffer); }
		_buffer~=varuint.encode(hotbar.length.to!uint);foreach(aG90YmFy;hotbar){ _buffer~=varint.encode(aG90YmFy); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		slots.length=varuint.decode(_buffer, *_index);foreach(ref c2xvdHM;slots){ c2xvdHM.decode(_buffer, _index); }
		hotbar.length=varuint.decode(_buffer, *_index);foreach(ref aG90YmFy;hotbar){ aG90YmFy=varint.decode(_buffer, *_index); }
		return this;
	}

}

struct CraftingData {

	public enum ubyte ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public sul.protocol.pocket100.types.Recipe[] recipes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varuint.encode(recipes.length.to!uint);foreach(cmVjaXBlcw;recipes){ cmVjaXBlcw.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		recipes.length=varuint.decode(_buffer, *_index);foreach(ref cmVjaXBlcw;recipes){ cmVjaXBlcw.decode(_buffer, _index); }
		return this;
	}

}

struct CraftingEvent {

	public enum ubyte ID = 54;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte window;
	public int type;
	public UUID uuid;
	public sul.protocol.pocket100.types.Slot[] input;
	public sul.protocol.pocket100.types.Slot[] output;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=window;
		_buffer~=varint.encode(type);
		_buffer~=uuid.data;
		_buffer~=varuint.encode(input.length.to!uint);foreach(aW5wdXQ;input){ aW5wdXQ.encode(_buffer); }
		_buffer~=varuint.encode(output.length.to!uint);foreach(b3V0cHV0;output){ b3V0cHV0.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		type=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		input.length=varuint.decode(_buffer, *_index);foreach(ref aW5wdXQ;input){ aW5wdXQ.decode(_buffer, _index); }
		output.length=varuint.decode(_buffer, *_index);foreach(ref b3V0cHV0;output){ b3V0cHV0.decode(_buffer, _index); }
		return this;
	}

}

struct AdventureSettings {

	public enum ubyte ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// flags
	public enum uint IMMUTABLE_WORLD = 1;
	public enum uint PVP_DISABLED = 2;
	public enum uint PVM_DISABLED = 4;
	public enum uint MVP_DISBALED = 8;
	public enum uint EVP_DISABLED = 16;
	public enum uint AUTO_JUMP = 32;
	public enum uint ALLOW_FLIGHT = 64;
	public enum uint NO_CLIP = 256;
	public enum uint FLYING = 1024;

	// permissions
	public enum uint USER = 0;
	public enum uint OPERATOR = 1;
	public enum uint HOST = 2;
	public enum uint AUTOMATION = 3;
	public enum uint ADMIN = 4;

	public uint flags;
	public uint permissions;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varuint.encode(flags);
		_buffer~=varuint.encode(permissions);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		flags=varuint.decode(_buffer, *_index);
		permissions=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct BlockEntityData {

	public enum ubyte ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public sul.protocol.pocket100.types.BlockPosition position;
	public ubyte[] nbt;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		position.encode(_buffer);
		_buffer~=nbt;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		position.decode(_buffer, _index);
		nbt=_buffer[*_index..$].dup; *_index=buffer.length;
		return this;
	}

}

struct PlayerInput {

	public enum ubyte ID = 57;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public Tuple!(float, "x", float, "y", float, "z") motion;
	public ubyte flags;
	public bool unknown2;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, motion.z, _buffer.length-float.sizeof);
		_buffer~=flags;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, unknown2, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+float.sizeof){ motion.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ flags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ unknown2=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct FullChunkData {

	public enum ubyte ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") position;
	public ubyte[] data;
	public ubyte[] tiles;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(position.x);_buffer~=varint.encode(position.z);
		_buffer~=varuint.encode(data.length.to!uint);_buffer~=data;
		_buffer~=varuint.encode(tiles.length.to!uint);_buffer~=tiles;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		position.x=varint.decode(_buffer, *_index);position.z=varint.decode(_buffer, *_index);
		data.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+data.length){ data=_buffer[*_index..*_index+data.length].dup; *_index+=data.length; }
		tiles.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+tiles.length){ tiles=_buffer[*_index..*_index+tiles.length].dup; *_index+=tiles.length; }
		return this;
	}

}

struct SetCheatsEnabled {

	public enum ubyte ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool enabled;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, enabled, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+bool.sizeof){ enabled=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SetDifficulty {

	public enum ubyte ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum uint PEACEFUL = 0;
	public enum uint EASY = 1;
	public enum uint NORMAL = 2;
	public enum uint HARD = 3;

	public uint difficulty;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varuint.encode(difficulty);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		difficulty=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct ChangeDimension {

	public enum ubyte ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	public int dimension;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public bool unknown2;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(dimension);
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, unknown2, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		dimension=varint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ unknown2=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SetPlayerGametype {

	public enum ubyte ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// gametype
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	public int gametype;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(gametype);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		gametype=varint.decode(_buffer, *_index);
		return this;
	}

}

struct PlayerList {

	public enum ubyte ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=action;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

	public struct Add {

		public enum typeof(action) ACTION = 0;

		public sul.protocol.pocket100.types.PlayerList[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint);foreach(cGxheWVycw;players){ cGxheWVycw.encode(_buffer); }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index);foreach(ref cGxheWVycw;players){ cGxheWVycw.decode(_buffer, _index); }
			return this;
		}

	}

	public struct Remove {

		public enum typeof(action) ACTION = 1;

		public UUID[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint);foreach(cGxheWVycw;players){ _buffer~=cGxheWVycw.data; }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index);foreach(ref cGxheWVycw;players){ if(_buffer.length>=*_index+16){ ubyte[16] Y0d4aGVXVnljdw=buffer[*_index..*_index+16].dup; *_index+=16; cGxheWVycw=UUID(Y0d4aGVXVnljdw); } }
			return this;
		}

	}

}

struct SpawnExperienceOrb {

	public enum ubyte ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;
	public int count;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.littleEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer~=varint.encode(count);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.littleEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.littleEndian)(_buffer, _index); }
		count=varint.decode(_buffer, *_index);
		return this;
	}

}

struct MapInfoRequest {

	public enum ubyte ID = 67;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public long mapId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(mapId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		mapId=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct RequestChunkRadius {

	public enum ubyte ID = 68;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public int radius;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(radius);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		radius=varint.decode(_buffer, *_index);
		return this;
	}

}

struct ChunkRadiusUpdated {

	public enum ubyte ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public int radius;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varint.encode(radius);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		radius=varint.decode(_buffer, *_index);
		return this;
	}

}

struct ItemFrameDropItem {

	public enum ubyte ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public sul.protocol.pocket100.types.BlockPosition position;
	public sul.protocol.pocket100.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		position.encode(_buffer);
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		position.decode(_buffer, _index);
		item.decode(_buffer, _index);
		return this;
	}

}

struct ReplaceSelectedItem {

	public enum ubyte ID = 71;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public sul.protocol.pocket100.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		item.decode(_buffer, _index);
		return this;
	}

}

struct Camera {

	public enum ubyte ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long entityId;
	public long runtimeId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varlong.encode(runtimeId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		runtimeId=varlong.decode(_buffer, *_index);
		return this;
	}

}

struct AddItem {

	public enum ubyte ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public sul.protocol.pocket100.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		item.decode(_buffer, _index);
		return this;
	}

}

struct BossEvent {

	public enum ubyte ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum uint ADD = 0;
	public enum uint UPDATE = 1;
	public enum uint REMOVE = 2;

	public long entityId;
	public uint eventId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varlong.encode(entityId);
		_buffer~=varuint.encode(eventId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		entityId=varlong.decode(_buffer, *_index);
		eventId=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct ShowCredits {

	public enum ubyte ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		return this;
	}

}

struct AvailableCommands {

	public enum ubyte ID = 77;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string commands;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		ubyte[] Y29tbWFuZHM=cast(ubyte[])commands; _buffer~=varuint.encode(Y29tbWFuZHM.length.to!uint);_buffer~=Y29tbWFuZHM;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		ubyte[] Y29tbWFuZHM; Y29tbWFuZHM.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+Y29tbWFuZHM.length){ Y29tbWFuZHM=_buffer[*_index..*_index+Y29tbWFuZHM.length].dup; *_index+=Y29tbWFuZHM.length; }; commands=cast(string)Y29tbWFuZHM;
		return this;
	}

}

struct CommandStep {

	public enum ubyte ID = 78;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public string command;
	public string overload;
	public uint unknown2;
	public uint unknown3;
	public bool isOutput;
	public ulong unknown5;
	public string input;
	public string output;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		ubyte[] Y29tbWFuZA=cast(ubyte[])command; _buffer~=varuint.encode(Y29tbWFuZA.length.to!uint);_buffer~=Y29tbWFuZA;
		ubyte[] b3ZlcmxvYWQ=cast(ubyte[])overload; _buffer~=varuint.encode(b3ZlcmxvYWQ.length.to!uint);_buffer~=b3ZlcmxvYWQ;
		_buffer~=varuint.encode(unknown2);
		_buffer~=varuint.encode(unknown3);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, isOutput, _buffer.length-bool.sizeof);
		_buffer~=varulong.encode(unknown5);
		ubyte[] aW5wdXQ=cast(ubyte[])input; _buffer~=varuint.encode(aW5wdXQ.length.to!uint);_buffer~=aW5wdXQ;
		ubyte[] b3V0cHV0=cast(ubyte[])output; _buffer~=varuint.encode(b3V0cHV0.length.to!uint);_buffer~=b3V0cHV0;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		ubyte[] Y29tbWFuZA; Y29tbWFuZA.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+Y29tbWFuZA.length){ Y29tbWFuZA=_buffer[*_index..*_index+Y29tbWFuZA.length].dup; *_index+=Y29tbWFuZA.length; }; command=cast(string)Y29tbWFuZA;
		ubyte[] b3ZlcmxvYWQ; b3ZlcmxvYWQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+b3ZlcmxvYWQ.length){ b3ZlcmxvYWQ=_buffer[*_index..*_index+b3ZlcmxvYWQ.length].dup; *_index+=b3ZlcmxvYWQ.length; }; overload=cast(string)b3ZlcmxvYWQ;
		unknown2=varuint.decode(_buffer, *_index);
		unknown3=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+bool.sizeof){ isOutput=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		unknown5=varulong.decode(_buffer, *_index);
		ubyte[] aW5wdXQ; aW5wdXQ.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+aW5wdXQ.length){ aW5wdXQ=_buffer[*_index..*_index+aW5wdXQ.length].dup; *_index+=aW5wdXQ.length; }; input=cast(string)aW5wdXQ;
		ubyte[] b3V0cHV0; b3V0cHV0.length=varuint.decode(_buffer, *_index);if(_buffer.length>=*_index+b3V0cHV0.length){ b3V0cHV0=_buffer[*_index..*_index+b3V0cHV0.length].dup; *_index+=b3V0cHV0.length; }; output=cast(string)b3V0cHV0;
		return this;
	}

}
