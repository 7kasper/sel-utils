/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/minecraft316.xml
 */
module sul.protocol.minecraft316.clientbound;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.minecraft316.types;

alias Packets = TypeTuple!(SpawnObject, SpawnExperienceOrb, SpawnGlobalEntity, SpawnMob, SpawnPainting, SpawnPlayer, Animation, Statistics, BlockBreakAnimation, UpdateBlockEntity, BlockAction, BlockChange, BossBar, ServerDifficulty, TabComplete, ChatMessage, MultiBlockChange, ConfirmTransaction, CloseWindow, OpenWindow, WindowItems, WindowProperty, SetSlot, SetCooldown, PluginMessage, NamedSoundEffect, Disconnect, EntityStatus, Explosion, UnloadChunk, ChangeGameState, KeepAlive, ChunkData, Effect, Particle, JoinGame, Map, EntityRelativeMove, EntityLookAndRelativeMove, EntityLook, Entity, VehicleMove, OpenSignEditor, PlayerAbilities, CombatEvent, PlayerListItem, PlayerPositionAndLook, UseBed, DestroyEntities, RemoveEntityEffect, ResourcePackSend, Respawn, EntityHeadLook, WorldBorder, Camera, HeldItemChange, DisplayScoreboard, EntityMetadata, AttachEntity, EntityVelocity, EntityEquipment, SetExperience, UpdateHealth, ScoreboardObjective, SetPassengers, Teams, UpdateScore, SpawnPosition, TimeUpdate, Title, SoundEffect, PlayerListHeaderAndFooter, CollectItem, EntityTeleport, EntityProperties, EntityEffect);

struct SpawnObject {

	public enum uint ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte pitch;
	public ubyte yaw;
	public int data;
	public Tuple!(short, "x", short, "y", short, "z") velocity;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=uuid.data;
		buffer~=type;
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer~=pitch;
		buffer~=yaw;
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, data, buffer.length-int.sizeof);
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.x, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.y, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.z, buffer.length-short.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		if(buffer.length>=ubyte.sizeof){ type=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ pitch=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ yaw=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=int.sizeof){ data=read!(int, Endian.bigEndian)(buffer); }
		if(buffer.length>=short.sizeof){ velocity.x=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ velocity.y=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ velocity.z=read!(short, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SpawnExperienceOrb {

	public enum uint ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ushort count;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, count, buffer.length-ushort.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ count=read!(ushort, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SpawnGlobalEntity {

	public enum uint ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// type
	public enum ubyte THUNDERBOLT = 1;

	public uint entityId;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=type;
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ type=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SpawnMob {

	public enum uint ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public uint type;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public ubyte headPitch;
	public Tuple!(short, "x", short, "y", short, "z") velocity;
	public types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=uuid.data;
		buffer~=varuint.encode(type);
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer~=yaw;
		buffer~=pitch;
		buffer~=headPitch;
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.x, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.y, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.z, buffer.length-short.sizeof);
		metadata.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		type=varuint.decode(buffer);
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ yaw=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ pitch=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ headPitch=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=short.sizeof){ velocity.x=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ velocity.y=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ velocity.z=read!(short, Endian.bigEndian)(buffer); }
		metadata.decode(buffer);
		return this;
	}

}

struct SpawnPainting {

	public enum uint ID = 4;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public string title;
	public ulong position;
	public ubyte direction;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=uuid.data;
		ubyte[] dGl0bGU=cast(ubyte[])title; buffer~=varuint.encode(dGl0bGU.length.to!uint);buffer~=dGl0bGU;
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		buffer~=direction;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(buffer);if(buffer.length>=dGl0bGU.length){ dGl0bGU=buffer[0..dGl0bGU.length]; buffer=buffer[dGl0bGU.length..$]; }; title=cast(string)dGl0bGU;
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ direction=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SpawnPlayer {

	public enum uint ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=uuid.data;
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer~=yaw;
		buffer~=pitch;
		metadata.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ yaw=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ pitch=read!(ubyte, Endian.bigEndian)(buffer); }
		metadata.decode(buffer);
		return this;
	}

}

struct Animation {

	public enum uint ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// animation
	public enum ubyte SWING_MAIN_ARM = 0;
	public enum ubyte TAKE_DAMAGE = 1;
	public enum ubyte LEAVE_BED = 2;
	public enum ubyte SWING_OFFHAND = 3;
	public enum ubyte CRITICAL_EFFECT = 4;
	public enum ubyte MAGICAL_CRITICAL_EFFECT = 5;

	public uint entityId;
	public ubyte animation;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=animation;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ animation=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Statistics {

	public enum uint ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public types.Statistic[] statistics;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(statistics.length.to!uint);foreach(c3RhdGlzdGljcw;statistics){ c3RhdGlzdGljcw.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		statistics.length=varuint.decode(buffer);foreach(ref c3RhdGlzdGljcw;statistics){ c3RhdGlzdGljcw.decode(buffer); }
		return this;
	}

}

struct BlockBreakAnimation {

	public enum uint ID = 8;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ulong position;
	public ubyte stage;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		buffer~=stage;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ stage=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct UpdateBlockEntity {

	public enum uint ID = 9;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte MOB_SPAWNER_DATA = 1;
	public enum ubyte COMMAND_BLOCK_TEXT = 2;
	public enum ubyte BEACON_POWERS = 3;
	public enum ubyte MOB_HEAD_DATA = 4;
	public enum ubyte FLOWER_POT_FLOWER = 5;
	public enum ubyte BANNER_DATA = 6;
	public enum ubyte STRUCTURE_DATA = 7;
	public enum ubyte END_GATEWAY_DESTINATION = 8;
	public enum ubyte SIGN_TEXT = 9;
	public enum ubyte SHULKER_BOX_DECLARATION = 10;

	public ulong position;
	public ubyte action;
	public ubyte[] nbt;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		buffer~=action;
		buffer~=nbt;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		nbt=buffer.dup; buffer.length=0;
		return this;
	}

}

struct BlockAction {

	public enum uint ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;
	public ubyte action;
	public ubyte parameter;
	public uint blockType;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		buffer~=action;
		buffer~=parameter;
		buffer~=varuint.encode(blockType);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ parameter=read!(ubyte, Endian.bigEndian)(buffer); }
		blockType=varuint.decode(buffer);
		return this;
	}

}

struct BlockChange {

	public enum uint ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;
	public uint block;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		buffer~=varuint.encode(block);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		block=varuint.decode(buffer);
		return this;
	}

}

struct BossBar {

	public enum uint ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public UUID uuid;
	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=uuid.data;
		buffer~=varuint.encode(action);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		action=varuint.decode(buffer);
		return this;
	}

}

struct ServerDifficulty {

	public enum uint ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	public ubyte difficulty;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=difficulty;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ difficulty=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct TabComplete {

	public enum uint ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string[] matches;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(matches.length.to!uint);foreach(bWF0Y2hlcw;matches){ ubyte[] YldGMFkyaGxjdw=cast(ubyte[])bWF0Y2hlcw; buffer~=varuint.encode(YldGMFkyaGxjdw.length.to!uint);buffer~=YldGMFkyaGxjdw; }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		matches.length=varuint.decode(buffer);foreach(ref bWF0Y2hlcw;matches){ ubyte[] YldGMFkyaGxjdw; YldGMFkyaGxjdw.length=varuint.decode(buffer);if(buffer.length>=YldGMFkyaGxjdw.length){ YldGMFkyaGxjdw=buffer[0..YldGMFkyaGxjdw.length]; buffer=buffer[YldGMFkyaGxjdw.length..$]; }; bWF0Y2hlcw=cast(string)YldGMFkyaGxjdw; }
		return this;
	}

}

struct ChatMessage {

	public enum uint ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// position
	public enum ubyte CHAT = 0;
	public enum ubyte SYSTEM_MESSAGE = 1;
	public enum ubyte ABOVE_HOTBAR = 2;

	public string message;
	public ubyte position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);buffer~=bWVzc2FnZQ;
		buffer~=position;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(buffer);if(buffer.length>=bWVzc2FnZQ.length){ bWVzc2FnZQ=buffer[0..bWVzc2FnZQ.length]; buffer=buffer[bWVzc2FnZQ.length..$]; }; message=cast(string)bWVzc2FnZQ;
		if(buffer.length>=ubyte.sizeof){ position=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct MultiBlockChange {

	public enum uint ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") chunk;
	public types.BlockChange[] changes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, chunk.x, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, chunk.z, buffer.length-int.sizeof);
		buffer~=varuint.encode(changes.length.to!uint);foreach(Y2hhbmdlcw;changes){ Y2hhbmdlcw.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=int.sizeof){ chunk.x=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ chunk.z=read!(int, Endian.bigEndian)(buffer); }
		changes.length=varuint.decode(buffer);foreach(ref Y2hhbmdlcw;changes){ Y2hhbmdlcw.decode(buffer); }
		return this;
	}

}

struct ConfirmTransaction {

	public enum uint ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ushort action;
	public bool accepted;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=window;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, action, buffer.length-ushort.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, accepted, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ action=read!(ushort, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ accepted=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct CloseWindow {

	public enum uint ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=window;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct OpenWindow {

	public enum uint ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public string type;
	public string title;
	public ubyte slots;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=window;
		ubyte[] dHlwZQ=cast(ubyte[])type; buffer~=varuint.encode(dHlwZQ.length.to!uint);buffer~=dHlwZQ;
		ubyte[] dGl0bGU=cast(ubyte[])title; buffer~=varuint.encode(dGl0bGU.length.to!uint);buffer~=dGl0bGU;
		buffer~=slots;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] dHlwZQ; dHlwZQ.length=varuint.decode(buffer);if(buffer.length>=dHlwZQ.length){ dHlwZQ=buffer[0..dHlwZQ.length]; buffer=buffer[dHlwZQ.length..$]; }; type=cast(string)dHlwZQ;
		ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(buffer);if(buffer.length>=dGl0bGU.length){ dGl0bGU=buffer[0..dGl0bGU.length]; buffer=buffer[dGl0bGU.length..$]; }; title=cast(string)dGl0bGU;
		if(buffer.length>=ubyte.sizeof){ slots=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct WindowItems {

	public enum uint ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ushort count;
	public types.Slots slots;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=window;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, count, buffer.length-ushort.sizeof);
		slots.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ count=read!(ushort, Endian.bigEndian)(buffer); }
		slots.decode(buffer);
		return this;
	}

}

struct WindowProperty {

	public enum uint ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// property
	public enum ushort FIRE_ICON = 0;
	public enum ushort MAX_FUEL_BURN_TIME = 1;
	public enum ushort PROGRESS_ARROW = 2;
	public enum ushort MAX_PROGRESS = 3;
	public enum ushort LEVEL_REQUIREMENT_TOP_ENCHANTMENT = 0;
	public enum ushort LEVEL_REQUIREMENT_MIDDLE_ENCHANTMENT = 1;
	public enum ushort LEVEL_REQUIREMENT_BOTTOM_ENCHANTMENT = 2;
	public enum ushort ENCHANTMENT_SEED = 3;
	public enum ushort POWER_LEVEL = 0;
	public enum ushort FIRST_POTION_EFFECT = 1;
	public enum ushort SECOND_POTION_EFFECT = 2;
	public enum ushort REPAIR_COST = 0;
	public enum ushort BREW_TIME = 0;

	public ubyte window;
	public ushort property;
	public short value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=window;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, property, buffer.length-ushort.sizeof);
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, value, buffer.length-short.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ property=read!(ushort, Endian.bigEndian)(buffer); }
		if(buffer.length>=short.sizeof){ value=read!(short, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct SetSlot {

	public enum uint ID = 22;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ushort slot;
	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=window;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, slot, buffer.length-ushort.sizeof);
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ window=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ slot=read!(ushort, Endian.bigEndian)(buffer); }
		item.decode(buffer);
		return this;
	}

}

struct SetCooldown {

	public enum uint ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint item;
	public uint cooldown;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(item);
		buffer~=varuint.encode(cooldown);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		item=varuint.decode(buffer);
		cooldown=varuint.decode(buffer);
		return this;
	}

}

struct PluginMessage {

	public enum uint ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string channel;
	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] Y2hhbm5lbA=cast(ubyte[])channel; buffer~=varuint.encode(Y2hhbm5lbA.length.to!uint);buffer~=Y2hhbm5lbA;
		buffer~=data;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] Y2hhbm5lbA; Y2hhbm5lbA.length=varuint.decode(buffer);if(buffer.length>=Y2hhbm5lbA.length){ Y2hhbm5lbA=buffer[0..Y2hhbm5lbA.length]; buffer=buffer[Y2hhbm5lbA.length..$]; }; channel=cast(string)Y2hhbm5lbA;
		data=buffer.dup; buffer.length=0;
		return this;
	}

}

struct NamedSoundEffect {

	public enum uint ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string name;
	public uint category;
	public Tuple!(int, "x", int, "y", int, "z") position;
	public float volume;
	public float pitch;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer~=varuint.encode(category);
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.x, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.y, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.z, buffer.length-int.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, volume, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, pitch, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		category=varuint.decode(buffer);
		if(buffer.length>=int.sizeof){ position.x=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ position.y=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ position.z=read!(int, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ volume=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Disconnect {

	public enum uint ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string reason;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] cmVhc29u=cast(ubyte[])reason; buffer~=varuint.encode(cmVhc29u.length.to!uint);buffer~=cmVhc29u;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] cmVhc29u; cmVhc29u.length=varuint.decode(buffer);if(buffer.length>=cmVhc29u.length){ cmVhc29u=buffer[0..cmVhc29u.length]; buffer=buffer[cmVhc29u.length..$]; }; reason=cast(string)cmVhc29u;
		return this;
	}

}

struct EntityStatus {

	public enum uint ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum ubyte HURT = 2;
	public enum ubyte DEAD = 3;

	public uint entityId;
	public ubyte status;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, entityId, buffer.length-uint.sizeof);
		buffer~=status;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=uint.sizeof){ entityId=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ status=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Explosion {

	public enum uint ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public types.ExplosionRecords records;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, radius, buffer.length-float.sizeof);
		records.encode(buffer);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, motion.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, motion.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, motion.z, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ radius=read!(float, Endian.bigEndian)(buffer); }
		records.decode(buffer);
		if(buffer.length>=float.sizeof){ motion.x=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.y=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ motion.z=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct UnloadChunk {

	public enum uint ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.x, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.z, buffer.length-int.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=int.sizeof){ position.x=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ position.z=read!(int, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ChangeGameState {

	public enum uint ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// reason
	public enum ubyte INVALID_BED = 0;
	public enum ubyte END_RAINING = 1;
	public enum ubyte BEGIN_RAINING = 2;
	public enum ubyte CHANGE_GAMEMODE = 3;
	public enum ubyte EXIT_END = 4;
	public enum ubyte DEMO_MESSAGE = 5;
	public enum ubyte ARROW_HITTING_PLAYER = 6;
	public enum ubyte FADE_VALUE = 7;
	public enum ubyte FADE_TIME = 8;
	public enum ubyte PLAY_ELDER_GUARDIAN_MOB_APPEARANCE = 10;

	// value
	public enum float SURVIVAL = 0;
	public enum float CREATIVE = 1;
	public enum float ADVENTURE = 2;
	public enum float SPECTATOR = 3;
	public enum float RESPAWN_IMMEDIATELY = 0;
	public enum float RESPAWN_AFTER_CREDITS = 1;
	public enum float SHOW_DEMO_SCREEN = 0;
	public enum float TELL_MOVEMENT_CONTROLS = 101;
	public enum float TELL_JUMP_CONTROLS = 102;
	public enum float TELL_INVENTORY_CONTROLS = 103;
	public enum float BRIGHT = 0;
	public enum float DARK = 1;

	public ubyte reason;
	public float value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=reason;
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, value, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ reason=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ value=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct KeepAlive {

	public enum uint ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint id;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(id);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		id=varuint.decode(buffer);
		return this;
	}

}

struct ChunkData {

	public enum uint ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") position;
	public bool full;
	public uint sections;
	public ubyte[] data;
	public ubyte[] tiles;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.x, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.z, buffer.length-int.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, full, buffer.length-bool.sizeof);
		buffer~=varuint.encode(sections);
		buffer~=varuint.encode(data.length.to!uint);buffer~=data;
		buffer~=tiles;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=int.sizeof){ position.x=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ position.z=read!(int, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ full=read!(bool, Endian.bigEndian)(buffer); }
		sections=varuint.decode(buffer);
		data.length=varuint.decode(buffer);if(buffer.length>=data.length){ data=buffer[0..data.length]; buffer=buffer[data.length..$]; }
		tiles=buffer.dup; buffer.length=0;
		return this;
	}

}

struct Effect {

	public enum uint ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint effectId;
	public ulong position;
	public uint data;
	public bool disableVolume;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, effectId, buffer.length-uint.sizeof);
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, data, buffer.length-uint.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, disableVolume, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=uint.sizeof){ effectId=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ data=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ disableVolume=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Particle {

	public enum uint ID = 34;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint particleId;
	public bool longDistance;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") offset;
	public float data;
	public uint count;
	public uint[2] additionalData;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, particleId, buffer.length-uint.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, longDistance, buffer.length-bool.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, position.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, position.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, position.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, offset.x, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, offset.y, buffer.length-float.sizeof);buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, offset.z, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, data, buffer.length-float.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, count, buffer.length-uint.sizeof);
		foreach(YWRkaXRpb25hbERh;additionalData){ buffer~=varuint.encode(YWRkaXRpb25hbERh); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=uint.sizeof){ particleId=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ longDistance=read!(bool, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ position.x=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ position.y=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ position.z=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ offset.x=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ offset.y=read!(float, Endian.bigEndian)(buffer); }if(buffer.length>=float.sizeof){ offset.z=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ data=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ count=read!(uint, Endian.bigEndian)(buffer); }
		foreach(ref YWRkaXRpb25hbERh;additionalData){ YWRkaXRpb25hbERh=varuint.decode(buffer); }
		return this;
	}

}

struct JoinGame {

	public enum uint ID = 35;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// gamemode
	public enum ubyte SURVIVAL = 0;
	public enum ubyte CREATIVE = 1;
	public enum ubyte ADVENTURE = 2;
	public enum ubyte SPECTATOR = 3;

	// dimension
	public enum int END = -1;
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	public uint entityId;
	public ubyte gamemode;
	public int dimension;
	public ubyte difficulty;
	public ubyte maxPlayers;
	public string levelType;
	public bool reducedDebug;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, entityId, buffer.length-uint.sizeof);
		buffer~=gamemode;
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, dimension, buffer.length-int.sizeof);
		buffer~=difficulty;
		buffer~=maxPlayers;
		ubyte[] bGV2ZWxUeXBl=cast(ubyte[])levelType; buffer~=varuint.encode(bGV2ZWxUeXBl.length.to!uint);buffer~=bGV2ZWxUeXBl;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, reducedDebug, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=uint.sizeof){ entityId=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ gamemode=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=int.sizeof){ dimension=read!(int, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ difficulty=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ maxPlayers=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] bGV2ZWxUeXBl; bGV2ZWxUeXBl.length=varuint.decode(buffer);if(buffer.length>=bGV2ZWxUeXBl.length){ bGV2ZWxUeXBl=buffer[0..bGV2ZWxUeXBl.length]; buffer=buffer[bGV2ZWxUeXBl.length..$]; }; levelType=cast(string)bGV2ZWxUeXBl;
		if(buffer.length>=bool.sizeof){ reducedDebug=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Map {

	public enum uint ID = 36;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint mapId;
	public ubyte scale;
	public bool showIcons;
	public types.Icon[] icons;
	public ubyte colums;
	public ubyte rows;
	public Tuple!(ubyte, "x", ubyte, "z") offset;
	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(mapId);
		buffer~=scale;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, showIcons, buffer.length-bool.sizeof);
		buffer~=varuint.encode(icons.length.to!uint);foreach(aWNvbnM;icons){ aWNvbnM.encode(buffer); }
		buffer~=colums;
		buffer~=rows;
		buffer~=offset.x;buffer~=offset.z;
		buffer~=varuint.encode(data.length.to!uint);buffer~=data;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		mapId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ scale=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ showIcons=read!(bool, Endian.bigEndian)(buffer); }
		icons.length=varuint.decode(buffer);foreach(ref aWNvbnM;icons){ aWNvbnM.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ colums=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ rows=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ offset.x=read!(ubyte, Endian.bigEndian)(buffer); }if(buffer.length>=ubyte.sizeof){ offset.z=read!(ubyte, Endian.bigEndian)(buffer); }
		data.length=varuint.decode(buffer);if(buffer.length>=data.length){ data=buffer[0..data.length]; buffer=buffer[data.length..$]; }
		return this;
	}

}

struct EntityRelativeMove {

	public enum uint ID = 37;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") delta;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, delta.x, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, delta.y, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, delta.z, buffer.length-short.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, onGround, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=short.sizeof){ delta.x=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ delta.y=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ delta.z=read!(short, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ onGround=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct EntityLookAndRelativeMove {

	public enum uint ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") delta;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, delta.x, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, delta.y, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, delta.z, buffer.length-short.sizeof);
		buffer~=yaw;
		buffer~=pitch;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, onGround, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=short.sizeof){ delta.x=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ delta.y=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ delta.z=read!(short, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ yaw=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ pitch=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ onGround=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct EntityLook {

	public enum uint ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=yaw;
		buffer~=pitch;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, onGround, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ yaw=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ pitch=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ onGround=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Entity {

	public enum uint ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		return this;
	}

}

struct VehicleMove {

	public enum uint ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(double, "x", double, "y", double, "z") position;
	public float yaw;
	public float pitch;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, yaw, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, pitch, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct OpenSignEditor {

	public enum uint ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct PlayerAbilities {

	public enum uint ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags
	public enum ubyte INVULNERABLE = 1;
	public enum ubyte FLYING = 2;
	public enum ubyte ALLOW_FLYING = 4;
	public enum ubyte CREATIVE_MODE = 8;

	public ubyte flags;
	public float flyingSpeed;
	public float fovModifier;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=flags;
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, flyingSpeed, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, fovModifier, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ flags=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ flyingSpeed=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ fovModifier=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct CombatEvent {

	public enum uint ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte eventId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=eventId;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ eventId=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct PlayerListItem {

	public enum uint ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(action);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		action=varuint.decode(buffer);
		return this;
	}

}

struct PlayerPositionAndLook {

	public enum uint ID = 46;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(double, "x", double, "y", double, "z") position;
	public float yaw;
	public float pitch;
	public ubyte flags;
	public uint teleportId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, yaw, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, pitch, buffer.length-float.sizeof);
		buffer~=flags;
		buffer~=varuint.encode(teleportId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ yaw=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ flags=read!(ubyte, Endian.bigEndian)(buffer); }
		teleportId=varuint.decode(buffer);
		return this;
	}

}

struct UseBed {

	public enum uint ID = 47;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ulong position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct DestroyEntities {

	public enum uint ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint[] entityIds;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityIds.length.to!uint);foreach(ZW50aXR5SWRz;entityIds){ buffer~=varuint.encode(ZW50aXR5SWRz); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityIds.length=varuint.decode(buffer);foreach(ref ZW50aXR5SWRz;entityIds){ ZW50aXR5SWRz=varuint.decode(buffer); }
		return this;
	}

}

struct RemoveEntityEffect {

	public enum uint ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte effectId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=effectId;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ effectId=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ResourcePackSend {

	public enum uint ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string url;
	public string hash;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] dXJs=cast(ubyte[])url; buffer~=varuint.encode(dXJs.length.to!uint);buffer~=dXJs;
		ubyte[] aGFzaA=cast(ubyte[])hash; buffer~=varuint.encode(aGFzaA.length.to!uint);buffer~=aGFzaA;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] dXJs; dXJs.length=varuint.decode(buffer);if(buffer.length>=dXJs.length){ dXJs=buffer[0..dXJs.length]; buffer=buffer[dXJs.length..$]; }; url=cast(string)dXJs;
		ubyte[] aGFzaA; aGFzaA.length=varuint.decode(buffer);if(buffer.length>=aGFzaA.length){ aGFzaA=buffer[0..aGFzaA.length]; buffer=buffer[aGFzaA.length..$]; }; hash=cast(string)aGFzaA;
		return this;
	}

}

struct Respawn {

	public enum uint ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int END = -1;
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	// gamemode
	public enum ubyte SURVIVAL = 0;
	public enum ubyte CREATIVE = 1;
	public enum ubyte ADVENTURE = 2;
	public enum ubyte SPECTATOR = 3;

	public int dimension;
	public ubyte difficulty;
	public ubyte gamemode;
	public string levelType;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, dimension, buffer.length-int.sizeof);
		buffer~=difficulty;
		buffer~=gamemode;
		ubyte[] bGV2ZWxUeXBl=cast(ubyte[])levelType; buffer~=varuint.encode(bGV2ZWxUeXBl.length.to!uint);buffer~=bGV2ZWxUeXBl;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=int.sizeof){ dimension=read!(int, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ difficulty=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ gamemode=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] bGV2ZWxUeXBl; bGV2ZWxUeXBl.length=varuint.decode(buffer);if(buffer.length>=bGV2ZWxUeXBl.length){ bGV2ZWxUeXBl=buffer[0..bGV2ZWxUeXBl.length]; buffer=buffer[bGV2ZWxUeXBl.length..$]; }; levelType=cast(string)bGV2ZWxUeXBl;
		return this;
	}

}

struct EntityHeadLook {

	public enum uint ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte headYaw;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=headYaw;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ headYaw=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct WorldBorder {

	public enum uint ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(action);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		action=varuint.decode(buffer);
		return this;
	}

}

struct Camera {

	public enum uint ID = 54;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		return this;
	}

}

struct HeldItemChange {

	public enum uint ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte slot;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=slot;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ slot=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct DisplayScoreboard {

	public enum uint ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// position
	public enum ubyte LIST = 0;
	public enum ubyte SIDEBAR = 1;
	public enum ubyte BELOW_NAME = 2;

	public ubyte position;
	public string scoreName;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=position;
		ubyte[] c2NvcmVOYW1l=cast(ubyte[])scoreName; buffer~=varuint.encode(c2NvcmVOYW1l.length.to!uint);buffer~=c2NvcmVOYW1l;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ubyte.sizeof){ position=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] c2NvcmVOYW1l; c2NvcmVOYW1l.length=varuint.decode(buffer);if(buffer.length>=c2NvcmVOYW1l.length){ c2NvcmVOYW1l=buffer[0..c2NvcmVOYW1l.length]; buffer=buffer[c2NvcmVOYW1l.length..$]; }; scoreName=cast(string)c2NvcmVOYW1l;
		return this;
	}

}

struct EntityMetadata {

	public enum uint ID = 57;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		metadata.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		metadata.decode(buffer);
		return this;
	}

}

struct AttachEntity {

	public enum uint ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint target;
	public uint holder;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, target, buffer.length-uint.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, holder, buffer.length-uint.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=uint.sizeof){ target=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ holder=read!(uint, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct EntityVelocity {

	public enum uint ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") velocity;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.x, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.y, buffer.length-short.sizeof);buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, velocity.z, buffer.length-short.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=short.sizeof){ velocity.x=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ velocity.y=read!(short, Endian.bigEndian)(buffer); }if(buffer.length>=short.sizeof){ velocity.z=read!(short, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct EntityEquipment {

	public enum uint ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public uint slot;
	public types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=varuint.encode(slot);
		item.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		slot=varuint.decode(buffer);
		item.decode(buffer);
		return this;
	}

}

struct SetExperience {

	public enum uint ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public float experience;
	public uint level;
	public uint totalExperience;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, experience, buffer.length-float.sizeof);
		buffer~=varuint.encode(level);
		buffer~=varuint.encode(totalExperience);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=float.sizeof){ experience=read!(float, Endian.bigEndian)(buffer); }
		level=varuint.decode(buffer);
		totalExperience=varuint.decode(buffer);
		return this;
	}

}

struct UpdateHealth {

	public enum uint ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public float health;
	public uint hunger;
	public float saturation;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, health, buffer.length-float.sizeof);
		buffer~=varuint.encode(hunger);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, saturation, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=float.sizeof){ health=read!(float, Endian.bigEndian)(buffer); }
		hunger=varuint.decode(buffer);
		if(buffer.length>=float.sizeof){ saturation=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ScoreboardObjective {

	public enum uint ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// mode
	public enum ubyte CREATE = 0;
	public enum ubyte REMOVE = 1;
	public enum ubyte UPDATE = 2;

	public string name;
	public ubyte mode;
	public string value;
	public string type;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer~=mode;
		ubyte[] dmFsdWU=cast(ubyte[])value; buffer~=varuint.encode(dmFsdWU.length.to!uint);buffer~=dmFsdWU;
		ubyte[] dHlwZQ=cast(ubyte[])type; buffer~=varuint.encode(dHlwZQ.length.to!uint);buffer~=dHlwZQ;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		if(buffer.length>=ubyte.sizeof){ mode=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] dmFsdWU; dmFsdWU.length=varuint.decode(buffer);if(buffer.length>=dmFsdWU.length){ dmFsdWU=buffer[0..dmFsdWU.length]; buffer=buffer[dmFsdWU.length..$]; }; value=cast(string)dmFsdWU;
		ubyte[] dHlwZQ; dHlwZQ.length=varuint.decode(buffer);if(buffer.length>=dHlwZQ.length){ dHlwZQ=buffer[0..dHlwZQ.length]; buffer=buffer[dHlwZQ.length..$]; }; type=cast(string)dHlwZQ;
		return this;
	}

}

struct SetPassengers {

	public enum uint ID = 64;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public uint[] passengers;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=varuint.encode(passengers.length.to!uint);foreach(cGFzc2VuZ2Vycw;passengers){ buffer~=varuint.encode(cGFzc2VuZ2Vycw); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		passengers.length=varuint.decode(buffer);foreach(ref cGFzc2VuZ2Vycw;passengers){ cGFzc2VuZ2Vycw=varuint.decode(buffer); }
		return this;
	}

}

struct Teams {

	public enum uint ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string name;
	public ubyte mode;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer~=mode;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		if(buffer.length>=ubyte.sizeof){ mode=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct UpdateScore {

	public enum uint ID = 66;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte UPDATE = 0;
	public enum ubyte REMOVE = 1;

	public string scoreName;
	public ubyte action;
	public string objectiveName;
	public uint value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] c2NvcmVOYW1l=cast(ubyte[])scoreName; buffer~=varuint.encode(c2NvcmVOYW1l.length.to!uint);buffer~=c2NvcmVOYW1l;
		buffer~=action;
		ubyte[] b2JqZWN0aXZlTmFt=cast(ubyte[])objectiveName; buffer~=varuint.encode(b2JqZWN0aXZlTmFt.length.to!uint);buffer~=b2JqZWN0aXZlTmFt;
		buffer~=varuint.encode(value);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] c2NvcmVOYW1l; c2NvcmVOYW1l.length=varuint.decode(buffer);if(buffer.length>=c2NvcmVOYW1l.length){ c2NvcmVOYW1l=buffer[0..c2NvcmVOYW1l.length]; buffer=buffer[c2NvcmVOYW1l.length..$]; }; scoreName=cast(string)c2NvcmVOYW1l;
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] b2JqZWN0aXZlTmFt; b2JqZWN0aXZlTmFt.length=varuint.decode(buffer);if(buffer.length>=b2JqZWN0aXZlTmFt.length){ b2JqZWN0aXZlTmFt=buffer[0..b2JqZWN0aXZlTmFt.length]; buffer=buffer[b2JqZWN0aXZlTmFt.length..$]; }; objectiveName=cast(string)b2JqZWN0aXZlTmFt;
		value=varuint.decode(buffer);
		return this;
	}

}

struct SpawnPosition {

	public enum uint ID = 67;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, position, buffer.length-ulong.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ulong.sizeof){ position=read!(ulong, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct TimeUpdate {

	public enum uint ID = 68;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong worldAge;
	public long time;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, worldAge, buffer.length-ulong.sizeof);
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, time, buffer.length-long.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		if(buffer.length>=ulong.sizeof){ worldAge=read!(ulong, Endian.bigEndian)(buffer); }
		if(buffer.length>=long.sizeof){ time=read!(long, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Title {

	public enum uint ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(action);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		action=varuint.decode(buffer);
		return this;
	}

}

struct SoundEffect {

	public enum uint ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint soundId;
	public uint category;
	public Tuple!(int, "x", int, "y", int, "z") position;
	public float volume;
	public float pitch;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(soundId);
		buffer~=varuint.encode(category);
		buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.x, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.y, buffer.length-int.sizeof);buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(buffer, position.z, buffer.length-int.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, volume, buffer.length-float.sizeof);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, pitch, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		soundId=varuint.decode(buffer);
		category=varuint.decode(buffer);
		if(buffer.length>=int.sizeof){ position.x=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ position.y=read!(int, Endian.bigEndian)(buffer); }if(buffer.length>=int.sizeof){ position.z=read!(int, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ volume=read!(float, Endian.bigEndian)(buffer); }
		if(buffer.length>=float.sizeof){ pitch=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct PlayerListHeaderAndFooter {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string header;
	public string footer;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] aGVhZGVy=cast(ubyte[])header; buffer~=varuint.encode(aGVhZGVy.length.to!uint);buffer~=aGVhZGVy;
		ubyte[] Zm9vdGVy=cast(ubyte[])footer; buffer~=varuint.encode(Zm9vdGVy.length.to!uint);buffer~=Zm9vdGVy;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] aGVhZGVy; aGVhZGVy.length=varuint.decode(buffer);if(buffer.length>=aGVhZGVy.length){ aGVhZGVy=buffer[0..aGVhZGVy.length]; buffer=buffer[aGVhZGVy.length..$]; }; header=cast(string)aGVhZGVy;
		ubyte[] Zm9vdGVy; Zm9vdGVy.length=varuint.decode(buffer);if(buffer.length>=Zm9vdGVy.length){ Zm9vdGVy=buffer[0..Zm9vdGVy.length]; buffer=buffer[Zm9vdGVy.length..$]; }; footer=cast(string)Zm9vdGVy;
		return this;
	}

}

struct CollectItem {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint collected;
	public uint collector;
	public uint count;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(collected);
		buffer~=varuint.encode(collector);
		buffer~=varuint.encode(count);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		collected=varuint.decode(buffer);
		collector=varuint.decode(buffer);
		count=varuint.decode(buffer);
		return this;
	}

}

struct EntityTeleport {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.x, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.y, buffer.length-double.sizeof);buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(buffer, position.z, buffer.length-double.sizeof);
		buffer~=yaw;
		buffer~=pitch;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, onGround, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=double.sizeof){ position.x=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.y=read!(double, Endian.bigEndian)(buffer); }if(buffer.length>=double.sizeof){ position.z=read!(double, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ yaw=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ pitch=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ onGround=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct EntityProperties {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public types.Properties properties;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		properties.encode(buffer);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		properties.decode(buffer);
		return this;
	}

}

struct EntityEffect {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags
	public enum ubyte AMBIENT = 1;
	public enum ubyte SHOW_PARTICLES = 2;

	public uint entityId;
	public ubyte effectId;
	public ubyte amplifier;
	public uint duration;
	public ubyte flags;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(entityId);
		buffer~=effectId;
		buffer~=amplifier;
		buffer~=varuint.encode(duration);
		buffer~=flags;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		entityId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ effectId=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ amplifier=read!(ubyte, Endian.bigEndian)(buffer); }
		duration=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ flags=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}
