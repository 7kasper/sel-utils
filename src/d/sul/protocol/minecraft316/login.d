/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/minecraft316.xml
 */
module sul.protocol.minecraft316.login;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.minecraft316.types;

alias Packets = TypeTuple!(Disconnect, LoginStart, EncryptionRequest, EncryptionResponse, LoginSuccess, SetCompression);

struct Disconnect {

	public enum uint ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string reason;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] cmVhc29u=cast(ubyte[])reason; buffer~=varuint.encode(cmVhc29u.length.to!uint);buffer~=cmVhc29u;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] cmVhc29u; cmVhc29u.length=varuint.decode(buffer);if(buffer.length>=cmVhc29u.length){ cmVhc29u=buffer[0..cmVhc29u.length]; buffer=buffer[cmVhc29u.length..$]; }; reason=cast(string)cmVhc29u;
		return this;
	}

}

struct LoginStart {

	public enum uint ID = 0;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public string username;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] dXNlcm5hbWU=cast(ubyte[])username; buffer~=varuint.encode(dXNlcm5hbWU.length.to!uint);buffer~=dXNlcm5hbWU;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] dXNlcm5hbWU; dXNlcm5hbWU.length=varuint.decode(buffer);if(buffer.length>=dXNlcm5hbWU.length){ dXNlcm5hbWU=buffer[0..dXNlcm5hbWU.length]; buffer=buffer[dXNlcm5hbWU.length..$]; }; username=cast(string)dXNlcm5hbWU;
		return this;
	}

}

struct EncryptionRequest {

	public enum uint ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string serverId;
	public ubyte[] publicKey;
	public ubyte[] verifyToken;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] c2VydmVySWQ=cast(ubyte[])serverId; buffer~=varuint.encode(c2VydmVySWQ.length.to!uint);buffer~=c2VydmVySWQ;
		buffer~=varuint.encode(publicKey.length.to!uint);buffer~=publicKey;
		buffer~=varuint.encode(verifyToken.length.to!uint);buffer~=verifyToken;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] c2VydmVySWQ; c2VydmVySWQ.length=varuint.decode(buffer);if(buffer.length>=c2VydmVySWQ.length){ c2VydmVySWQ=buffer[0..c2VydmVySWQ.length]; buffer=buffer[c2VydmVySWQ.length..$]; }; serverId=cast(string)c2VydmVySWQ;
		publicKey.length=varuint.decode(buffer);if(buffer.length>=publicKey.length){ publicKey=buffer[0..publicKey.length]; buffer=buffer[publicKey.length..$]; }
		verifyToken.length=varuint.decode(buffer);if(buffer.length>=verifyToken.length){ verifyToken=buffer[0..verifyToken.length]; buffer=buffer[verifyToken.length..$]; }
		return this;
	}

}

struct EncryptionResponse {

	public enum uint ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte[] sharedSecret;
	public ubyte[] verifyToken;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(sharedSecret.length.to!uint);buffer~=sharedSecret;
		buffer~=varuint.encode(verifyToken.length.to!uint);buffer~=verifyToken;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		sharedSecret.length=varuint.decode(buffer);if(buffer.length>=sharedSecret.length){ sharedSecret=buffer[0..sharedSecret.length]; buffer=buffer[sharedSecret.length..$]; }
		verifyToken.length=varuint.decode(buffer);if(buffer.length>=verifyToken.length){ verifyToken=buffer[0..verifyToken.length]; buffer=buffer[verifyToken.length..$]; }
		return this;
	}

}

struct LoginSuccess {

	public enum uint ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string uuid;
	public string username;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		ubyte[] dXVpZA=cast(ubyte[])uuid; buffer~=varuint.encode(dXVpZA.length.to!uint);buffer~=dXVpZA;
		ubyte[] dXNlcm5hbWU=cast(ubyte[])username; buffer~=varuint.encode(dXNlcm5hbWU.length.to!uint);buffer~=dXNlcm5hbWU;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		ubyte[] dXVpZA; dXVpZA.length=varuint.decode(buffer);if(buffer.length>=dXVpZA.length){ dXVpZA=buffer[0..dXVpZA.length]; buffer=buffer[dXVpZA.length..$]; }; uuid=cast(string)dXVpZA;
		ubyte[] dXNlcm5hbWU; dXNlcm5hbWU.length=varuint.decode(buffer);if(buffer.length>=dXNlcm5hbWU.length){ dXNlcm5hbWU=buffer[0..dXNlcm5hbWU.length]; buffer=buffer[dXNlcm5hbWU.length..$]; }; username=cast(string)dXNlcm5hbWU;
		return this;
	}

}

struct SetCompression {

	public enum uint ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint thresold;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=varuint.encode(ID); }
		buffer~=varuint.encode(thresold);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(buffer); }
		thresold=varuint.decode(buffer);
		return this;
	}

}
