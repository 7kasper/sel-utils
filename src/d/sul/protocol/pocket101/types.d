/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket101.xml
 */
module sul.protocol.pocket101.types;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

import sul.metadata.pocket101;

struct Pack {

	public enum string[] FIELDS = ["id", "vers", "size"];

	public string id;
	public string vers;
	public ulong size;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
			writeBytes(varuint.encode(cast(uint)vers.length)); writeString(vers);
			writeBigEndianUlong(size);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			uint awq=varuint.decode(_buffer, &_index); id=readString(awq);
			uint dmvycw=varuint.decode(_buffer, &_index); vers=readString(dmvycw);
			size=readBigEndianUlong();
		}
	}

	public string toString() {
		return "Pack(id: " ~ std.conv.to!string(this.id) ~ ", vers: " ~ std.conv.to!string(this.vers) ~ ", size: " ~ std.conv.to!string(this.size) ~ ")";
	}

}

/**
 * Informations about a slot, that, if not empty, contains an item id and meta, the
 * count (0-255) and, optionally, an nbt tag for enchantments, custom name, colours
 * and more.
 */
struct Slot {

	public enum string[] FIELDS = ["id", "metaAndCount", "nbt"];

	/**
	 * Item's id or 0 if the slot is empty.
	 */
	public int id;

	/**
	 * Item's meta or uses (unsigned short) left-shifted 8 times and the count (unisgned
	 * byte).
	 * Examples:
	 * ---
	 * var encoded = item.meta << 8 | item.count
	 * var meta = encoded >> 8
	 * var count = count & 255
	 * ---
	 */
	public int metaAndCount;

	/**
	 * Optional nbt data encoded as a nameless little-endian compound tag.
	 */
	public ubyte[] nbt;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varint.encode(id));
			if(id>0){ writeBytes(varint.encode(metaAndCount)); }
			if(id>0){ writeLittleEndianUshort(cast(ushort)nbt.length); writeBytes(nbt); }
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			id=varint.decode(_buffer, &_index);
			if(id>0){ metaAndCount=varint.decode(_buffer, &_index); }
			if(id>0){ nbt.length=readLittleEndianUshort(); if(_buffer.length>=_index+nbt.length){ nbt=_buffer[_index.._index+nbt.length].dup; _index+=nbt.length; } }
		}
	}

	public string toString() {
		return "Slot(id: " ~ std.conv.to!string(this.id) ~ ", metaAndCount: " ~ std.conv.to!string(this.metaAndCount) ~ ", nbt: " ~ std.conv.to!string(this.nbt) ~ ")";
	}

}

struct Attribute {

	public enum string[] FIELDS = ["min", "max", "value", "def", "name"];

	public float min;
	public float max;
	public float value;
	public float def;
	public string name;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeLittleEndianFloat(min);
			writeLittleEndianFloat(max);
			writeLittleEndianFloat(value);
			writeLittleEndianFloat(def);
			writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			min=readLittleEndianFloat();
			max=readLittleEndianFloat();
			value=readLittleEndianFloat();
			def=readLittleEndianFloat();
			uint bmftzq=varuint.decode(_buffer, &_index); name=readString(bmftzq);
		}
	}

	public string toString() {
		return "Attribute(min: " ~ std.conv.to!string(this.min) ~ ", max: " ~ std.conv.to!string(this.max) ~ ", value: " ~ std.conv.to!string(this.value) ~ ", def: " ~ std.conv.to!string(this.def) ~ ", name: " ~ std.conv.to!string(this.name) ~ ")";
	}

}

/**
 * Position of a block, where x and z are signed and y is always positive (as blocks
 * cannot be placed under 0).
 */
struct BlockPosition {

	public enum string[] FIELDS = ["x", "y", "z"];

	public int x;
	public uint y;
	public int z;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varint.encode(x));
			writeBytes(varuint.encode(y));
			writeBytes(varint.encode(z));
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			x=varint.decode(_buffer, &_index);
			y=varuint.decode(_buffer, &_index);
			z=varint.decode(_buffer, &_index);
		}
	}

	public string toString() {
		return "BlockPosition(x: " ~ std.conv.to!string(this.x) ~ ", y: " ~ std.conv.to!string(this.y) ~ ", z: " ~ std.conv.to!string(this.z) ~ ")";
	}

}

/**
 * Player's skin.
 */
struct Skin {

	public enum string[] FIELDS = ["name", "data"];

	/**
	 * Name of the skin. It's used to render the shape of the skin correctly.
	 */
	public string name;

	/**
	 * Bytes of the skin in format RGBA. The length should be 8192 or 16382.
	 */
	public ubyte[] data;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
			writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			uint bmftzq=varuint.decode(_buffer, &_index); name=readString(bmftzq);
			data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
		}
	}

	public string toString() {
		return "Skin(name: " ~ std.conv.to!string(this.name) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

/**
 * Informations about a player that will be added to the player's list in the pause
 * menu.
 */
struct PlayerList {

	public enum string[] FIELDS = ["uuid", "entityId", "displayName", "skin"];

	/**
	 * UUID of the player. If it's associated with an XBOX Live account the player's profile
	 * will also be available in pause menu.
	 */
	public UUID uuid;

	/**
	 * Player's id, used to associate the skin with the game's entity spawned with AddPlayer.
	 */
	public long entityId;

	/**
	 * Player's display name, that can contain Minecraft's formatting codes. It shouldn't
	 * contain suffixes nor prefixes.
	 */
	public string displayName;

	/**
	 * Player's skin usually given in the Login's packet body.
	 */
	public sul.protocol.pocket101.types.Skin skin;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(uuid.data);
			writeBytes(varlong.encode(entityId));
			writeBytes(varuint.encode(cast(uint)displayName.length)); writeString(displayName);
			skin.encode(bufferInstance);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			if(_buffer.length>=_index+16){ ubyte[16] dxvpza=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dxvpza); }
			entityId=varlong.decode(_buffer, &_index);
			uint zglzcgxheu5hbwu=varuint.decode(_buffer, &_index); displayName=readString(zglzcgxheu5hbwu);
			skin.decode(bufferInstance);
		}
	}

	public string toString() {
		return "PlayerList(uuid: " ~ std.conv.to!string(this.uuid) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", displayName: " ~ std.conv.to!string(this.displayName) ~ ", skin: " ~ std.conv.to!string(this.skin) ~ ")";
	}

}

struct Link {

	// action
	public enum ubyte ADD = 0;
	public enum ubyte RIDE = 1;
	public enum ubyte REMOVE = 2;

	public enum string[] FIELDS = ["from", "to", "action"];

	public long from;
	public long to;
	public ubyte action;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varlong.encode(from));
			writeBytes(varlong.encode(to));
			writeBigEndianUbyte(action);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			from=varlong.decode(_buffer, &_index);
			to=varlong.decode(_buffer, &_index);
			action=readBigEndianUbyte();
		}
	}

	public string toString() {
		return "Link(from: " ~ std.conv.to!string(this.from) ~ ", to: " ~ std.conv.to!string(this.to) ~ ", action: " ~ std.conv.to!string(this.action) ~ ")";
	}

}

struct Recipe {

	// type
	public enum int SHAPELESS = 0;
	public enum int SHAPED = 1;
	public enum int FURNACE = 2;
	public enum int FURNACE_DATA = 3;
	public enum int MULTI = 4;

	public enum string[] FIELDS = ["type", "data"];

	public int type;
	public ubyte[] data;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varint.encode(type));
			writeBytes(data);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			type=varint.decode(_buffer, &_index);
			data=_buffer[_index..$].dup; _index=_buffer.length;
		}
	}

	public string toString() {
		return "Recipe(type: " ~ std.conv.to!string(this.type) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

/**
 * A game rule that prevents the client from doing client-side actions and animations.
 */
struct Rule {

	// name
	public enum string DROWNING_DAMAGE = "drowningdamage";
	public enum string FALL_DAMAGE = "falldamage";
	public enum string FIRE_DAMAGE = "firedamage";
	public enum string IMMUTABLE_WORLD = "immutableworld";
	public enum string PVP = "pvp";

	public enum string[] FIELDS = ["name", "value", "unknown2"];

	/**
	 * Name of the rule. Same of the `gamerule` command's field in Minecraft: Education
	 * Edition.
	 * The behaviours indicated in the following constants' descriptions is enabled or
	 * disabled.
	 */
	public string name;

	/**
	 * Indicates whether the game rule is enabled.
	 */
	public bool value;
	public bool unknown2;

	public pure nothrow @safe void encode(Buffer buffer) {
		with(buffer) {
			writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
			writeBigEndianBool(value);
			writeBigEndianBool(unknown2);
		}
	}

	public pure nothrow @safe void decode(Buffer buffer) {
		with(buffer) {
			uint bmftzq=varuint.decode(_buffer, &_index); name=readString(bmftzq);
			value=readBigEndianBool();
			unknown2=readBigEndianBool();
		}
	}

	public string toString() {
		return "Rule(name: " ~ std.conv.to!string(this.name) ~ ", value: " ~ std.conv.to!string(this.value) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}
