/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
module sul.protocol.hncom1.types;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.uuid : UUID;

import sul.utils.var;

struct Plugin {

	public string name;
	public string vers;

	public void encode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		ubyte[] dmVyc2lvbg=cast(ubyte[])version; buffer~=varuint.encode(dmVyc2lvbg.length.to!uint);buffer~=dmVyc2lvbg;
	}

	public void decode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		ubyte[] dmVyc2lvbg; dmVyc2lvbg.length=varuint.decode(buffer);if(buffer.length>=dmVyc2lvbg.length){ dmVyc2lvbg=buffer[0..dmVyc2lvbg.length]; buffer=buffer[dmVyc2lvbg.length..$]; }; version=cast(string)dmVyc2lvbg;
	}

}

/**
 * Internet protocol address. Could be either version 4 and 6.
 */
struct Address {

	/**
	 * Bytes of the address. The length may be 4 (for ipv4 addresses) or 16 (for ipv6 addresses).
	 * The byte order is always big-endian (network order).
	 */
	public ubyte[] bytes;

	/**
	 * Port of the address.
	 */
	public ushort port;

	public void encode(ref ubyte[] buffer) {
		buffer~=varuint.encode(bytes.length.to!uint);buffer~=bytes;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, port, buffer.length-ushort.sizeof);
	}

	public void decode(ref ubyte[] buffer) {
		bytes.length=varuint.decode(buffer);if(buffer.length>=bytes.length){ bytes=buffer[0..bytes.length]; buffer=buffer[bytes.length..$]; }
		if(buffer.length>=ushort.sizeof){ port=read!(ushort, Endian.bigEndian)(buffer); }
	}

}

struct Game {

	// type
	public enum ubyte POCKET = 1;
	public enum ubyte MINECRAFT = 2;

	public ubyte type;
	public uint[] protocols;
	public string motd;
	public ushort port;

	public void encode(ref ubyte[] buffer) {
		buffer~=type;
		buffer~=varuint.encode(protocols.length.to!uint);foreach(cHJvdG9jb2xz;protocols){ buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, cHJvdG9jb2xz, buffer.length-uint.sizeof); }
		ubyte[] bW90ZA=cast(ubyte[])motd; buffer~=varuint.encode(bW90ZA.length.to!uint);buffer~=bW90ZA;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, port, buffer.length-ushort.sizeof);
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=ubyte.sizeof){ type=read!(ubyte, Endian.bigEndian)(buffer); }
		protocols.length=varuint.decode(buffer);foreach(ref cHJvdG9jb2xz;protocols){ if(buffer.length>=uint.sizeof){ cHJvdG9jb2xz=read!(uint, Endian.bigEndian)(buffer); } }
		ubyte[] bW90ZA; bW90ZA.length=varuint.decode(buffer);if(buffer.length>=bW90ZA.length){ bW90ZA=buffer[0..bW90ZA.length]; buffer=buffer[bW90ZA.length..$]; }; motd=cast(string)bW90ZA;
		if(buffer.length>=ushort.sizeof){ port=read!(ushort, Endian.bigEndian)(buffer); }
	}

}

struct Skin {

	public string name;
	public ubyte[] data;

	public void encode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer~=varuint.encode(data.length.to!uint);buffer~=data;
	}

	public void decode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		data.length=varuint.decode(buffer);if(buffer.length>=data.length){ data=buffer[0..data.length]; buffer=buffer[data.length..$]; }
	}

}

struct Log {

	public ulong timestamp;
	public string logger;
	public string message;

	public void encode(ref ubyte[] buffer) {
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, timestamp, buffer.length-ulong.sizeof);
		ubyte[] bG9nZ2Vy=cast(ubyte[])logger; buffer~=varuint.encode(bG9nZ2Vy.length.to!uint);buffer~=bG9nZ2Vy;
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint);buffer~=bWVzc2FnZQ;
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=ulong.sizeof){ timestamp=read!(ulong, Endian.bigEndian)(buffer); }
		ubyte[] bG9nZ2Vy; bG9nZ2Vy.length=varuint.decode(buffer);if(buffer.length>=bG9nZ2Vy.length){ bG9nZ2Vy=buffer[0..bG9nZ2Vy.length]; buffer=buffer[bG9nZ2Vy.length..$]; }; logger=cast(string)bG9nZ2Vy;
		ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(buffer);if(buffer.length>=bWVzc2FnZQ.length){ bWVzc2FnZQ=buffer[0..bWVzc2FnZQ.length]; buffer=buffer[bWVzc2FnZQ.length..$]; }; message=cast(string)bWVzc2FnZQ;
	}

}
