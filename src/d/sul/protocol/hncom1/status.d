/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
module sul.protocol.hncom1.status;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.hncom1.types;

alias Packets = TypeTuple!(Players, AddNode, RemoveNode, ResourcesUsage);

/**
 * Updates the number of players on the server.
 */
class Players : Buffer {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["online", "max"];

	public uint online;
	public uint max;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint online, uint max=uint.init) {
		this.online = online;
		this.max = max;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(online));
		writeBytes(varuint.encode(max));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		online=varuint.decode(_buffer, &_index);
		max=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Players fromBuffer(bool readId=true)(ubyte[] buffer) {
		Players ret = new Players();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

class AddNode : Buffer {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["hubId", "name", "main", "acceptedGames"];

	public uint hubId;
	public string name;
	public bool main;
	public sul.protocol.hncom1.types.Game[] acceptedGames;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint hubId, string name=string.init, bool main=bool.init, sul.protocol.hncom1.types.Game[] acceptedGames=(sul.protocol.hncom1.types.Game[]).init) {
		this.hubId = hubId;
		this.name = name;
		this.main = main;
		this.acceptedGames = acceptedGames;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(hubId));
		writeBytes(varuint.encode(cast(uint)name.length)); writeString(name);
		writeBigEndianBool(main);
		writeBytes(varuint.encode(cast(uint)acceptedGames.length)); foreach(ywnjzxb0zwrhyw1l;acceptedGames){ ywnjzxb0zwrhyw1l.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		hubId=varuint.decode(_buffer, &_index);
		uint bmftzq=varuint.decode(_buffer, &_index); name=readString(bmftzq);
		main=readBigEndianBool();
		acceptedGames.length=varuint.decode(_buffer, &_index); foreach(ref ywnjzxb0zwrhyw1l;acceptedGames){ ywnjzxb0zwrhyw1l.decode(bufferInstance); }
	}

	public static pure nothrow @safe AddNode fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddNode ret = new AddNode();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

class RemoveNode : Buffer {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["hubId"];

	public uint hubId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint hubId) {
		this.hubId = hubId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(hubId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		hubId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RemoveNode fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveNode ret = new RemoveNode();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

/**
 * Updates the usage of the resources in the node.
 */
class ResourcesUsage : Buffer {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["tps", "ram", "cpu"];

	public float tps;
	public ulong ram;
	public float cpu;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float tps, ulong ram=ulong.init, float cpu=float.init) {
		this.tps = tps;
		this.ram = ram;
		this.cpu = cpu;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianFloat(tps);
		writeBytes(varulong.encode(ram));
		writeBigEndianFloat(cpu);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		tps=readBigEndianFloat();
		ram=varulong.decode(_buffer, &_index);
		cpu=readBigEndianFloat();
	}

	public static pure nothrow @safe ResourcesUsage fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcesUsage ret = new ResourcesUsage();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}
