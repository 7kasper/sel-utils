/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
module sul.protocol.hncom1.status;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.hncom1.types;

alias Packets = TypeTuple!(Players, Nodes, ResourcesUsage);

class Players : Buffer {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["online", "max"];

	public uint online;
	public uint max;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint online, uint max=uint.init) {
		this.online = online;
		this.max = max;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(online));
		writeBytes(varuint.encode(max));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		online=varuint.decode(_buffer, &_index);
		max=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Players fromBuffer(bool readId=true)(ubyte[] buffer) {
		Players ret = new Players();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

class Nodes : Buffer {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action", "node"];

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public ubyte action;
	public string node;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, string node=string.init) {
		this.action = action;
		this.node = node;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		writeBytes(varuint.encode(cast(uint)node.length)); writeString(node);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
		uint bm9kzq=varuint.decode(_buffer, &_index); node=readString(bm9kzq);
	}

	public static pure nothrow @safe Nodes fromBuffer(bool readId=true)(ubyte[] buffer) {
		Nodes ret = new Nodes();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

class ResourcesUsage : Buffer {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["tps", "ram", "cpu"];

	public float tps;
	public ulong ram;
	public float cpu;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float tps, ulong ram=ulong.init, float cpu=float.init) {
		this.tps = tps;
		this.ram = ram;
		this.cpu = cpu;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(tps);
		writeBytes(varulong.encode(ram));
		writeLittleEndianFloat(cpu);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		tps=readLittleEndianFloat();
		ram=varulong.decode(_buffer, &_index);
		cpu=readLittleEndianFloat();
	}

	public static pure nothrow @safe ResourcesUsage fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcesUsage ret = new ResourcesUsage();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}
