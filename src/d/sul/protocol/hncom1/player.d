/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
module sul.protocol.hncom1.player;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.hncom1.types;

alias Packets = TypeTuple!(Add, Remove, Kick, Transfer, UpdateLanguage, UpdateDisplayName, UpdateLatency, UpdatePacketLoss, GamePacket, OrderedGamePacket);

struct Add {

	public enum ubyte ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// reason
	public enum ubyte FIRST_JOIN = 0;
	public enum ubyte TRANSFERRED = 1;
	public enum ubyte FORCIBLY_TRANSFERRED = 2;

	// game
	public enum ubyte POCKET = 1;
	public enum ubyte MINECRAFT = 2;

	public uint hubId;
	public ubyte reason;
	public uint protocol;
	public string username;
	public string displayName;
	public types.Address address;
	public ubyte game;
	public UUID uuid;
	public types.Skin skin;
	public uint latency;
	public float packetLoss;
	public string language;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		buffer~=reason;
		buffer~=varuint.encode(protocol);
		ubyte[] dXNlcm5hbWU=cast(ubyte[])username; buffer~=varuint.encode(dXNlcm5hbWU.length.to!uint);buffer~=dXNlcm5hbWU;
		ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint);buffer~=ZGlzcGxheU5hbWU;
		address.encode(buffer);
		buffer~=game;
		buffer~=uuid.data;
		skin.encode(buffer);
		buffer~=varuint.encode(latency);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, packetLoss, buffer.length-float.sizeof);
		ubyte[] bGFuZ3VhZ2U=cast(ubyte[])language; buffer~=varuint.encode(bGFuZ3VhZ2U.length.to!uint);buffer~=bGFuZ3VhZ2U;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ reason=read!(ubyte, Endian.bigEndian)(buffer); }
		protocol=varuint.decode(buffer);
		ubyte[] dXNlcm5hbWU; dXNlcm5hbWU.length=varuint.decode(buffer);if(buffer.length>=dXNlcm5hbWU.length){ dXNlcm5hbWU=buffer[0..dXNlcm5hbWU.length]; buffer=buffer[dXNlcm5hbWU.length..$]; }; username=cast(string)dXNlcm5hbWU;
		ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(buffer);if(buffer.length>=ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=buffer[0..ZGlzcGxheU5hbWU.length]; buffer=buffer[ZGlzcGxheU5hbWU.length..$]; }; displayName=cast(string)ZGlzcGxheU5hbWU;
		address.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ game=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		skin.decode(buffer);
		latency=varuint.decode(buffer);
		if(buffer.length>=float.sizeof){ packetLoss=read!(float, Endian.bigEndian)(buffer); }
		ubyte[] bGFuZ3VhZ2U; bGFuZ3VhZ2U.length=varuint.decode(buffer);if(buffer.length>=bGFuZ3VhZ2U.length){ bGFuZ3VhZ2U=buffer[0..bGFuZ3VhZ2U.length]; buffer=buffer[bGFuZ3VhZ2U.length..$]; }; language=cast(string)bGFuZ3VhZ2U;
		return this;
	}

}

struct Remove {

	public enum ubyte ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// reason
	public enum ubyte LEFT = 0;
	public enum ubyte TIMED_OUT = 1;
	public enum ubyte KICKED = 2;
	public enum ubyte TRANSFERRED = 3;

	public uint hubId;
	public ubyte reason;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		buffer~=reason;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		if(buffer.length>=ubyte.sizeof){ reason=read!(ubyte, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Kick {

	public enum ubyte ID = 12;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public uint hubId;
	public string reason;
	public bool translation;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		ubyte[] cmVhc29u=cast(ubyte[])reason; buffer~=varuint.encode(cmVhc29u.length.to!uint);buffer~=cmVhc29u;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, translation, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		ubyte[] cmVhc29u; cmVhc29u.length=varuint.decode(buffer);if(buffer.length>=cmVhc29u.length){ cmVhc29u=buffer[0..cmVhc29u.length]; buffer=buffer[cmVhc29u.length..$]; }; reason=cast(string)cmVhc29u;
		if(buffer.length>=bool.sizeof){ translation=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Transfer {

	public enum ubyte ID = 13;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public uint hubId;
	public string node;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		ubyte[] bm9kZQ=cast(ubyte[])node; buffer~=varuint.encode(bm9kZQ.length.to!uint);buffer~=bm9kZQ;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		ubyte[] bm9kZQ; bm9kZQ.length=varuint.decode(buffer);if(buffer.length>=bm9kZQ.length){ bm9kZQ=buffer[0..bm9kZQ.length]; buffer=buffer[bm9kZQ.length..$]; }; node=cast(string)bm9kZQ;
		return this;
	}

}

struct UpdateLanguage {

	public enum ubyte ID = 14;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public uint hubId;
	public string language;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		ubyte[] bGFuZ3VhZ2U=cast(ubyte[])language; buffer~=varuint.encode(bGFuZ3VhZ2U.length.to!uint);buffer~=bGFuZ3VhZ2U;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		ubyte[] bGFuZ3VhZ2U; bGFuZ3VhZ2U.length=varuint.decode(buffer);if(buffer.length>=bGFuZ3VhZ2U.length){ bGFuZ3VhZ2U=buffer[0..bGFuZ3VhZ2U.length]; buffer=buffer[bGFuZ3VhZ2U.length..$]; }; language=cast(string)bGFuZ3VhZ2U;
		return this;
	}

}

struct UpdateDisplayName {

	public enum ubyte ID = 15;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public uint hubId;
	public string displayName;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint);buffer~=ZGlzcGxheU5hbWU;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(buffer);if(buffer.length>=ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=buffer[0..ZGlzcGxheU5hbWU.length]; buffer=buffer[ZGlzcGxheU5hbWU.length..$]; }; displayName=cast(string)ZGlzcGxheU5hbWU;
		return this;
	}

}

struct UpdateLatency {

	public enum ubyte ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint hubId;
	public uint latency;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		buffer~=varuint.encode(latency);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		latency=varuint.decode(buffer);
		return this;
	}

}

struct UpdatePacketLoss {

	public enum ubyte ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint hubId;
	public float packetLoss;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(buffer, packetLoss, buffer.length-float.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		if(buffer.length>=float.sizeof){ packetLoss=read!(float, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct GamePacket {

	public enum ubyte ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public uint hubId;
	public ubyte[] packet;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		buffer~=packet;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		packet=buffer.dup; buffer.length=0;
		return this;
	}

}

struct OrderedGamePacket {

	public enum ubyte ID = 19;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public uint hubId;
	public uint order;
	public ubyte[] packet;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(hubId);
		buffer~=varuint.encode(order);
		buffer~=packet;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		hubId=varuint.decode(buffer);
		order=varuint.decode(buffer);
		packet=buffer.dup; buffer.length=0;
		return this;
	}

}
