/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
module sul.protocol.hncom1.generic;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.hncom1.types;

alias Packets = TypeTuple!(Logs, RemoteCommand, UpdateList);

struct Logs {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public sul.protocol.hncom1.types.Log[] messages;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=varuint.encode(messages.length.to!uint); foreach(bWVzc2FnZXM;messages){ bWVzc2FnZXM.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		messages.length=varuint.decode(_buffer, *_index); foreach(ref bWVzc2FnZXM;messages){ bWVzc2FnZXM.decode(_buffer, _index); }
		return this;
	}

}

struct RemoteCommand {

	public enum ubyte ID = 8;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// origin
	public enum ubyte HUB = 0;
	public enum ubyte EXTERNAL_CONSOLE = 1;
	public enum ubyte RCON = 2;

	public ubyte origin;
	public sul.protocol.hncom1.types.Address sender;
	public string command;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=origin;
		sender.encode(_buffer);
		ubyte[] Y29tbWFuZA=cast(ubyte[])command; _buffer~=varuint.encode(Y29tbWFuZA.length.to!uint); _buffer~=Y29tbWFuZA;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ origin=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		sender.decode(_buffer, _index);
		ubyte[] Y29tbWFuZA; Y29tbWFuZA.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y29tbWFuZA.length){ Y29tbWFuZA=_buffer[*_index..*_index+Y29tbWFuZA.length].dup; *_index+=Y29tbWFuZA.length; }; command=cast(string)Y29tbWFuZA;
		return this;
	}

}

struct UpdateList {

	public enum ubyte ID = 9;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// list
	public enum ubyte WHITELIST = 0;
	public enum ubyte BLACKLIST = 1;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public ubyte list;
	public ubyte action;
	public ubyte type;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=list;
		_buffer~=action;
		_buffer~=type;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+ubyte.sizeof){ list=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ type=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

	public struct ByHubId {

		public enum typeof(type) TYPE = 0;

		public uint hubId;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(hubId);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			hubId=varuint.decode(_buffer, *_index);
			return this;
		}

	}

	public struct ByName {

		public enum typeof(type) TYPE = 1;

		public string username;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] dXNlcm5hbWU=cast(ubyte[])username; _buffer~=varuint.encode(dXNlcm5hbWU.length.to!uint); _buffer~=dXNlcm5hbWU;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] dXNlcm5hbWU; dXNlcm5hbWU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dXNlcm5hbWU.length){ dXNlcm5hbWU=_buffer[*_index..*_index+dXNlcm5hbWU.length].dup; *_index+=dXNlcm5hbWU.length; }; username=cast(string)dXNlcm5hbWU;
			return this;
		}

	}

	public struct BySuuid {

		public enum typeof(type) TYPE = 2;

		// game
		public enum ubyte POCKET = 1;
		public enum ubyte MINECRAFT = 2;

		public ubyte game;
		public UUID uuid;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=game;
			_buffer~=uuid.data;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+ubyte.sizeof){ game=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
			return this;
		}

	}

}
