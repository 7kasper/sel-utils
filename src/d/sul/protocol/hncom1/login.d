/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
module sul.protocol.hncom1.login;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.hncom1.types;

alias Packets = TypeTuple!(Connection, ConnectionResponse, Info, Ready);

struct Connection {

	public enum ubyte ID = 0;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	/**
	 * Version of the protocol used by the client that must match the hub's one
	 */
	public uint protocol;

	/**
	 * Name of the node that will be validated by the hub.
	 */
	public string name;

	/**
	 * Indicates whether the node accepts clients when they first connect to the hub or
	 * exclusively when they are manually transferred.
	 */
	public bool mainNode;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(protocol);
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, mainNode, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		protocol=varuint.decode(buffer);
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		if(buffer.length>=bool.sizeof){ mainNode=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ConnectionResponse {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public bool protocolAccepted;
	public bool nameAccepted;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, protocolAccepted, buffer.length-bool.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, nameAccepted, buffer.length-bool.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=bool.sizeof){ protocolAccepted=read!(bool, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ nameAccepted=read!(bool, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Info {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long serverId;
	public bool onlineMode;
	public string displayName;
	public types.Game[] games;
	public uint online;
	public uint max;
	public string language;
	public string[] acceptedLanguages;
	public string[] nodes;
	public string socialJson;
	public string additionalJson;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, serverId, buffer.length-long.sizeof);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, onlineMode, buffer.length-bool.sizeof);
		ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint);buffer~=ZGlzcGxheU5hbWU;
		buffer~=varuint.encode(games.length.to!uint);foreach(Z2FtZXM;games){ Z2FtZXM.encode(buffer); }
		buffer~=varuint.encode(online);
		buffer~=varuint.encode(max);
		ubyte[] bGFuZ3VhZ2U=cast(ubyte[])language; buffer~=varuint.encode(bGFuZ3VhZ2U.length.to!uint);buffer~=bGFuZ3VhZ2U;
		buffer~=varuint.encode(acceptedLanguages.length.to!uint);foreach(YWNjZXB0ZWRMYW5n;acceptedLanguages){ ubyte[] WVdOalpYQjBaV1JN=cast(ubyte[])YWNjZXB0ZWRMYW5n; buffer~=varuint.encode(WVdOalpYQjBaV1JN.length.to!uint);buffer~=WVdOalpYQjBaV1JN; }
		buffer~=varuint.encode(nodes.length.to!uint);foreach(bm9kZXM;nodes){ ubyte[] Ym05a1pYTQ=cast(ubyte[])bm9kZXM; buffer~=varuint.encode(Ym05a1pYTQ.length.to!uint);buffer~=Ym05a1pYTQ; }
		ubyte[] c29jaWFsSnNvbg=cast(ubyte[])socialJson; buffer~=varuint.encode(c29jaWFsSnNvbg.length.to!uint);buffer~=c29jaWFsSnNvbg;
		ubyte[] YWRkaXRpb25hbEpz=cast(ubyte[])additionalJson; buffer~=varuint.encode(YWRkaXRpb25hbEpz.length.to!uint);buffer~=YWRkaXRpb25hbEpz;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=long.sizeof){ serverId=read!(long, Endian.bigEndian)(buffer); }
		if(buffer.length>=bool.sizeof){ onlineMode=read!(bool, Endian.bigEndian)(buffer); }
		ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(buffer);if(buffer.length>=ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=buffer[0..ZGlzcGxheU5hbWU.length]; buffer=buffer[ZGlzcGxheU5hbWU.length..$]; }; displayName=cast(string)ZGlzcGxheU5hbWU;
		games.length=varuint.decode(buffer);foreach(ref Z2FtZXM;games){ Z2FtZXM.decode(buffer); }
		online=varuint.decode(buffer);
		max=varuint.decode(buffer);
		ubyte[] bGFuZ3VhZ2U; bGFuZ3VhZ2U.length=varuint.decode(buffer);if(buffer.length>=bGFuZ3VhZ2U.length){ bGFuZ3VhZ2U=buffer[0..bGFuZ3VhZ2U.length]; buffer=buffer[bGFuZ3VhZ2U.length..$]; }; language=cast(string)bGFuZ3VhZ2U;
		acceptedLanguages.length=varuint.decode(buffer);foreach(ref YWNjZXB0ZWRMYW5n;acceptedLanguages){ ubyte[] WVdOalpYQjBaV1JN; WVdOalpYQjBaV1JN.length=varuint.decode(buffer);if(buffer.length>=WVdOalpYQjBaV1JN.length){ WVdOalpYQjBaV1JN=buffer[0..WVdOalpYQjBaV1JN.length]; buffer=buffer[WVdOalpYQjBaV1JN.length..$]; }; YWNjZXB0ZWRMYW5n=cast(string)WVdOalpYQjBaV1JN; }
		nodes.length=varuint.decode(buffer);foreach(ref bm9kZXM;nodes){ ubyte[] Ym05a1pYTQ; Ym05a1pYTQ.length=varuint.decode(buffer);if(buffer.length>=Ym05a1pYTQ.length){ Ym05a1pYTQ=buffer[0..Ym05a1pYTQ.length]; buffer=buffer[Ym05a1pYTQ.length..$]; }; bm9kZXM=cast(string)Ym05a1pYTQ; }
		ubyte[] c29jaWFsSnNvbg; c29jaWFsSnNvbg.length=varuint.decode(buffer);if(buffer.length>=c29jaWFsSnNvbg.length){ c29jaWFsSnNvbg=buffer[0..c29jaWFsSnNvbg.length]; buffer=buffer[c29jaWFsSnNvbg.length..$]; }; socialJson=cast(string)c29jaWFsSnNvbg;
		ubyte[] YWRkaXRpb25hbEpz; YWRkaXRpb25hbEpz.length=varuint.decode(buffer);if(buffer.length>=YWRkaXRpb25hbEpz.length){ YWRkaXRpb25hbEpz=buffer[0..YWRkaXRpb25hbEpz.length]; buffer=buffer[YWRkaXRpb25hbEpz.length..$]; }; additionalJson=cast(string)YWRkaXRpb25hbEpz;
		return this;
	}

}

struct Ready {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public types.Plugin[] plugins;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=varuint.encode(plugins.length.to!uint);foreach(cGx1Z2lucw;plugins){ cGx1Z2lucw.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		plugins.length=varuint.decode(buffer);foreach(ref cGx1Z2lucw;plugins){ cGx1Z2lucw.decode(buffer); }
		return this;
	}

}
