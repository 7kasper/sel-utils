/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/minecraft210.xml
 */
module sul.protocol.minecraft210.types;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.uuid : UUID;

import sul.utils.var;

struct Statistic {

	public string name;
	public uint value;

	public void encode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer~=varuint.encode(value);
	}

	public void decode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		value=varuint.decode(buffer);
	}

}

struct BlockChange {

	public ubyte xz;
	public ubyte y;
	public uint block;

	public void encode(ref ubyte[] buffer) {
		buffer~=xz;
		buffer~=y;
		buffer~=varuint.encode(block);
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=ubyte.sizeof){ xz=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ y=read!(ubyte, Endian.bigEndian)(buffer); }
		block=varuint.decode(buffer);
	}

}

struct Slot {

	public short id;
	public ubyte count;
	public ushort damage;
	public ubyte[] nbt;

	public void encode(ref ubyte[] buffer) {
		buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(buffer, id, buffer.length-short.sizeof);
		if(id>0){ buffer~=count; }
		if(id>0){ buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, damage, buffer.length-ushort.sizeof); }
		if(id>0){ buffer~=nbt; }
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=short.sizeof){ id=read!(short, Endian.bigEndian)(buffer); }
		if(id>0){ if(buffer.length>=ubyte.sizeof){ count=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(id>0){ if(buffer.length>=ushort.sizeof){ damage=read!(ushort, Endian.bigEndian)(buffer); } }
		if(id>0){ nbt=buffer.dup; buffer.length=0; }
	}

}

struct Icon {

	public ubyte directionAndType;
	public Tuple!(ubyte, "x", ubyte, "z") position;

	public void encode(ref ubyte[] buffer) {
		buffer~=directionAndType;
		buffer~=position.x;buffer~=position.z;
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=ubyte.sizeof){ directionAndType=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ubyte.sizeof){ position.x=read!(ubyte, Endian.bigEndian)(buffer); }if(buffer.length>=ubyte.sizeof){ position.z=read!(ubyte, Endian.bigEndian)(buffer); }
	}

}

struct Property {

	public string name;
	public string value;
	public bool signed;
	public string signature;

	public void encode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		ubyte[] dmFsdWU=cast(ubyte[])value; buffer~=varuint.encode(dmFsdWU.length.to!uint);buffer~=dmFsdWU;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, signed, buffer.length-bool.sizeof);
		if(signed==true){ ubyte[] c2lnbmF0dXJl=cast(ubyte[])signature; buffer~=varuint.encode(c2lnbmF0dXJl.length.to!uint);buffer~=c2lnbmF0dXJl; }
	}

	public void decode(ref ubyte[] buffer) {
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		ubyte[] dmFsdWU; dmFsdWU.length=varuint.decode(buffer);if(buffer.length>=dmFsdWU.length){ dmFsdWU=buffer[0..dmFsdWU.length]; buffer=buffer[dmFsdWU.length..$]; }; value=cast(string)dmFsdWU;
		if(buffer.length>=bool.sizeof){ signed=read!(bool, Endian.bigEndian)(buffer); }
		if(signed==true){ ubyte[] c2lnbmF0dXJl; c2lnbmF0dXJl.length=varuint.decode(buffer);if(buffer.length>=c2lnbmF0dXJl.length){ c2lnbmF0dXJl=buffer[0..c2lnbmF0dXJl.length]; buffer=buffer[c2lnbmF0dXJl.length..$]; }; signature=cast(string)c2lnbmF0dXJl; }
	}

}

struct ListAddPlayer {

	// gamemode
	public enum uint SURVIVAL = 0;
	public enum uint CREATIVE = 1;
	public enum uint ADVENTURE = 2;
	public enum uint SPECTATOR = 3;

	public UUID uuid;
	public string name;
	public types.Property[] properties;
	public uint gamemode;
	public uint latency;
	public bool hasDisplayName;
	public string displayName;

	public void encode(ref ubyte[] buffer) {
		buffer~=uuid.data;
		ubyte[] bmFtZQ=cast(ubyte[])name; buffer~=varuint.encode(bmFtZQ.length.to!uint);buffer~=bmFtZQ;
		buffer~=varuint.encode(properties.length.to!uint);foreach(cHJvcGVydGllcw;properties){ cHJvcGVydGllcw.encode(buffer); }
		buffer~=varuint.encode(gamemode);
		buffer~=varuint.encode(latency);
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, hasDisplayName, buffer.length-bool.sizeof);
		if(hasDisplayName==true){ ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint);buffer~=ZGlzcGxheU5hbWU; }
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(buffer);if(buffer.length>=bmFtZQ.length){ bmFtZQ=buffer[0..bmFtZQ.length]; buffer=buffer[bmFtZQ.length..$]; }; name=cast(string)bmFtZQ;
		properties.length=varuint.decode(buffer);foreach(ref cHJvcGVydGllcw;properties){ cHJvcGVydGllcw.decode(buffer); }
		gamemode=varuint.decode(buffer);
		latency=varuint.decode(buffer);
		if(buffer.length>=bool.sizeof){ hasDisplayName=read!(bool, Endian.bigEndian)(buffer); }
		if(hasDisplayName==true){ ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(buffer);if(buffer.length>=ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=buffer[0..ZGlzcGxheU5hbWU.length]; buffer=buffer[ZGlzcGxheU5hbWU.length..$]; }; displayName=cast(string)ZGlzcGxheU5hbWU; }
	}

}

struct ListUpdateGamemode {

	// gamemode
	public enum uint SURVIVAL = 0;
	public enum uint CREATIVE = 1;
	public enum uint ADVENTURE = 2;
	public enum uint SPECTATOR = 3;

	public UUID uuid;
	public uint gamemode;

	public void encode(ref ubyte[] buffer) {
		buffer~=uuid.data;
		buffer~=varuint.encode(gamemode);
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		gamemode=varuint.decode(buffer);
	}

}

struct ListUpdateDisplayName {

	public UUID uuid;
	public bool hasDisplayName;
	public string displayName;

	public void encode(ref ubyte[] buffer) {
		buffer~=uuid.data;
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, hasDisplayName, buffer.length-bool.sizeof);
		if(hasDisplayName==true){ ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint);buffer~=ZGlzcGxheU5hbWU; }
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=16){ ubyte[16] dXVpZA=buffer[0..16]; buffer=buffer[16..$]; uuid=UUID(dXVpZA); }
		if(buffer.length>=bool.sizeof){ hasDisplayName=read!(bool, Endian.bigEndian)(buffer); }
		if(hasDisplayName==true){ ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(buffer);if(buffer.length>=ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=buffer[0..ZGlzcGxheU5hbWU.length]; buffer=buffer[ZGlzcGxheU5hbWU.length..$]; }; displayName=cast(string)ZGlzcGxheU5hbWU; }
	}

}
