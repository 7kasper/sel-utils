/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
module sul.protocol.raknet8.types;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.uuid : UUID;

import sul.utils.var;

struct Address {

	public ubyte type;
	public ubyte[4] ipv4;
	public ubyte[16] ipv6;
	public ushort port;

	public void encode(ref ubyte[] buffer) {
		buffer~=type;
		if(type==4){ buffer~=ipv4; }
		if(type==6){ buffer~=ipv6; }
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, port, buffer.length-ushort.sizeof);
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=ubyte.sizeof){ type=read!(ubyte, Endian.bigEndian)(buffer); }
		if(type==4){ if(buffer.length>=ipv4.length){ ipv4=buffer[0..ipv4.length]; buffer=buffer[ipv4.length..$]; } }
		if(type==6){ if(buffer.length>=ipv6.length){ ipv6=buffer[0..ipv6.length]; buffer=buffer[ipv6.length..$]; } }
		if(buffer.length>=ushort.sizeof){ port=read!(ushort, Endian.bigEndian)(buffer); }
	}

}

struct Acknowledge {

	public bool unique;
	public int first;
	public int last;

	public void encode(ref ubyte[] buffer) {
		buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(buffer, unique, buffer.length-bool.sizeof);
		buffer.length+=3; buffer[$-3]=first&255; buffer[$-2]=(first>>8)&255; buffer[$-1]=(first>>16)&255;
		if(unique==false){ buffer.length+=3; buffer[$-3]=last&255; buffer[$-2]=(last>>8)&255; buffer[$-1]=(last>>16)&255; }
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=bool.sizeof){ unique=read!(bool, Endian.bigEndian)(buffer); }
		if(buffer.length>=3){ first=buffer[0]|(buffer[1]<<8)|(buffer[2]<<16); buffer=buffer[3..$]; }
		if(unique==false){ if(buffer.length>=3){ last=buffer[0]|(buffer[1]<<8)|(buffer[2]<<16); buffer=buffer[3..$]; } }
	}

}

struct Encapsulation {

	public ubyte info;
	public ushort length;
	public int messageIndex;
	public int orderIndex;
	public ubyte orderChannel;
	public types.Split split;
	public ubyte[] payload;

	public void encode(ref ubyte[] buffer) {
		buffer~=info;
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, length, buffer.length-ushort.sizeof);
		if((info&0x7F)>=64){ buffer.length+=3; buffer[$-3]=messageIndex&255; buffer[$-2]=(messageIndex>>8)&255; buffer[$-1]=(messageIndex>>16)&255; }
		if((info&0x7F)>=96){ buffer.length+=3; buffer[$-3]=orderIndex&255; buffer[$-2]=(orderIndex>>8)&255; buffer[$-1]=(orderIndex>>16)&255; }
		if((info&0x7F)>=96){ buffer~=orderChannel; }
		if((info&0x10)!=0){ split.encode(buffer); }
		buffer~=payload;
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=ubyte.sizeof){ info=read!(ubyte, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ length=read!(ushort, Endian.bigEndian)(buffer); }
		if((info&0x7F)>=64){ if(buffer.length>=3){ messageIndex=buffer[0]|(buffer[1]<<8)|(buffer[2]<<16); buffer=buffer[3..$]; } }
		if((info&0x7F)>=96){ if(buffer.length>=3){ orderIndex=buffer[0]|(buffer[1]<<8)|(buffer[2]<<16); buffer=buffer[3..$]; } }
		if((info&0x7F)>=96){ if(buffer.length>=ubyte.sizeof){ orderChannel=read!(ubyte, Endian.bigEndian)(buffer); } }
		if((info&0x10)!=0){ split.decode(buffer); }
		payload=buffer.dup; buffer.length=0;
	}

}

struct Split {

	public uint count;
	public ushort id;
	public uint order;

	public void encode(ref ubyte[] buffer) {
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, count, buffer.length-uint.sizeof);
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, id, buffer.length-ushort.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, order, buffer.length-uint.sizeof);
	}

	public void decode(ref ubyte[] buffer) {
		if(buffer.length>=uint.sizeof){ count=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ id=read!(ushort, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ order=read!(uint, Endian.bigEndian)(buffer); }
	}

}
