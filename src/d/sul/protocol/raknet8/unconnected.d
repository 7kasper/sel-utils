/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
module sul.protocol.raknet8.unconnected;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.raknet8.types;

alias Packets = TypeTuple!(Ping, Pong, OpenConnectionRequest1, OpenConnectionReply1, OpenConnectionRequest2, OpenConnectionReply2);

struct Ping {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public long pingId;
	public ubyte[16] magic;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, pingId, _buffer.length-long.sizeof);
		_buffer~=magic;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+long.sizeof){ pingId=peek!(long, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+magic.length){ magic=_buffer[*_index..*_index+magic.length].dup; *_index+=magic.length; }
		return this;
	}

}

struct Pong {

	public enum ubyte ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long pingId;
	public long serverId;
	public ubyte[16] magic;
	public string status;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, pingId, _buffer.length-long.sizeof);
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, serverId, _buffer.length-long.sizeof);
		_buffer~=magic;
		ubyte[] c3RhdHVz=cast(ubyte[])status; _buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, c3RhdHVz.length.to!ushort, _buffer.length-ushort.sizeof); _buffer~=c3RhdHVz;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+long.sizeof){ pingId=peek!(long, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+long.sizeof){ serverId=peek!(long, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+magic.length){ magic=_buffer[*_index..*_index+magic.length].dup; *_index+=magic.length; }
		ubyte[] c3RhdHVz; if(_buffer.length>=*_index+ushort.sizeof){ c3RhdHVz.length=peek!(ushort, Endian.bigEndian)(_buffer, _index); } if(_buffer.length>=*_index+c3RhdHVz.length){ c3RhdHVz=_buffer[*_index..*_index+c3RhdHVz.length].dup; *_index+=c3RhdHVz.length; }; status=cast(string)c3RhdHVz;
		return this;
	}

}

struct OpenConnectionRequest1 {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte[16] magic;
	public ubyte protocol;
	public ubyte[] mtu;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=magic;
		_buffer~=protocol;
		_buffer~=mtu;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+magic.length){ magic=_buffer[*_index..*_index+magic.length].dup; *_index+=magic.length; }
		if(_buffer.length>=*_index+ubyte.sizeof){ protocol=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		mtu=_buffer[*_index..$].dup; *_index=buffer.length;
		return this;
	}

}

struct OpenConnectionReply1 {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte[16] magic;
	public long serverId;
	public bool security;
	public ushort mtuLength;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=magic;
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, serverId, _buffer.length-long.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, security, _buffer.length-bool.sizeof);
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, mtuLength, _buffer.length-ushort.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+magic.length){ magic=_buffer[*_index..*_index+magic.length].dup; *_index+=magic.length; }
		if(_buffer.length>=*_index+long.sizeof){ serverId=peek!(long, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ security=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ mtuLength=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct OpenConnectionRequest2 {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte[16] magic;
	public sul.protocol.raknet8.types.Address serverAddress;
	public ushort mtuLength;
	public long clientId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=magic;
		serverAddress.encode(_buffer);
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, mtuLength, _buffer.length-ushort.sizeof);
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, clientId, _buffer.length-long.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+magic.length){ magic=_buffer[*_index..*_index+magic.length].dup; *_index+=magic.length; }
		serverAddress.decode(_buffer, _index);
		if(_buffer.length>=*_index+ushort.sizeof){ mtuLength=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+long.sizeof){ clientId=peek!(long, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct OpenConnectionReply2 {

	public enum ubyte ID = 8;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte[16] magic;
	public long serverId;
	public sul.protocol.raknet8.types.Address serverAddress;
	public ushort mtuLength;
	public bool security;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		_buffer~=magic;
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, serverId, _buffer.length-long.sizeof);
		serverAddress.encode(_buffer);
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, mtuLength, _buffer.length-ushort.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, security, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		if(_buffer.length>=*_index+magic.length){ magic=_buffer[*_index..*_index+magic.length].dup; *_index+=magic.length; }
		if(_buffer.length>=*_index+long.sizeof){ serverId=peek!(long, Endian.bigEndian)(_buffer, _index); }
		serverAddress.decode(_buffer, _index);
		if(_buffer.length>=*_index+ushort.sizeof){ mtuLength=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ security=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}
