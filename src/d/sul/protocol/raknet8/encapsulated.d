/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
module sul.protocol.raknet8.encapsulated;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.raknet8.types;

alias Packets = TypeTuple!(ClientConnect, ServerHandshake, ClientHandshake, ClientCancelConnection, Ping, Pong, Mcpe);

struct ClientConnect {

	public enum ubyte ID = 9;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public long clientId;
	public long pingId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, clientId, buffer.length-long.sizeof);
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, pingId, buffer.length-long.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=long.sizeof){ clientId=read!(long, Endian.bigEndian)(buffer); }
		if(buffer.length>=long.sizeof){ pingId=read!(long, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ServerHandshake {

	public enum ubyte ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public types.Address clientAddress;
	public ushort mtuLength;
	public types.Address[10] systemAddresses;
	public long pingId;
	public long serverId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		clientAddress.encode(buffer);
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, mtuLength, buffer.length-ushort.sizeof);
		foreach(c3lzdGVtQWRkcmVz;systemAddresses){ c3lzdGVtQWRkcmVz.encode(buffer); }
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, pingId, buffer.length-long.sizeof);
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, serverId, buffer.length-long.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		clientAddress.decode(buffer);
		if(buffer.length>=ushort.sizeof){ mtuLength=read!(ushort, Endian.bigEndian)(buffer); }
		foreach(ref c3lzdGVtQWRkcmVz;systemAddresses){ c3lzdGVtQWRkcmVz.decode(buffer); }
		if(buffer.length>=long.sizeof){ pingId=read!(long, Endian.bigEndian)(buffer); }
		if(buffer.length>=long.sizeof){ serverId=read!(long, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ClientHandshake {

	public enum ubyte ID = 19;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public types.Address clientAddress;
	public types.Address[10] systemAddresses;
	public long pingId;
	public long clientId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		clientAddress.encode(buffer);
		foreach(c3lzdGVtQWRkcmVz;systemAddresses){ c3lzdGVtQWRkcmVz.encode(buffer); }
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, pingId, buffer.length-long.sizeof);
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, clientId, buffer.length-long.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		clientAddress.decode(buffer);
		foreach(ref c3lzdGVtQWRkcmVz;systemAddresses){ c3lzdGVtQWRkcmVz.decode(buffer); }
		if(buffer.length>=long.sizeof){ pingId=read!(long, Endian.bigEndian)(buffer); }
		if(buffer.length>=long.sizeof){ clientId=read!(long, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct ClientCancelConnection {

	public enum ubyte ID = 21;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		return this;
	}

}

struct Ping {

	public enum ubyte ID = 0;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public long time;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, time, buffer.length-long.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=long.sizeof){ time=read!(long, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Pong {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public long time;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(buffer, time, buffer.length-long.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=long.sizeof){ time=read!(long, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct Mcpe {

	public enum ubyte ID = 254;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public ubyte[] packet;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=packet;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		packet=buffer.dup; buffer.length=0;
		return this;
	}

}
