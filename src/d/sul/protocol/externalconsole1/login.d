/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/externalconsole1.xml
 */
module sul.protocol.externalconsole1.login;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.externalconsole1.types;

alias Packets = TypeTuple!(AuthCredentials, Auth, Welcome);

/**
 * First packet sent by the server after the connection has been successfully established.
 * It contains informations about how the client should authenticate.
 */
class AuthCredentials : Buffer {

	public enum ubyte ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["protocol", "hashAlgorithm", "payload"];

	/**
	 * Protocol used by the server. If the client uses a different one it should close
	 * the connection without trying to perform authentication.
	 */
	public ubyte protocol;

	/**
	 * Algorithm used by the server to match the the hash. The value should be sent in
	 * lowercase without any separation symbol (for example `sha256` instead of `SHA-256`).
	 * If empty no hashing is done and the password is sent raw. See Auth.hash for more
	 * details.
	 */
	public string hashAlgorithm;

	/**
	 * Payload to add to the password encoded as UTF-8 (if hash algorithm is not empty)
	 * before hashing it, as described in the Auth.hash field.
	 */
	public ubyte[16] payload;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte protocol, string hashAlgorithm=string.init, ubyte[16] payload=(ubyte[16]).init) {
		this.protocol = protocol;
		this.hashAlgorithm = hashAlgorithm;
		this.payload = payload;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(protocol);
		writeBigEndianUshort(cast(ushort)hashAlgorithm.length); writeString(hashAlgorithm);
		writeBytes(payload);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		protocol=readBigEndianUbyte();
		ushort agfzaefsz29yaxro=readBigEndianUshort(); hashAlgorithm=readString(agfzaefsz29yaxro);
		if(_buffer.length>=_index+payload.length){ payload=_buffer[_index.._index+payload.length].dup; _index+=payload.length; }
	}

	public static pure nothrow @safe AuthCredentials fromBuffer(bool readId=true)(ubyte[] buffer) {
		AuthCredentials ret = new AuthCredentials();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

class Auth : Buffer {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["hash"];

	public ubyte[] hash;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte[] hash) {
		this.hash = hash;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUshort(cast(ushort)hash.length); writeBytes(hash);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		hash.length=readBigEndianUshort(); if(_buffer.length>=_index+hash.length){ hash=_buffer[_index.._index+hash.length].dup; _index+=hash.length; }
	}

	public static pure nothrow @safe Auth fromBuffer(bool readId=true)(ubyte[] buffer) {
		Auth ret = new Auth();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

class Welcome : Buffer {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["status"];

	public ubyte status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte status) {
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(status);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		status=readBigEndianUbyte();
	}

	public static pure nothrow @safe Welcome fromBuffer(bool readId=true)(ubyte[] buffer) {
		Welcome ret = new Welcome();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	alias _encode = encode;

	public class Accepted {

		public enum typeof(status) STATUS = 0;

		public bool remoteCommands;
		public string software;
		public ubyte[3] versions;
		public string displayName;
		public sul.protocol.externalconsole1.types.Game[] games;
		public string[] connectedNodes;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(bool remoteCommands, string software=string.init, ubyte[3] versions=(ubyte[3]).init, string displayName=string.init, sul.protocol.externalconsole1.types.Game[] games=(sul.protocol.externalconsole1.types.Game[]).init, string[] connectedNodes=(string[]).init) {
			this.remoteCommands = remoteCommands;
			this.software = software;
			this.versions = versions;
			this.displayName = displayName;
			this.games = games;
			this.connectedNodes = connectedNodes;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			status = 0;
			_encode!writeId();
			writeBigEndianBool(remoteCommands);
			writeBigEndianUshort(cast(ushort)software.length); writeString(software);
			writeBytes(versions);
			writeBigEndianUshort(cast(ushort)displayName.length); writeString(displayName);
			writeBigEndianUshort(cast(ushort)games.length); foreach(z2ftzxm;games){ z2ftzxm.encode(bufferInstance); }
			writeBigEndianUshort(cast(ushort)connectedNodes.length); foreach(y29ubmvjdgvktm9k;connectedNodes){ writeBigEndianUshort(cast(ushort)y29ubmvjdgvktm9k.length); writeString(y29ubmvjdgvktm9k); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			remoteCommands=readBigEndianBool();
			ushort c29mdhdhcmu=readBigEndianUshort(); software=readString(c29mdhdhcmu);
			if(_buffer.length>=_index+versions.length){ versions=_buffer[_index.._index+versions.length].dup; _index+=versions.length; }
			ushort zglzcgxheu5hbwu=readBigEndianUshort(); displayName=readString(zglzcgxheu5hbwu);
			games.length=readBigEndianUshort(); foreach(ref z2ftzxm;games){ z2ftzxm.decode(bufferInstance); }
			connectedNodes.length=readBigEndianUshort(); foreach(ref y29ubmvjdgvktm9k;connectedNodes){ ushort eti5dwjtdmpkz3zr=readBigEndianUshort(); y29ubmvjdgvktm9k=readString(eti5dwjtdmpkz3zr); }
		}

	}

		/**
		 * Sent when Auth is received but the given password or hash doesn't match the server's
		 * one.
		 */
	public class WrongHash {

		public enum typeof(status) STATUS = 1;

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			status = 1;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

	}

		/**
		 * Sent when Auth is not received and the server decides to close the connection because
		 * too much time has elapsed since the creation of the socket.
		 */
	public class TimedOut {

		public enum typeof(status) STATUS = 2;

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			status = 2;
			_encode!writeId();
			return _buffer;
		}

		public pure nothrow @safe void decode() {
		}

	}

}
