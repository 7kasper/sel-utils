/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/externalconsole1.xml
 */
module sul.protocol.externalconsole1.connected;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.externalconsole1.types;

alias Packets = TypeTuple!(ConsoleMessage, Command, PermissionDenied);

/**
 * Logs a message from the server's console. It may be the output of a command, a debug
 * message or any other message that the server retains able to be seen by the External
 * Console.
 */
class ConsoleMessage : Buffer {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["node", "timestamp", "logger", "message"];

	/**
	 * Name of the node that created the log or an empty string if the log was created
	 * by the hub or by a server implementation that isn't based on the hub-node structure.
	 */
	public string node;

	/**
	 * Unix timestamp in milliseconds that indicates the exact time when the log has been
	 * generated by the server.
	 * The logs may not arrive in order when the server uses the hub-node structure or
	 * another kind of proxy because the logs created by the nodes have to travel a longer
	 * distance, which requires more time.
	 */
	public ulong timestamp;

	/**
	 * Name of the logger. It may be the world name if the log has been generated by a
	 * world's message (like a broadcast or a chat message), the name of plugin (for example
	 * `plugin\test`) or the name of the package/module/class that has generated the log
	 * (like `math.vector` or `event.world.player`).
	 */
	public string logger;

	/**
	 * The logged message. It may contain Minecraft's formatting codes which should be
	 * translated into appropriate colours and formatting by the client implementation
	 * of the console.
	 */
	public string message;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string node, ulong timestamp=ulong.init, string logger=string.init, string message=string.init) {
		this.node = node;
		this.timestamp = timestamp;
		this.logger = logger;
		this.message = message;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUshort(cast(ushort)node.length); writeString(node);
		writeBigEndianUlong(timestamp);
		writeBigEndianUshort(cast(ushort)logger.length); writeString(logger);
		writeBigEndianUshort(cast(ushort)message.length); writeString(message);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		ushort bm9kzq=readBigEndianUshort(); node=readString(bm9kzq);
		timestamp=readBigEndianUlong();
		ushort bg9nz2vy=readBigEndianUshort(); logger=readString(bg9nz2vy);
		ushort bwvzc2fnzq=readBigEndianUshort(); message=readString(bwvzc2fnzq);
	}

	public static pure nothrow @safe ConsoleMessage fromBuffer(bool readId=true)(ubyte[] buffer) {
		ConsoleMessage ret = new ConsoleMessage();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

/**
 * Executes a command remotely if the server allows it. If not a [Permission Denied](#connected.permission-denied)
 * is sent back. The ideal client should never send this packet if [remoteCommands](#login.welcome.accepted.remote-commands)
 * field in [Welcome.Accepted](#login.welcome.accepted) is not true.
 */
class Command : Buffer {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["command"];

	/**
	 * Command to execute on the server. On servers that based on the hub-node structure
	 * it should start with a slash or a point (hub command) or a node name followed by
	 * the command (node command).
	 */
	public string command;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string command) {
		this.command = command;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUshort(cast(ushort)command.length); writeString(command);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		ushort y29tbwfuza=readBigEndianUshort(); command=readString(y29tbwfuza);
	}

	public static pure nothrow @safe Command fromBuffer(bool readId=true)(ubyte[] buffer) {
		Command ret = new Command();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

/**
 * Bodyless packet only sent in response to [Command](#connected.command) when the
 * server doesn't allow the execution of remote commands through the External Console.
 * A well-implemented client should never receive this packet avoiding the use of [Command](#connected.command)
 * if the [remoteCommands](#login.welcome.accepted.remote-command) field is false.
 */
class PermissionDenied : Buffer {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
	}

	public static pure nothrow @safe PermissionDenied fromBuffer(bool readId=true)(ubyte[] buffer) {
		PermissionDenied ret = new PermissionDenied();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}
