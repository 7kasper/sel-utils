/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/externalconsole1.xml
 */
/**
 * Packets about the informations and the usage of the server.
 */
module sul.protocol.externalconsole1.status;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.externalconsole1.types;

alias Packets = TypeTuple!(KeepAlive, UpdateNodes, RequestStats, UpdateStats);

/**
 * Keeps the connection alive and/or calculates the latency. This packet should be
 * sent at least every 5 seconds to avoid the disconnection caused by timeout and update
 * the latency. The external console can send this packet whenever it wants it and
 * the server must reply with the same packet with the same field's value.
 */
class KeepAlive : Buffer {

	public enum ubyte ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["count"];

	/**
	 * An identifier chosen by the external console to uniquely identify the packet.
	 */
	public uint count;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint count) {
		this.count = count;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(count);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		count=readBigEndianUint();
	}

	public static pure nothrow @safe KeepAlive fromBuffer(bool readId=true)(ubyte[] buffer) {
		KeepAlive ret = new KeepAlive();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

/**
 * Updates the list of the nodes connected to the hub, adding or removing one.
 * If the server isn't built on the hub-node layout this packet is never sent.
 */
class UpdateNodes : Buffer {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public enum string[] FIELDS = ["action", "node"];

	/**
	 * Whether the node should be added or removed from the list of connected nodes.
	 */
	public ubyte action;

	/**
	 * Name of the node.
	 */
	public string node;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, string node=string.init) {
		this.action = action;
		this.node = node;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		writeBigEndianUshort(cast(ushort)node.length); writeString(node);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
		ushort bm9kzq=readBigEndianUshort(); node=readString(bm9kzq);
	}

	public static pure nothrow @safe UpdateNodes fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateNodes ret = new UpdateNodes();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

/**
 * Requests an UpdateStats packet to the server, which should sent it immediately instead
 * of waiting for the next automatic update (if the server does one).
 */
class RequestStats : Buffer {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
	}

	public static pure nothrow @safe RequestStats fromBuffer(bool readId=true)(ubyte[] buffer) {
		RequestStats ret = new RequestStats();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}

/**
 * Updates the statistics about the usage of the server and, eventually, the connected
 * nodes.
 * This packet is sent in response to RequestStats and every time the server retains
 * that the stats should be updated (usually in a range of 5 to 30 seconds).
 */
class UpdateStats : Buffer {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["onlinePlayers", "maxPlayers", "uptime", "upload", "download", "nodes"];

	/**
	 * Number of players currently online on the server. Players that are performing authentication
	 * are not included in the count.
	 */
	public uint onlinePlayers;

	/**
	 * Highest number of players that can join the server simultaneously. If 0, there is
	 * not maximum number of players.
	 */
	public uint maxPlayers;

	/**
	 * Milliseconds since the server has started.
	 */
	public uint uptime;

	/**
	 * Average amount of bytes sent every second.
	 */
	public uint upload;

	/**
	 * Average amount of bytes sent every second.
	 */
	public uint download;

	/**
	 * Resources usage of the connected nodes, if the server uses the hub-node layout,
	 * or an empty list.
	 */
	public sul.protocol.externalconsole1.types.NodeStats[] nodes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint onlinePlayers, uint maxPlayers=uint.init, uint uptime=uint.init, uint upload=uint.init, uint download=uint.init, sul.protocol.externalconsole1.types.NodeStats[] nodes=(sul.protocol.externalconsole1.types.NodeStats[]).init) {
		this.onlinePlayers = onlinePlayers;
		this.maxPlayers = maxPlayers;
		this.uptime = uptime;
		this.upload = upload;
		this.download = download;
		this.nodes = nodes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(onlinePlayers);
		writeBigEndianUint(maxPlayers);
		writeBigEndianUint(uptime);
		writeBigEndianUint(upload);
		writeBigEndianUint(download);
		writeBigEndianUshort(cast(ushort)nodes.length); foreach(bm9kzxm;nodes){ bm9kzxm.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		onlinePlayers=readBigEndianUint();
		maxPlayers=readBigEndianUint();
		uptime=readBigEndianUint();
		upload=readBigEndianUint();
		download=readBigEndianUint();
		nodes.length=readBigEndianUshort(); foreach(ref bm9kzxm;nodes){ bm9kzxm.decode(bufferInstance); }
	}

	public static pure nothrow @safe UpdateStats fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateStats ret = new UpdateStats();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

}
