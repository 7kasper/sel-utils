/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/externalconsole1.xml
 */
module sul.protocol.externalconsole1.status;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.externalconsole1.types;

alias Packets = TypeTuple!(KeepAlive, UpdateNodes, UpdateStats);

struct KeepAlive {

	public enum ubyte ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public uint count;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, count, buffer.length-uint.sizeof);
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=uint.sizeof){ count=read!(uint, Endian.bigEndian)(buffer); }
		return this;
	}

}

struct UpdateNodes {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public ubyte action;
	public string node;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer~=action;
		ubyte[] bm9kZQ=cast(ubyte[])node; buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, bm9kZQ.length.to!ushort, buffer.length-ushort.sizeof);buffer~=bm9kZQ;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=ubyte.sizeof){ action=read!(ubyte, Endian.bigEndian)(buffer); }
		ubyte[] bm9kZQ; if(buffer.length>=ushort.sizeof){ bm9kZQ.length=read!(ushort, Endian.bigEndian)(buffer); }if(buffer.length>=bm9kZQ.length){ bm9kZQ=buffer[0..bm9kZQ.length]; buffer=buffer[bm9kZQ.length..$]; }; node=cast(string)bm9kZQ;
		return this;
	}

}

struct UpdateStats {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint onlinePlayers;
	public uint maxPlayers;
	public uint uptime;
	public uint upload;
	public uint download;
	public types.NodeStats[] nodes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, onlinePlayers, buffer.length-uint.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, maxPlayers, buffer.length-uint.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, uptime, buffer.length-uint.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, upload, buffer.length-uint.sizeof);
		buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(buffer, download, buffer.length-uint.sizeof);
		buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, nodes.length.to!ushort, buffer.length-ushort.sizeof);foreach(bm9kZXM;nodes){ bm9kZXM.encode(buffer); }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		if(buffer.length>=uint.sizeof){ onlinePlayers=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ maxPlayers=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ uptime=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ upload=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=uint.sizeof){ download=read!(uint, Endian.bigEndian)(buffer); }
		if(buffer.length>=ushort.sizeof){ nodes.length=read!(ushort, Endian.bigEndian)(buffer); }foreach(ref bm9kZXM;nodes){ bm9kZXM.decode(buffer); }
		return this;
	}

}
