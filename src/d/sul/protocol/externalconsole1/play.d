/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/externalconsole1.xml
 */
module sul.protocol.externalconsole1.play;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.externalconsole1.types;

alias Packets = TypeTuple!(ConsoleMessage, Command, PermissionDenied);

/**
 * Logs a message from the server's console. It may be a result of a command, a debug
 * message or any other message that the server retains able to be seen by the External
 * Console.
 */
struct ConsoleMessage {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	/**
	 * Name of the node that has created the log or an empty string if the log has been
	 * created by the hub or by a server implementation that isn't based on the hub-node
	 * structure.
	 */
	public string node;

	/**
	 * Unix timestamp in milliseconds that indicates the exact time when the log has been
	 * generated by the server.
	 */
	public ulong timestamp;

	/**
	 * Name of the logger. It is the world name if the log has been generated by a world's
	 * message (like a broadcast or a chat message).
	 */
	public string logger;

	/**
	 * The logged message. It may contain Minecraft's formatting codes which should be
	 * translated into appropriate colours by the client-side implementation.
	 */
	public string message;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		ubyte[] bm9kZQ=cast(ubyte[])node; _buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, bm9kZQ.length.to!ushort, _buffer.length-ushort.sizeof);_buffer~=bm9kZQ;
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, timestamp, _buffer.length-ulong.sizeof);
		ubyte[] bG9nZ2Vy=cast(ubyte[])logger; _buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, bG9nZ2Vy.length.to!ushort, _buffer.length-ushort.sizeof);_buffer~=bG9nZ2Vy;
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, bWVzc2FnZQ.length.to!ushort, _buffer.length-ushort.sizeof);_buffer~=bWVzc2FnZQ;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		ubyte[] bm9kZQ; if(_buffer.length>=*_index+ushort.sizeof){ bm9kZQ.length=peek!(ushort, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+bm9kZQ.length){ bm9kZQ=_buffer[*_index..*_index+bm9kZQ.length].dup; *_index+=bm9kZQ.length; }; node=cast(string)bm9kZQ;
		if(_buffer.length>=*_index+ulong.sizeof){ timestamp=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		ubyte[] bG9nZ2Vy; if(_buffer.length>=*_index+ushort.sizeof){ bG9nZ2Vy.length=peek!(ushort, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+bG9nZ2Vy.length){ bG9nZ2Vy=_buffer[*_index..*_index+bG9nZ2Vy.length].dup; *_index+=bG9nZ2Vy.length; }; logger=cast(string)bG9nZ2Vy;
		ubyte[] bWVzc2FnZQ; if(_buffer.length>=*_index+ushort.sizeof){ bWVzc2FnZQ.length=peek!(ushort, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
		return this;
	}

}

/**
 * Executes a command remotely if the server allows it. If not a Permission Denied
 * is sent back. The ideal client should never send this packet if remoteCommands field
 * in Welcome.Accepted is not true.
 */
struct Command {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	/**
	 * Command to be executed on the server. On SEL servers it should start with a slash
	 * or a point (hub command) or a node name followed by the command (node command).
	 */
	public string command;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		ubyte[] Y29tbWFuZA=cast(ubyte[])command; _buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, Y29tbWFuZA.length.to!ushort, _buffer.length-ushort.sizeof);_buffer~=Y29tbWFuZA;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		ubyte[] Y29tbWFuZA; if(_buffer.length>=*_index+ushort.sizeof){ Y29tbWFuZA.length=peek!(ushort, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+Y29tbWFuZA.length){ Y29tbWFuZA=_buffer[*_index..*_index+Y29tbWFuZA.length].dup; *_index+=Y29tbWFuZA.length; }; command=cast(string)Y29tbWFuZA;
		return this;
	}

}

/**
 * Bodyless packet only sent in response to Command when the server doesn't allow the
 * execution of remote commands through the External Console protocol. The ideal client
 * should never receive this packet avoiding the use of Command if the remoteCommands
 * field in Welcome.Accepted is not true.
 */
struct PermissionDenied {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=ID; }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; if(_buffer.length>=*_index+ubyte.sizeof){ _id=peek!(ubyte, Endian.bigEndian)(_buffer, _index); } }
		return this;
	}

}
