/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/externalconsole1.xml
 */
module sul.protocol.externalconsole1.play;

import std.bitmanip : write, read;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.externalconsole1.types;

alias Packets = TypeTuple!(ConsoleMessage, Command, PermissionDenied);

/**
 * Logs a message from the server's console. It may be a result of a command, a debug
 * message or any other message that the server retains able to be seen by the External
 * Console.
 */
struct ConsoleMessage {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	/**
	 * Name of the node that has created the log or an empty string if the log has been
	 * created by the hub or by a server implementation that isn't based on the hub-node
	 * structure.
	 */
	public string node;

	/**
	 * Unix timestamp in milliseconds that indicates the exact time when the log has been
	 * generated by the server.
	 */
	public ulong timestamp;

	/**
	 * Name of the logger. It is the world name if the log has been generated by a world's
	 * message (like a broadcast or a chat message).
	 */
	public string logger;

	/**
	 * The logged message. It may contain Minecraft's formatting codes which should be
	 * translated into appropriate colours by the client-side implementation.
	 */
	public string message;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		ubyte[] bm9kZQ=cast(ubyte[])node; buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, bm9kZQ.length.to!ushort, buffer.length-ushort.sizeof);buffer~=bm9kZQ;
		buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(buffer, timestamp, buffer.length-ulong.sizeof);
		ubyte[] bG9nZ2Vy=cast(ubyte[])logger; buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, bG9nZ2Vy.length.to!ushort, buffer.length-ushort.sizeof);buffer~=bG9nZ2Vy;
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, bWVzc2FnZQ.length.to!ushort, buffer.length-ushort.sizeof);buffer~=bWVzc2FnZQ;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		ubyte[] bm9kZQ; if(buffer.length>=ushort.sizeof){ bm9kZQ.length=read!(ushort, Endian.bigEndian)(buffer); }if(buffer.length>=bm9kZQ.length){ bm9kZQ=buffer[0..bm9kZQ.length]; buffer=buffer[bm9kZQ.length..$]; }; node=cast(string)bm9kZQ;
		if(buffer.length>=ulong.sizeof){ timestamp=read!(ulong, Endian.bigEndian)(buffer); }
		ubyte[] bG9nZ2Vy; if(buffer.length>=ushort.sizeof){ bG9nZ2Vy.length=read!(ushort, Endian.bigEndian)(buffer); }if(buffer.length>=bG9nZ2Vy.length){ bG9nZ2Vy=buffer[0..bG9nZ2Vy.length]; buffer=buffer[bG9nZ2Vy.length..$]; }; logger=cast(string)bG9nZ2Vy;
		ubyte[] bWVzc2FnZQ; if(buffer.length>=ushort.sizeof){ bWVzc2FnZQ.length=read!(ushort, Endian.bigEndian)(buffer); }if(buffer.length>=bWVzc2FnZQ.length){ bWVzc2FnZQ=buffer[0..bWVzc2FnZQ.length]; buffer=buffer[bWVzc2FnZQ.length..$]; }; message=cast(string)bWVzc2FnZQ;
		return this;
	}

}

/**
 * Executes a command remotely if the server allows it. If not a Permission Denied
 * is sent back. The ideal client should never send this packet if remoteCommands field
 * in Welcome.Accepted is not true.
 */
struct Command {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	/**
	 * Command to be executed on the server. On SEL servers it should start with a slash
	 * or a point (hub command) or a node name followed by the command (node command).
	 */
	public string command;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		ubyte[] Y29tbWFuZA=cast(ubyte[])command; buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(buffer, Y29tbWFuZA.length.to!ushort, buffer.length-ushort.sizeof);buffer~=Y29tbWFuZA;
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		ubyte[] Y29tbWFuZA; if(buffer.length>=ushort.sizeof){ Y29tbWFuZA.length=read!(ushort, Endian.bigEndian)(buffer); }if(buffer.length>=Y29tbWFuZA.length){ Y29tbWFuZA=buffer[0..Y29tbWFuZA.length]; buffer=buffer[Y29tbWFuZA.length..$]; }; command=cast(string)Y29tbWFuZA;
		return this;
	}

}

/**
 * Bodyless packet only sent in response to Command when the server doesn't allow the
 * execution of remote commands through the External Console protocol. The ideal client
 * should never receive this packet avoiding the use of Command if the remoteCommands
 * field in Welcome.Accepted is not true.
 */
struct PermissionDenied {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] buffer;
		static if(writeId){ buffer~=ID; }
		return buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] buffer) {
		static if(readId){ typeof(ID) _id; if(buffer.length>=ubyte.sizeof){ _id=read!(ubyte, Endian.bigEndian)(buffer); } }
		return this;
	}

}
