/*
 * This file has been automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generator: https://github.com/sel-project/sel-utils/blob/master/xml/protocol/minecraft107.xml
 */
module sul.protocol.minecraft107.clientbound;

import std.bitmanip : write, peek;
import std.conv : to;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.var;

import types = sul.protocol.minecraft107.types;

alias Packets = TypeTuple!(SpawnObject, SpawnExperienceOrb, SpawnGlobalEntity, SpawnMob, SpawnPainting, SpawnPlayer, Animation, Statistics, BlockBreakAnimation, UpdateBlockEntity, BlockAction, BlockChange, BossBar, ServerDifficulty, TabComplete, ChatMessage, MultiBlockChange, ConfirmTransaction, CloseWindow, OpenWindow, WindowItems, WindowProperty, SetSlot, SetCooldown, PluginMessage, NamedSoundEffect, Disconnect, EntityStatus, Explosion, UnloadChunk, ChangeGameState, KeepAlive, ChunkData, Effect, Particle, JoinGame, Map, EntityRelativeMove, EntityLookAndRelativeMove, EntityLook, Entity, VehicleMove, OpenSignEditor, PlayerAbilities, CombatEvent, PlayerListItem, PlayerPositionAndLook, UseBed, DestroyEntities, RemoveEntityEffect, ResourcePackSend, Respawn, EntityHeadLook, WorldBorder, Camera, HeldItemChange, DisplayScoreboard, EntityMetadata, AttachEntity, EntityVelocity, EntityEquipment, SetExperience, UpdateHealth, ScoreboardObjective, SetPassengers, Teams, UpdateScore, SpawnPosition, TimeUpdate, Title, UpdateSign, SoundEffect, PlayerListHeaderAndFooter, CollectItem, EntityTeleport, EntityProperties, EntityEffect);

struct SpawnObject {

	public enum uint ID = 0;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte pitch;
	public ubyte yaw;
	public int data;
	public Tuple!(short, "x", short, "y", short, "z") velocity;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=uuid.data;
		_buffer~=type;
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer~=pitch;
		_buffer~=yaw;
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, data, _buffer.length-int.sizeof);
		_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.x, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.y, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.z, _buffer.length-short.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		if(_buffer.length>=*_index+ubyte.sizeof){ type=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ yaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+int.sizeof){ data=peek!(int, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+short.sizeof){ velocity.x=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ velocity.y=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ velocity.z=peek!(short, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SpawnExperienceOrb {

	public enum uint ID = 1;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ushort count;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, count, _buffer.length-ushort.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ count=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SpawnGlobalEntity {

	public enum uint ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// type
	public enum ubyte THUNDERBOLT = 1;

	public uint entityId;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=type;
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ type=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SpawnMob {

	public enum uint ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public ubyte type;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public ubyte headPitch;
	public Tuple!(short, "x", short, "y", short, "z") velocity;
	public sul.protocol.minecraft107.types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=uuid.data;
		_buffer~=type;
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer~=yaw;
		_buffer~=pitch;
		_buffer~=headPitch;
		_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.x, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.y, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.z, _buffer.length-short.sizeof);
		metadata.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		if(_buffer.length>=*_index+ubyte.sizeof){ type=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ yaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ headPitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+short.sizeof){ velocity.x=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ velocity.y=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ velocity.z=peek!(short, Endian.bigEndian)(_buffer, _index); }
		metadata.decode(_buffer, _index);
		return this;
	}

}

struct SpawnPainting {

	public enum uint ID = 4;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// direction
	public enum ubyte NORTH = 0;
	public enum ubyte WEST = 1;
	public enum ubyte SOUTH = 2;
	public enum ubyte EAST = 3;

	public uint entityId;
	public UUID uuid;
	public string title;
	public ulong position;
	public ubyte direction;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=uuid.data;
		ubyte[] dGl0bGU=cast(ubyte[])title; _buffer~=varuint.encode(dGl0bGU.length.to!uint); _buffer~=dGl0bGU;
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		_buffer~=direction;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dGl0bGU.length){ dGl0bGU=_buffer[*_index..*_index+dGl0bGU.length].dup; *_index+=dGl0bGU.length; }; title=cast(string)dGl0bGU;
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ direction=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SpawnPlayer {

	public enum uint ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public UUID uuid;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public sul.protocol.minecraft107.types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=uuid.data;
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer~=yaw;
		_buffer~=pitch;
		metadata.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ yaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		metadata.decode(_buffer, _index);
		return this;
	}

}

struct Animation {

	public enum uint ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// animation
	public enum ubyte SWING_ARM = 0;
	public enum ubyte TAKE_DAMAGE = 1;
	public enum ubyte LEAVE_BED = 2;
	public enum ubyte EAT_FOOD = 3;
	public enum ubyte CRITICAL_EFFECT = 4;
	public enum ubyte MAGICAL_CRITICAL_EFFECT = 5;

	public uint entityId;
	public ubyte animation;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=animation;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ animation=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Statistics {

	public enum uint ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public sul.protocol.minecraft107.types.Statistic[] statistics;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(statistics.length.to!uint); foreach(c3RhdGlzdGljcw;statistics){ c3RhdGlzdGljcw.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		statistics.length=varuint.decode(_buffer, *_index); foreach(ref c3RhdGlzdGljcw;statistics){ c3RhdGlzdGljcw.decode(_buffer, _index); }
		return this;
	}

}

struct BlockBreakAnimation {

	public enum uint ID = 8;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ulong position;
	public ubyte stage;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		_buffer~=stage;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ stage=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct UpdateBlockEntity {

	public enum uint ID = 9;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte MOB_SPAWNER_DATA = 1;
	public enum ubyte COMMAND_BLOCK_TEXT = 2;
	public enum ubyte BEACON_POWERS = 3;
	public enum ubyte MOB_HEAD_DATA = 4;
	public enum ubyte FLOWER_POT_FLOWER = 5;
	public enum ubyte BANNER_DATA = 6;

	public ulong position;
	public ubyte action;
	public ubyte[] nbt;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		_buffer~=action;
		_buffer~=nbt;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		nbt=_buffer[*_index..$].dup; *_index=buffer.length;
		return this;
	}

}

struct BlockAction {

	public enum uint ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte NOTE_BLOCK_HARP = 0;
	public enum ubyte NOTE_BLOCK_BASS_DRUM = 1;
	public enum ubyte NOTE_BLOCK_SNARE_DRUM = 2;
	public enum ubyte NOTE_BLOCK_CLICKS = 3;
	public enum ubyte NOTE_BLOCK_STICKS = 3;
	public enum ubyte NOTE_BLOCK_BASS_GUITAR = 4;
	public enum ubyte PISTON_EXTEND = 0;
	public enum ubyte PISTON_RETRACT = 1;
	public enum ubyte CHEST_WATCHERS = 1;
	public enum ubyte BEACON_RECALCULATE = 1;
	public enum ubyte MOB_SPAWNER_RESET_DELAY = 1;
	public enum ubyte END_GATEWAY_YELLOW_BEAM = 1;

	// parameter
	public enum ubyte PISTON_DOWN = 0;
	public enum ubyte PISTON_UP = 1;
	public enum ubyte PISTON_SOUTH = 2;
	public enum ubyte PISTON_WEST = 3;
	public enum ubyte PISTON_NORTH = 4;
	public enum ubyte PISTON_EAST = 5;

	public ulong position;
	public ubyte action;
	public ubyte parameter;
	public uint blockType;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		_buffer~=action;
		_buffer~=parameter;
		_buffer~=varuint.encode(blockType);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ parameter=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		blockType=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct BlockChange {

	public enum uint ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;
	public uint block;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		_buffer~=varuint.encode(block);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		block=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct BossBar {

	public enum uint ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public UUID uuid;
	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=uuid.data;
		_buffer~=varuint.encode(action);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+16){ ubyte[16] dXVpZA=buffer[*_index..*_index+16].dup; *_index+=16; uuid=UUID(dXVpZA); }
		action=varuint.decode(_buffer, *_index);
		return this;
	}

	public struct Add {

		public enum typeof(action) ACTION = 0;

		// color
		public enum uint PINK = 0;
		public enum uint BLUE = 1;
		public enum uint RED = 2;
		public enum uint GREEN = 3;
		public enum uint YELLOW = 4;
		public enum uint PURPLE = 5;
		public enum uint WHITE = 6;

		// division
		public enum uint NO_DIVISION = 0;
		public enum uint SIX_NOTCHES = 1;
		public enum uint TEN_NOTCHES = 2;
		public enum uint TWELVE_NOTCHES = 3;
		public enum uint TWENTY_NOTCHES = 4;

		// flags
		public enum ubyte DARK_SKY = 1;
		public enum ubyte IS_DRAGON_BAR = 2;

		public string title;
		public float health;
		public uint color;
		public uint division;
		public ubyte flags;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] dGl0bGU=cast(ubyte[])title; _buffer~=varuint.encode(dGl0bGU.length.to!uint); _buffer~=dGl0bGU;
			_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, health, _buffer.length-float.sizeof);
			_buffer~=varuint.encode(color);
			_buffer~=varuint.encode(division);
			_buffer~=flags;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dGl0bGU.length){ dGl0bGU=_buffer[*_index..*_index+dGl0bGU.length].dup; *_index+=dGl0bGU.length; }; title=cast(string)dGl0bGU;
			if(_buffer.length>=*_index+float.sizeof){ health=peek!(float, Endian.bigEndian)(_buffer, _index); }
			color=varuint.decode(_buffer, *_index);
			division=varuint.decode(_buffer, *_index);
			if(_buffer.length>=*_index+ubyte.sizeof){ flags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct Remove {

		public enum typeof(action) ACTION = 1;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			return this;
		}

	}

	public struct UpdateHealth {

		public enum typeof(action) ACTION = 2;

		public float health;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, health, _buffer.length-float.sizeof);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+float.sizeof){ health=peek!(float, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct UpdateTitle {

		public enum typeof(action) ACTION = 3;

		public string title;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] dGl0bGU=cast(ubyte[])title; _buffer~=varuint.encode(dGl0bGU.length.to!uint); _buffer~=dGl0bGU;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dGl0bGU.length){ dGl0bGU=_buffer[*_index..*_index+dGl0bGU.length].dup; *_index+=dGl0bGU.length; }; title=cast(string)dGl0bGU;
			return this;
		}

	}

	public struct UpdateStyle {

		public enum typeof(action) ACTION = 4;

		// color
		public enum uint PINK = 0;
		public enum uint BLUE = 1;
		public enum uint RED = 2;
		public enum uint GREEN = 3;
		public enum uint YELLOW = 4;
		public enum uint PURPLE = 5;
		public enum uint WHITE = 6;

		// division
		public enum uint NO_DIVISION = 0;
		public enum uint SIX_NOTCHES = 1;
		public enum uint TEN_NOTCHES = 2;
		public enum uint TWELVE_NOTCHES = 3;
		public enum uint TWENTY_NOTCHES = 4;

		public uint color;
		public uint division;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(color);
			_buffer~=varuint.encode(division);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			color=varuint.decode(_buffer, *_index);
			division=varuint.decode(_buffer, *_index);
			return this;
		}

	}

	public struct UpdateFlags {

		public enum typeof(action) ACTION = 5;

		// flags
		public enum ubyte DARK_SKY = 1;
		public enum ubyte IS_DRAGON_BAR = 2;

		public ubyte flags;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=flags;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+ubyte.sizeof){ flags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

}

struct ServerDifficulty {

	public enum uint ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	public ubyte difficulty;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=difficulty;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ difficulty=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct TabComplete {

	public enum uint ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string[] matches;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(matches.length.to!uint); foreach(bWF0Y2hlcw;matches){ ubyte[] YldGMFkyaGxjdw=cast(ubyte[])bWF0Y2hlcw; _buffer~=varuint.encode(YldGMFkyaGxjdw.length.to!uint); _buffer~=YldGMFkyaGxjdw; }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		matches.length=varuint.decode(_buffer, *_index); foreach(ref bWF0Y2hlcw;matches){ ubyte[] YldGMFkyaGxjdw; YldGMFkyaGxjdw.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+YldGMFkyaGxjdw.length){ YldGMFkyaGxjdw=_buffer[*_index..*_index+YldGMFkyaGxjdw.length].dup; *_index+=YldGMFkyaGxjdw.length; }; bWF0Y2hlcw=cast(string)YldGMFkyaGxjdw; }
		return this;
	}

}

struct ChatMessage {

	public enum uint ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// position
	public enum ubyte CHAT = 0;
	public enum ubyte SYSTEM_MESSAGE = 1;
	public enum ubyte ABOVE_HOTBAR = 2;

	public string message;
	public ubyte position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint); _buffer~=bWVzc2FnZQ;
		_buffer~=position;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
		if(_buffer.length>=*_index+ubyte.sizeof){ position=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct MultiBlockChange {

	public enum uint ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") chunk;
	public sul.protocol.minecraft107.types.BlockChange[] changes;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, chunk.x, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, chunk.z, _buffer.length-int.sizeof);
		_buffer~=varuint.encode(changes.length.to!uint); foreach(Y2hhbmdlcw;changes){ Y2hhbmdlcw.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+int.sizeof){ chunk.x=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ chunk.z=peek!(int, Endian.bigEndian)(_buffer, _index); }
		changes.length=varuint.decode(_buffer, *_index); foreach(ref Y2hhbmdlcw;changes){ Y2hhbmdlcw.decode(_buffer, _index); }
		return this;
	}

}

struct ConfirmTransaction {

	public enum uint ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ushort action;
	public bool accepted;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=window;
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, action, _buffer.length-ushort.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, accepted, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ action=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ accepted=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct CloseWindow {

	public enum uint ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=window;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct OpenWindow {

	public enum uint ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public string type;
	public string title;
	public ubyte slots;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=window;
		ubyte[] dHlwZQ=cast(ubyte[])type; _buffer~=varuint.encode(dHlwZQ.length.to!uint); _buffer~=dHlwZQ;
		ubyte[] dGl0bGU=cast(ubyte[])title; _buffer~=varuint.encode(dGl0bGU.length.to!uint); _buffer~=dGl0bGU;
		_buffer~=slots;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		ubyte[] dHlwZQ; dHlwZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dHlwZQ.length){ dHlwZQ=_buffer[*_index..*_index+dHlwZQ.length].dup; *_index+=dHlwZQ.length; }; type=cast(string)dHlwZQ;
		ubyte[] dGl0bGU; dGl0bGU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dGl0bGU.length){ dGl0bGU=_buffer[*_index..*_index+dGl0bGU.length].dup; *_index+=dGl0bGU.length; }; title=cast(string)dGl0bGU;
		if(_buffer.length>=*_index+ubyte.sizeof){ slots=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct WindowItems {

	public enum uint ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public sul.protocol.minecraft107.types.Slot[] slots;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=window;
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, slots.length.to!ushort, _buffer.length-ushort.sizeof); foreach(c2xvdHM;slots){ c2xvdHM.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ slots.length=peek!(ushort, Endian.bigEndian)(_buffer, _index); } foreach(ref c2xvdHM;slots){ c2xvdHM.decode(_buffer, _index); }
		return this;
	}

}

struct WindowProperty {

	public enum uint ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// property
	public enum ushort FURNANCE_FIRE_ICON = 0;
	public enum ushort FURNACE_MAX_FUEL_BURN_TIME = 1;
	public enum ushort FURNACE_PROGRESS_ARROW = 2;
	public enum ushort FURNCE_MAX_PROGRESS = 3;
	public enum ushort ENCHANTMENT_LEVEL_REQUIREMENT_TOP = 0;
	public enum ushort ENCHANTMENT_LEVEL_REQUIREMENT_MIDDLE = 1;
	public enum ushort ENCHANTMENT_LEVEL_REQUIREMENT_BOTTOM = 2;
	public enum ushort ENCHANTMENT_SEED = 3;
	public enum ushort ENCHANTMENT_ID_TOP = 4;
	public enum ushort ENCHANTMENT_ID_MIDDLE = 5;
	public enum ushort ENCHANTMENT_ID_BOTTOM = 6;
	public enum ushort ENCHANTMENT_LEVEL_TOP = 7;
	public enum ushort ENCHANTMENT_LEVEL_MIDDLE = 8;
	public enum ushort ENCHANTMENT_LEVEL_BOTTOM = 9;
	public enum ushort BEACON_POWER_LEVEL = 0;
	public enum ushort BEACON_FIRST_EFFECT = 1;
	public enum ushort BEACON_SECOND_EFFECT = 2;
	public enum ushort ANVIL_REPAIR_COST = 0;
	public enum ushort BREWING_STAND_BREW_TIME = 0;

	public ubyte window;
	public ushort property;
	public short value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=window;
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, property, _buffer.length-ushort.sizeof);
		_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, value, _buffer.length-short.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ property=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+short.sizeof){ value=peek!(short, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct SetSlot {

	public enum uint ID = 22;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte window;
	public ushort slot;
	public sul.protocol.minecraft107.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=window;
		_buffer.length+=ushort.sizeof; write!(ushort, Endian.bigEndian)(_buffer, slot, _buffer.length-ushort.sizeof);
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ window=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ushort.sizeof){ slot=peek!(ushort, Endian.bigEndian)(_buffer, _index); }
		item.decode(_buffer, _index);
		return this;
	}

}

struct SetCooldown {

	public enum uint ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint item;
	public uint cooldown;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(item);
		_buffer~=varuint.encode(cooldown);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		item=varuint.decode(_buffer, *_index);
		cooldown=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct PluginMessage {

	public enum uint ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string channel;
	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] Y2hhbm5lbA=cast(ubyte[])channel; _buffer~=varuint.encode(Y2hhbm5lbA.length.to!uint); _buffer~=Y2hhbm5lbA;
		_buffer~=data;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] Y2hhbm5lbA; Y2hhbm5lbA.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y2hhbm5lbA.length){ Y2hhbm5lbA=_buffer[*_index..*_index+Y2hhbm5lbA.length].dup; *_index+=Y2hhbm5lbA.length; }; channel=cast(string)Y2hhbm5lbA;
		data=_buffer[*_index..$].dup; *_index=buffer.length;
		return this;
	}

}

struct NamedSoundEffect {

	public enum uint ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string name;
	public uint category;
	public Tuple!(int, "x", int, "y", int, "z") position;
	public float volume;
	public ubyte pitch;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] bmFtZQ=cast(ubyte[])name; _buffer~=varuint.encode(bmFtZQ.length.to!uint); _buffer~=bmFtZQ;
		_buffer~=varuint.encode(category);
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.x, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.y, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.z, _buffer.length-int.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, volume, _buffer.length-float.sizeof);
		_buffer~=pitch;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bmFtZQ.length){ bmFtZQ=_buffer[*_index..*_index+bmFtZQ.length].dup; *_index+=bmFtZQ.length; }; name=cast(string)bmFtZQ;
		category=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+int.sizeof){ position.x=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ position.y=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ position.z=peek!(int, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ volume=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Disconnect {

	public enum uint ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string reason;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] cmVhc29u=cast(ubyte[])reason; _buffer~=varuint.encode(cmVhc29u.length.to!uint); _buffer~=cmVhc29u;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] cmVhc29u; cmVhc29u.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+cmVhc29u.length){ cmVhc29u=_buffer[*_index..*_index+cmVhc29u.length].dup; *_index+=cmVhc29u.length; }; reason=cast(string)cmVhc29u;
		return this;
	}

}

struct EntityStatus {

	public enum uint ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum ubyte SPAWN_TIPPED_ARROW_PARTICLE_EFFECTS = 0;
	public enum ubyte PLAY_JUMPING_ANIMATION_AND_PARTICLES = 1;
	public enum ubyte RESET_SPAWNER_DELAY = 1;
	public enum ubyte PLAY_HURT_ANIMATION_AND_SOUND = 2;
	public enum ubyte PLAY_DEAD_ANIMATION_AND_SOUND = 3;
	public enum ubyte PLAY_ATTACK_ANIMATION_AND_SOUND = 4;
	public enum ubyte SPAWN_SMOKE_PARTICLES = 6;
	public enum ubyte SPAWN_HEART_PARTICLES = 7;
	public enum ubyte PLAY_SHAKING_WATER_ANIMATION = 8;
	public enum ubyte FINISHED_CONSUMING = 9;
	public enum ubyte PLAY_EATING_GRASS_ANIMATION = 10;
	public enum ubyte IGNITE_MINECART_TNT = 10;
	public enum ubyte HOLD_POPPY = 11;
	public enum ubyte SPAWN_VILLAGER_MATING_HEART_PARTICLES = 12;
	public enum ubyte SPAWN_VILLAGER_ANGRY_PARTICLES = 13;
	public enum ubyte SPAWN_VILLAGER_HAPPY_PARTICLES = 14;
	public enum ubyte SPAWN_WITCH_MAGIC_PARTICLES = 15;
	public enum ubyte PLAY_ZOMBIE_CURE_FINISHED_SOUND = 16;
	public enum ubyte SPAWN_FIREWORK_EXPLOSION_EFFECT = 17;
	public enum ubyte SPAWN_LOVE_PARTICLES = 18;
	public enum ubyte RESET_SQUID_ROTATION = 19;
	public enum ubyte SPAWN_EXPLOSION_PARTICLES = 20;
	public enum ubyte PLAY_GUARDIAN_SOUND_EFFECT = 21;
	public enum ubyte ENABLE_REDUCED_DEBUG_SCREEN = 22;
	public enum ubyte DISABLE_REDUCED_DEBUG_SCREEN = 23;
	public enum ubyte SET_OP_PERMISSION_LEVEL_0 = 24;
	public enum ubyte SET_OP_PERMISSION_LEVEL_1 = 25;
	public enum ubyte SET_OP_PERMISSION_LEVEL_2 = 26;
	public enum ubyte SET_OP_PERMISSION_LEVEL_3 = 27;
	public enum ubyte SET_OP_PERMISSION_LEVEL_4 = 28;

	public uint entityId;
	public ubyte status;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, entityId, _buffer.length-uint.sizeof);
		_buffer~=status;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+uint.sizeof){ entityId=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ status=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Explosion {

	public enum uint ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public Tuple!(byte, "x", byte, "y", byte, "z")[] records;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, radius, _buffer.length-float.sizeof);
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, records.length.to!uint, _buffer.length-uint.sizeof); foreach(cmVjb3Jkcw;records){ cmVjb3Jkcw.encode(_buffer); }
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, motion.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, motion.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, motion.z, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ radius=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+uint.sizeof){ records.length=peek!(uint, Endian.bigEndian)(_buffer, _index); } foreach(ref cmVjb3Jkcw;records){ cmVjb3Jkcw.decode(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ motion.x=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.y=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ motion.z=peek!(float, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct UnloadChunk {

	public enum uint ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.x, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.z, _buffer.length-int.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+int.sizeof){ position.x=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ position.z=peek!(int, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct ChangeGameState {

	public enum uint ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// reason
	public enum ubyte INVALID_BED = 0;
	public enum ubyte END_RAINING = 1;
	public enum ubyte BEGIN_RAINING = 2;
	public enum ubyte CHANGE_GAMEMODE = 3;
	public enum ubyte EXIT_END = 4;
	public enum ubyte DEMO_MESSAGE = 5;
	public enum ubyte ARROW_HITTING_PLAYER = 6;
	public enum ubyte FADE_VALUE = 7;
	public enum ubyte FADE_TIME = 8;
	public enum ubyte PLAY_MOB_APPEARANCE = 10;

	// value
	public enum float SURVIVAL = 0;
	public enum float CREATIVE = 1;
	public enum float ADVENTURE = 2;
	public enum float SPECTATOR = 3;
	public enum float SHOW_DEMO_SCREEN = 0;
	public enum float TELL_MOVEMENT_CONTROLS = 101;
	public enum float TELL_JUMP_CONTROLS = 102;
	public enum float TELL_INVENTORY_CONTROLS = 103;
	public enum float BRIGHT = 0;
	public enum float DARK = 1;

	public ubyte reason;
	public float value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=reason;
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, value, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ reason=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ value=peek!(float, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct KeepAlive {

	public enum uint ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint id;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(id);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		id=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct ChunkData {

	public enum uint ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(int, "x", int, "z") position;
	public bool full;
	public uint sections;
	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.x, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.z, _buffer.length-int.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, full, _buffer.length-bool.sizeof);
		_buffer~=varuint.encode(sections);
		_buffer~=varuint.encode(data.length.to!uint); _buffer~=data;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+int.sizeof){ position.x=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ position.z=peek!(int, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ full=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		sections=varuint.decode(_buffer, *_index);
		data.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+data.length){ data=_buffer[*_index..*_index+data.length].dup; *_index+=data.length; }
		return this;
	}

}

struct Effect {

	public enum uint ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// effect id
	public enum uint DISPENSER_DISPENSE = 1000;
	public enum uint DISPENSER_FAIL_DISPENSE = 1001;
	public enum uint DISPENSER_SHOOT = 1002;
	public enum uint DOOR_OPEN_OR_CLOSE = 1003;
	public enum uint FIREWORK_SHOT = 1004;
	public enum uint PLAY_DISC = 1005;
	public enum uint GHAST_WARN = 1007;
	public enum uint GHAST_SHOOT = 1008;
	public enum uint ZOMBIE_ATTACK_WOOD_DOOR = 1010;
	public enum uint ZOMBIE_ATTACK_IRON_DOOR = 1011;
	public enum uint ZOMBIE_BREAK_WOOD_DOOR = 1012;
	public enum uint WITHER_SPAWN = 1013;
	public enum uint WITHER_SHOOT = 1014;
	public enum uint BAT_TAKE_OFF = 1015;
	public enum uint ZOMBIE_INFECT_VILLAGER = 1016;
	public enum uint ZOMBIE_VILLAGER_CONVERT = 1017;
	public enum uint ANVIL_BREAK = 1019;
	public enum uint ANVIL_USE = 1020;
	public enum uint ANVIL_LAND = 1021;
	public enum uint SPAWN_10_SMOKE_PARTICLES = 2000;
	public enum uint BREAK_BREAK_PARTICLES = 2001;
	public enum uint SPLASH_POTION_PARTICLES_AND_SOUND = 2002;
	public enum uint ENDER_EYE_BREAK_PARTICLES_AND_SOUND = 2003;
	public enum uint MOB_SPAWN_PARTICLES = 2004;
	public enum uint BONEMEAL_PARTICLES = 2005;

	public uint effectId;
	public ulong position;
	public uint data;
	public bool disableVolume;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, effectId, _buffer.length-uint.sizeof);
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, data, _buffer.length-uint.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, disableVolume, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+uint.sizeof){ effectId=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+uint.sizeof){ data=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ disableVolume=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Particle {

	public enum uint ID = 34;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// particle id
	public enum uint EXPLODE = 0;
	public enum uint LARGE_EXPLOSION = 1;
	public enum uint HUGE_EXPLOSION = 2;
	public enum uint FIREWORK_SPARK = 3;
	public enum uint BUBBLE = 4;
	public enum uint SPLASH = 5;
	public enum uint WAKE = 6;
	public enum uint SUSPENDED = 7;
	public enum uint DEPTH_SUSPEND = 8;
	public enum uint CRIT = 9;
	public enum uint MAGIC_CRIT = 10;
	public enum uint SMOKE = 11;
	public enum uint LARGE_SMOKE = 12;
	public enum uint SPELL = 13;
	public enum uint INSTANT_SPELL = 14;
	public enum uint MOB_SPELL = 15;
	public enum uint MOB_SPELL_AMBIENT = 16;
	public enum uint WITCH_MAGIC = 17;
	public enum uint DRIP_WATER = 18;
	public enum uint DRIP_LAVA = 19;
	public enum uint ANGRY_VILLAGER = 20;
	public enum uint HAPPY_VILLAGER = 21;
	public enum uint TOWN_AURA = 22;
	public enum uint NOTE = 23;
	public enum uint PORTAL = 24;
	public enum uint ENCHANTMENT_TABLE = 25;
	public enum uint FLAME = 26;
	public enum uint LAVA = 27;
	public enum uint FOOTSTEP = 28;
	public enum uint CLOUD = 29;
	public enum uint RED_DUST = 30;
	public enum uint SNOWBALL_POOF = 31;
	public enum uint SNOW_SHOVEL = 32;
	public enum uint SLIME = 33;
	public enum uint HEART = 34;
	public enum uint BARRIER = 35;
	public enum uint ITEM_CRACK = 36;
	public enum uint BLOCK_CRACK = 37;
	public enum uint BLOCK_DUST = 38;
	public enum uint DROPLET = 39;
	public enum uint TAKE = 40;
	public enum uint MOB_APPEARANCE = 41;
	public enum uint DRAGON_BREATH = 42;
	public enum uint ENDROD = 43;
	public enum uint DAMAGE_INDICATOR = 44;
	public enum uint SWEEP_ATTACK = 45;

	public uint particleId;
	public bool longDistance;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") offset;
	public float data;
	public uint count;
	public uint[2] additionalData;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, particleId, _buffer.length-uint.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, longDistance, _buffer.length-bool.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, position.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, position.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, position.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, offset.x, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, offset.y, _buffer.length-float.sizeof);_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, offset.z, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, data, _buffer.length-float.sizeof);
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, count, _buffer.length-uint.sizeof);
		foreach(YWRkaXRpb25hbERh;additionalData){ _buffer~=varuint.encode(YWRkaXRpb25hbERh); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+uint.sizeof){ particleId=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ longDistance=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ position.x=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.y=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ position.z=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ offset.x=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ offset.y=peek!(float, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+float.sizeof){ offset.z=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ data=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+uint.sizeof){ count=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		foreach(ref YWRkaXRpb25hbERh;additionalData){ YWRkaXRpb25hbERh=varuint.decode(_buffer, *_index); }
		return this;
	}

}

struct JoinGame {

	public enum uint ID = 35;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// gamemode
	public enum ubyte SURVIVAL = 0;
	public enum ubyte CREATIVE = 1;
	public enum ubyte ADVENTURE = 2;
	public enum ubyte SPECTATOR = 3;

	// dimension
	public enum byte END = -1;
	public enum byte OVERWORLD = 0;
	public enum byte NETHER = 1;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	// level type
	public enum string INFINITY = "default";
	public enum string FLAT = "flat";
	public enum string AMPLIFIED = "amplified";
	public enum string LARGE_BIOMES = "largeBiomes";

	public uint entityId;
	public ubyte gamemode;
	public byte dimension;
	public ubyte difficulty;
	public ubyte maxPlayers;
	public string levelType;
	public bool reducedDebug;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, entityId, _buffer.length-uint.sizeof);
		_buffer~=gamemode;
		_buffer.length+=byte.sizeof; write!(byte, Endian.bigEndian)(_buffer, dimension, _buffer.length-byte.sizeof);
		_buffer~=difficulty;
		_buffer~=maxPlayers;
		ubyte[] bGV2ZWxUeXBl=cast(ubyte[])levelType; _buffer~=varuint.encode(bGV2ZWxUeXBl.length.to!uint); _buffer~=bGV2ZWxUeXBl;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, reducedDebug, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+uint.sizeof){ entityId=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ gamemode=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+byte.sizeof){ dimension=peek!(byte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ difficulty=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ maxPlayers=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		ubyte[] bGV2ZWxUeXBl; bGV2ZWxUeXBl.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bGV2ZWxUeXBl.length){ bGV2ZWxUeXBl=_buffer[*_index..*_index+bGV2ZWxUeXBl.length].dup; *_index+=bGV2ZWxUeXBl.length; }; levelType=cast(string)bGV2ZWxUeXBl;
		if(_buffer.length>=*_index+bool.sizeof){ reducedDebug=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Map {

	public enum uint ID = 36;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint mapId;
	public ubyte scale;
	public bool showIcons;
	public sul.protocol.minecraft107.types.Icon[] icons;
	public ubyte colums;
	public ubyte rows;
	public Tuple!(ubyte, "x", ubyte, "z") offset;
	public ubyte[] data;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(mapId);
		_buffer~=scale;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, showIcons, _buffer.length-bool.sizeof);
		_buffer~=varuint.encode(icons.length.to!uint); foreach(aWNvbnM;icons){ aWNvbnM.encode(_buffer); }
		_buffer~=colums;
		_buffer~=rows;
		_buffer~=offset.x;_buffer~=offset.z;
		_buffer~=varuint.encode(data.length.to!uint); _buffer~=data;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		mapId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ scale=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ showIcons=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		icons.length=varuint.decode(_buffer, *_index); foreach(ref aWNvbnM;icons){ aWNvbnM.decode(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ colums=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ rows=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ offset.x=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+ubyte.sizeof){ offset.z=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		data.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+data.length){ data=_buffer[*_index..*_index+data.length].dup; *_index+=data.length; }
		return this;
	}

}

struct EntityRelativeMove {

	public enum uint ID = 37;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") delta;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, delta.x, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, delta.y, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, delta.z, _buffer.length-short.sizeof);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, onGround, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+short.sizeof){ delta.x=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ delta.y=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ delta.z=peek!(short, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ onGround=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct EntityLookAndRelativeMove {

	public enum uint ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") delta;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, delta.x, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, delta.y, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, delta.z, _buffer.length-short.sizeof);
		_buffer~=yaw;
		_buffer~=pitch;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, onGround, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+short.sizeof){ delta.x=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ delta.y=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ delta.z=peek!(short, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ yaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ onGround=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct EntityLook {

	public enum uint ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=yaw;
		_buffer~=pitch;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, onGround, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ yaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ onGround=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Entity {

	public enum uint ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct VehicleMove {

	public enum uint ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public Tuple!(double, "x", double, "y", double, "z") position;
	public float yaw;
	public float pitch;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct OpenSignEditor {

	public enum uint ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct PlayerAbilities {

	public enum uint ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags
	public enum ubyte INVULNERABLE = 1;
	public enum ubyte FLYING = 2;
	public enum ubyte ALLOW_FLYING = 4;
	public enum ubyte CREATIVE_MODE = 8;

	public ubyte flags;
	public float flyingSpeed;
	public float fovModifier;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=flags;
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, flyingSpeed, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, fovModifier, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ flags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ flyingSpeed=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ fovModifier=peek!(float, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct CombatEvent {

	public enum uint ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte eventId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=eventId;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ eventId=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

	public struct EnterCombat {

		public enum typeof(eventId) EVENT-ID = 0;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			return this;
		}

	}

	public struct EndCombat {

		public enum typeof(eventId) EVENT-ID = 1;

		public uint duration;
		public uint entityId;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(duration);
			_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, entityId, _buffer.length-uint.sizeof);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			duration=varuint.decode(_buffer, *_index);
			if(_buffer.length>=*_index+uint.sizeof){ entityId=peek!(uint, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct EntityDead {

		public enum typeof(eventId) EVENT-ID = 2;

		public uint playerId;
		public uint entityId;
		public string message;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(playerId);
			_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, entityId, _buffer.length-uint.sizeof);
			ubyte[] bWVzc2FnZQ=cast(ubyte[])message; _buffer~=varuint.encode(bWVzc2FnZQ.length.to!uint); _buffer~=bWVzc2FnZQ;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			playerId=varuint.decode(_buffer, *_index);
			if(_buffer.length>=*_index+uint.sizeof){ entityId=peek!(uint, Endian.bigEndian)(_buffer, _index); }
			ubyte[] bWVzc2FnZQ; bWVzc2FnZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bWVzc2FnZQ.length){ bWVzc2FnZQ=_buffer[*_index..*_index+bWVzc2FnZQ.length].dup; *_index+=bWVzc2FnZQ.length; }; message=cast(string)bWVzc2FnZQ;
			return this;
		}

	}

}

struct PlayerListItem {

	public enum uint ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(action);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		action=varuint.decode(_buffer, *_index);
		return this;
	}

	public struct AddPlayer {

		public enum typeof(action) ACTION = 0;

		public sul.protocol.minecraft107.types.ListAddPlayer[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ cGxheWVycw.encode(_buffer); }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ cGxheWVycw.decode(_buffer, _index); }
			return this;
		}

	}

	public struct UpdateGamemode {

		public enum typeof(action) ACTION = 1;

		public sul.protocol.minecraft107.types.ListUpdateGamemode[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ cGxheWVycw.encode(_buffer); }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ cGxheWVycw.decode(_buffer, _index); }
			return this;
		}

	}

	public struct UpdateLatency {

		public enum typeof(action) ACTION = 2;

		public sul.protocol.minecraft107.types.ListUpdateLatency[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ cGxheWVycw.encode(_buffer); }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ cGxheWVycw.decode(_buffer, _index); }
			return this;
		}

	}

	public struct UpdateDisplayName {

		public enum typeof(action) ACTION = 3;

		public sul.protocol.minecraft107.types.ListUpdateDisplayName[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ cGxheWVycw.encode(_buffer); }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ cGxheWVycw.decode(_buffer, _index); }
			return this;
		}

	}

	public struct RemovePlayer {

		public enum typeof(action) ACTION = 4;

		public UUID[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ _buffer~=cGxheWVycw.data; }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ if(_buffer.length>=*_index+16){ ubyte[16] Y0d4aGVXVnljdw=buffer[*_index..*_index+16].dup; *_index+=16; cGxheWVycw=UUID(Y0d4aGVXVnljdw); } }
			return this;
		}

	}

}

struct PlayerPositionAndLook {

	public enum uint ID = 46;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags
	public enum ubyte X = 1;
	public enum ubyte Y = 2;
	public enum ubyte Z = 4;
	public enum ubyte Y_ROTATION = 8;
	public enum ubyte X_ROTATION = 16;

	public Tuple!(double, "x", double, "y", double, "z") position;
	public float yaw;
	public float pitch;
	public ubyte flags;
	public uint teleportId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, yaw, _buffer.length-float.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, pitch, _buffer.length-float.sizeof);
		_buffer~=flags;
		_buffer~=varuint.encode(teleportId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ yaw=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ pitch=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ flags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		teleportId=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct UseBed {

	public enum uint ID = 47;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ulong position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct DestroyEntities {

	public enum uint ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint[] entityIds;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityIds.length.to!uint); foreach(ZW50aXR5SWRz;entityIds){ _buffer~=varuint.encode(ZW50aXR5SWRz); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityIds.length=varuint.decode(_buffer, *_index); foreach(ref ZW50aXR5SWRz;entityIds){ ZW50aXR5SWRz=varuint.decode(_buffer, *_index); }
		return this;
	}

}

struct RemoveEntityEffect {

	public enum uint ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte effectId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=effectId;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ effectId=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct ResourcePackSend {

	public enum uint ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string url;
	public string hash;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] dXJs=cast(ubyte[])url; _buffer~=varuint.encode(dXJs.length.to!uint); _buffer~=dXJs;
		ubyte[] aGFzaA=cast(ubyte[])hash; _buffer~=varuint.encode(aGFzaA.length.to!uint); _buffer~=aGFzaA;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] dXJs; dXJs.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dXJs.length){ dXJs=_buffer[*_index..*_index+dXJs.length].dup; *_index+=dXJs.length; }; url=cast(string)dXJs;
		ubyte[] aGFzaA; aGFzaA.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+aGFzaA.length){ aGFzaA=_buffer[*_index..*_index+aGFzaA.length].dup; *_index+=aGFzaA.length; }; hash=cast(string)aGFzaA;
		return this;
	}

}

struct Respawn {

	public enum uint ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int END = -1;
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;

	// difficulty
	public enum ubyte PEACEFUL = 0;
	public enum ubyte EASY = 1;
	public enum ubyte NORMAL = 2;
	public enum ubyte HARD = 3;

	// gamemode
	public enum ubyte SURVIVAL = 0;
	public enum ubyte CREATIVE = 1;
	public enum ubyte ADVENTURE = 2;
	public enum ubyte SPECTATOR = 3;

	// level type
	public enum string INFINITY = "default";
	public enum string FLAT = "flat";
	public enum string AMPLIFIED = "amplified";
	public enum string LARGE_BIOMES = "largeBiomes";

	public int dimension;
	public ubyte difficulty;
	public ubyte gamemode;
	public string levelType;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, dimension, _buffer.length-int.sizeof);
		_buffer~=difficulty;
		_buffer~=gamemode;
		ubyte[] bGV2ZWxUeXBl=cast(ubyte[])levelType; _buffer~=varuint.encode(bGV2ZWxUeXBl.length.to!uint); _buffer~=bGV2ZWxUeXBl;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+int.sizeof){ dimension=peek!(int, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ difficulty=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ gamemode=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		ubyte[] bGV2ZWxUeXBl; bGV2ZWxUeXBl.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bGV2ZWxUeXBl.length){ bGV2ZWxUeXBl=_buffer[*_index..*_index+bGV2ZWxUeXBl.length].dup; *_index+=bGV2ZWxUeXBl.length; }; levelType=cast(string)bGV2ZWxUeXBl;
		return this;
	}

}

struct EntityHeadLook {

	public enum uint ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte headYaw;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=headYaw;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ headYaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct WorldBorder {

	public enum uint ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(action);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		action=varuint.decode(_buffer, *_index);
		return this;
	}

	public struct SetSize {

		public enum typeof(action) ACTION = 0;

		public double diameter;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, diameter, _buffer.length-double.sizeof);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+double.sizeof){ diameter=peek!(double, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct LerpSize {

		public enum typeof(action) ACTION = 1;

		public double oldDiameter;
		public double newDiameter;
		public ulong speed;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, oldDiameter, _buffer.length-double.sizeof);
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, newDiameter, _buffer.length-double.sizeof);
			_buffer~=varulong.encode(speed);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+double.sizeof){ oldDiameter=peek!(double, Endian.bigEndian)(_buffer, _index); }
			if(_buffer.length>=*_index+double.sizeof){ newDiameter=peek!(double, Endian.bigEndian)(_buffer, _index); }
			speed=varulong.decode(_buffer, *_index);
			return this;
		}

	}

	public struct SetCenter {

		public enum typeof(action) ACTION = 2;

		public Tuple!(double, "x", double, "y", double, "z") center;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, center.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, center.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, center.z, _buffer.length-double.sizeof);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+double.sizeof){ center.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ center.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ center.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct Initialize {

		public enum typeof(action) ACTION = 3;

		public Tuple!(double, "x", double, "y", double, "z") center;
		public double oldDiameter;
		public double newDiameter;
		public ulong speed;
		public uint portalTeleportBoundary;
		public uint warningTime;
		public uint warningBlocks;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, center.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, center.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, center.z, _buffer.length-double.sizeof);
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, oldDiameter, _buffer.length-double.sizeof);
			_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, newDiameter, _buffer.length-double.sizeof);
			_buffer~=varulong.encode(speed);
			_buffer~=varuint.encode(portalTeleportBoundary);
			_buffer~=varuint.encode(warningTime);
			_buffer~=varuint.encode(warningBlocks);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+double.sizeof){ center.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ center.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ center.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
			if(_buffer.length>=*_index+double.sizeof){ oldDiameter=peek!(double, Endian.bigEndian)(_buffer, _index); }
			if(_buffer.length>=*_index+double.sizeof){ newDiameter=peek!(double, Endian.bigEndian)(_buffer, _index); }
			speed=varulong.decode(_buffer, *_index);
			portalTeleportBoundary=varuint.decode(_buffer, *_index);
			warningTime=varuint.decode(_buffer, *_index);
			warningBlocks=varuint.decode(_buffer, *_index);
			return this;
		}

	}

	public struct SetWarningTime {

		public enum typeof(action) ACTION = 4;

		public uint warningTime;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(warningTime);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			warningTime=varuint.decode(_buffer, *_index);
			return this;
		}

	}

	public struct SetWarningBlocks {

		public enum typeof(action) ACTION = 5;

		public uint warningBlocks;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(warningBlocks);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			warningBlocks=varuint.decode(_buffer, *_index);
			return this;
		}

	}

}

struct Camera {

	public enum uint ID = 54;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct HeldItemChange {

	public enum uint ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ubyte slot;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=slot;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ slot=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct DisplayScoreboard {

	public enum uint ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// position
	public enum ubyte LIST = 0;
	public enum ubyte SIDEBAR = 1;
	public enum ubyte BELOW_NAME = 2;

	public ubyte position;
	public string scoreName;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=position;
		ubyte[] c2NvcmVOYW1l=cast(ubyte[])scoreName; _buffer~=varuint.encode(c2NvcmVOYW1l.length.to!uint); _buffer~=c2NvcmVOYW1l;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ position=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		ubyte[] c2NvcmVOYW1l; c2NvcmVOYW1l.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+c2NvcmVOYW1l.length){ c2NvcmVOYW1l=_buffer[*_index..*_index+c2NvcmVOYW1l.length].dup; *_index+=c2NvcmVOYW1l.length; }; scoreName=cast(string)c2NvcmVOYW1l;
		return this;
	}

}

struct EntityMetadata {

	public enum uint ID = 57;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public sul.protocol.minecraft107.types.Metadata metadata;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		metadata.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		metadata.decode(_buffer, _index);
		return this;
	}

}

struct AttachEntity {

	public enum uint ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint target;
	public uint holder;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, target, _buffer.length-uint.sizeof);
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, holder, _buffer.length-uint.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+uint.sizeof){ target=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+uint.sizeof){ holder=peek!(uint, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct EntityVelocity {

	public enum uint ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(short, "x", short, "y", short, "z") velocity;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.x, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.y, _buffer.length-short.sizeof);_buffer.length+=short.sizeof; write!(short, Endian.bigEndian)(_buffer, velocity.z, _buffer.length-short.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+short.sizeof){ velocity.x=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ velocity.y=peek!(short, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+short.sizeof){ velocity.z=peek!(short, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct EntityEquipment {

	public enum uint ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public uint slot;
	public sul.protocol.minecraft107.types.Slot item;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=varuint.encode(slot);
		item.encode(_buffer);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		slot=varuint.decode(_buffer, *_index);
		item.decode(_buffer, _index);
		return this;
	}

}

struct SetExperience {

	public enum uint ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public float experience;
	public uint level;
	public uint totalExperience;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, experience, _buffer.length-float.sizeof);
		_buffer~=varuint.encode(level);
		_buffer~=varuint.encode(totalExperience);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+float.sizeof){ experience=peek!(float, Endian.bigEndian)(_buffer, _index); }
		level=varuint.decode(_buffer, *_index);
		totalExperience=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct UpdateHealth {

	public enum uint ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public float health;
	public uint hunger;
	public float saturation;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, health, _buffer.length-float.sizeof);
		_buffer~=varuint.encode(hunger);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, saturation, _buffer.length-float.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+float.sizeof){ health=peek!(float, Endian.bigEndian)(_buffer, _index); }
		hunger=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+float.sizeof){ saturation=peek!(float, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct ScoreboardObjective {

	public enum uint ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// mode
	public enum ubyte CREATE = 0;
	public enum ubyte REMOVE = 1;
	public enum ubyte UPDATE = 2;

	// type
	public enum string NUMERIC = "integer";
	public enum string GRAPHIC = "hearts";

	public string name;
	public ubyte mode;
	public string value;
	public string type;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] bmFtZQ=cast(ubyte[])name; _buffer~=varuint.encode(bmFtZQ.length.to!uint); _buffer~=bmFtZQ;
		_buffer~=mode;
		if(mode!=1){ ubyte[] dmFsdWU=cast(ubyte[])value; _buffer~=varuint.encode(dmFsdWU.length.to!uint); _buffer~=dmFsdWU; }
		if(mode!=1){ ubyte[] dHlwZQ=cast(ubyte[])type; _buffer~=varuint.encode(dHlwZQ.length.to!uint); _buffer~=dHlwZQ; }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bmFtZQ.length){ bmFtZQ=_buffer[*_index..*_index+bmFtZQ.length].dup; *_index+=bmFtZQ.length; }; name=cast(string)bmFtZQ;
		if(_buffer.length>=*_index+ubyte.sizeof){ mode=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(mode!=1){ ubyte[] dmFsdWU; dmFsdWU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dmFsdWU.length){ dmFsdWU=_buffer[*_index..*_index+dmFsdWU.length].dup; *_index+=dmFsdWU.length; }; value=cast(string)dmFsdWU; }
		if(mode!=1){ ubyte[] dHlwZQ; dHlwZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dHlwZQ.length){ dHlwZQ=_buffer[*_index..*_index+dHlwZQ.length].dup; *_index+=dHlwZQ.length; }; type=cast(string)dHlwZQ; }
		return this;
	}

}

struct SetPassengers {

	public enum uint ID = 64;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public uint[] passengers;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=varuint.encode(passengers.length.to!uint); foreach(cGFzc2VuZ2Vycw;passengers){ _buffer~=varuint.encode(cGFzc2VuZ2Vycw); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		passengers.length=varuint.decode(_buffer, *_index); foreach(ref cGFzc2VuZ2Vycw;passengers){ cGFzc2VuZ2Vycw=varuint.decode(_buffer, *_index); }
		return this;
	}

}

struct Teams {

	public enum uint ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string name;
	public ubyte mode;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] bmFtZQ=cast(ubyte[])name; _buffer~=varuint.encode(bmFtZQ.length.to!uint); _buffer~=bmFtZQ;
		_buffer~=mode;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] bmFtZQ; bmFtZQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bmFtZQ.length){ bmFtZQ=_buffer[*_index..*_index+bmFtZQ.length].dup; *_index+=bmFtZQ.length; }; name=cast(string)bmFtZQ;
		if(_buffer.length>=*_index+ubyte.sizeof){ mode=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

	public struct CreateTeam {

		public enum typeof(mode) MODE = 0;

		// friendly flags
		public enum ubyte FRIENDLY_FIRE = 1;
		public enum ubyte SEE_TEAM_INVISIBLE_PLAYERS = 2;

		// nametag visibility
		public enum string ALWAYS = "always";
		public enum string HIDE_OTHER_TEAMS = "hideOtherTeams";
		public enum string HIDE_OWN_TEAM = "hideOwnTeam";
		public enum string NEVEN = "never";

		// collision rule
		public enum string ALWAYS = "always";
		public enum string PUSH_OTHER_TEAMS = "pushOtherTeams";
		public enum string PUSH_OWN_TEAM = "pushOwnTeam";
		public enum string NEVEN = "never";

		public string displayName;
		public string prefix;
		public string suffix;
		public ubyte friendlyFlags;
		public string nametagVisibility;
		public string collisionRule;
		public ubyte color;
		public string[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; _buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint); _buffer~=ZGlzcGxheU5hbWU;
			ubyte[] cHJlZml4=cast(ubyte[])prefix; _buffer~=varuint.encode(cHJlZml4.length.to!uint); _buffer~=cHJlZml4;
			ubyte[] c3VmZml4=cast(ubyte[])suffix; _buffer~=varuint.encode(c3VmZml4.length.to!uint); _buffer~=c3VmZml4;
			_buffer~=friendlyFlags;
			ubyte[] bmFtZXRhZ1Zpc2li=cast(ubyte[])nametagVisibility; _buffer~=varuint.encode(bmFtZXRhZ1Zpc2li.length.to!uint); _buffer~=bmFtZXRhZ1Zpc2li;
			ubyte[] Y29sbGlzaW9uUnVs=cast(ubyte[])collisionRule; _buffer~=varuint.encode(Y29sbGlzaW9uUnVs.length.to!uint); _buffer~=Y29sbGlzaW9uUnVs;
			_buffer~=color;
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ ubyte[] Y0d4aGVXVnljdw=cast(ubyte[])cGxheWVycw; _buffer~=varuint.encode(Y0d4aGVXVnljdw.length.to!uint); _buffer~=Y0d4aGVXVnljdw; }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=_buffer[*_index..*_index+ZGlzcGxheU5hbWU.length].dup; *_index+=ZGlzcGxheU5hbWU.length; }; displayName=cast(string)ZGlzcGxheU5hbWU;
			ubyte[] cHJlZml4; cHJlZml4.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+cHJlZml4.length){ cHJlZml4=_buffer[*_index..*_index+cHJlZml4.length].dup; *_index+=cHJlZml4.length; }; prefix=cast(string)cHJlZml4;
			ubyte[] c3VmZml4; c3VmZml4.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+c3VmZml4.length){ c3VmZml4=_buffer[*_index..*_index+c3VmZml4.length].dup; *_index+=c3VmZml4.length; }; suffix=cast(string)c3VmZml4;
			if(_buffer.length>=*_index+ubyte.sizeof){ friendlyFlags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			ubyte[] bmFtZXRhZ1Zpc2li; bmFtZXRhZ1Zpc2li.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bmFtZXRhZ1Zpc2li.length){ bmFtZXRhZ1Zpc2li=_buffer[*_index..*_index+bmFtZXRhZ1Zpc2li.length].dup; *_index+=bmFtZXRhZ1Zpc2li.length; }; nametagVisibility=cast(string)bmFtZXRhZ1Zpc2li;
			ubyte[] Y29sbGlzaW9uUnVs; Y29sbGlzaW9uUnVs.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y29sbGlzaW9uUnVs.length){ Y29sbGlzaW9uUnVs=_buffer[*_index..*_index+Y29sbGlzaW9uUnVs.length].dup; *_index+=Y29sbGlzaW9uUnVs.length; }; collisionRule=cast(string)Y29sbGlzaW9uUnVs;
			if(_buffer.length>=*_index+ubyte.sizeof){ color=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ ubyte[] Y0d4aGVXVnljdw; Y0d4aGVXVnljdw.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y0d4aGVXVnljdw.length){ Y0d4aGVXVnljdw=_buffer[*_index..*_index+Y0d4aGVXVnljdw.length].dup; *_index+=Y0d4aGVXVnljdw.length; }; cGxheWVycw=cast(string)Y0d4aGVXVnljdw; }
			return this;
		}

	}

	public struct RemoveTeam {

		public enum typeof(mode) MODE = 1;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			return this;
		}

	}

	public struct UpdateTeamInfo {

		public enum typeof(mode) MODE = 2;

		// friendly flags
		public enum ubyte FRIENDLY_FIRE = 1;
		public enum ubyte SEE_TEAM_INVISIBLE_PLAYERS = 2;

		// nametag visibility
		public enum string ALWAYS = "always";
		public enum string HIDE_OTHER_TEAMS = "hideOtherTeams";
		public enum string HIDE_OWN_TEAM = "hideOwnTeam";
		public enum string NEVEN = "never";

		// collision rule
		public enum string ALWAYS = "always";
		public enum string PUSH_OTHER_TEAMS = "pushOtherTeams";
		public enum string PUSH_OWN_TEAM = "pushOwnTeam";
		public enum string NEVEN = "never";

		public string displayName;
		public string prefix;
		public string suffix;
		public ubyte friendlyFlags;
		public string nametagVisibility;
		public string collisionRule;
		public ubyte color;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] ZGlzcGxheU5hbWU=cast(ubyte[])displayName; _buffer~=varuint.encode(ZGlzcGxheU5hbWU.length.to!uint); _buffer~=ZGlzcGxheU5hbWU;
			ubyte[] cHJlZml4=cast(ubyte[])prefix; _buffer~=varuint.encode(cHJlZml4.length.to!uint); _buffer~=cHJlZml4;
			ubyte[] c3VmZml4=cast(ubyte[])suffix; _buffer~=varuint.encode(c3VmZml4.length.to!uint); _buffer~=c3VmZml4;
			_buffer~=friendlyFlags;
			ubyte[] bmFtZXRhZ1Zpc2li=cast(ubyte[])nametagVisibility; _buffer~=varuint.encode(bmFtZXRhZ1Zpc2li.length.to!uint); _buffer~=bmFtZXRhZ1Zpc2li;
			ubyte[] Y29sbGlzaW9uUnVs=cast(ubyte[])collisionRule; _buffer~=varuint.encode(Y29sbGlzaW9uUnVs.length.to!uint); _buffer~=Y29sbGlzaW9uUnVs;
			_buffer~=color;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] ZGlzcGxheU5hbWU; ZGlzcGxheU5hbWU.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+ZGlzcGxheU5hbWU.length){ ZGlzcGxheU5hbWU=_buffer[*_index..*_index+ZGlzcGxheU5hbWU.length].dup; *_index+=ZGlzcGxheU5hbWU.length; }; displayName=cast(string)ZGlzcGxheU5hbWU;
			ubyte[] cHJlZml4; cHJlZml4.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+cHJlZml4.length){ cHJlZml4=_buffer[*_index..*_index+cHJlZml4.length].dup; *_index+=cHJlZml4.length; }; prefix=cast(string)cHJlZml4;
			ubyte[] c3VmZml4; c3VmZml4.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+c3VmZml4.length){ c3VmZml4=_buffer[*_index..*_index+c3VmZml4.length].dup; *_index+=c3VmZml4.length; }; suffix=cast(string)c3VmZml4;
			if(_buffer.length>=*_index+ubyte.sizeof){ friendlyFlags=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			ubyte[] bmFtZXRhZ1Zpc2li; bmFtZXRhZ1Zpc2li.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+bmFtZXRhZ1Zpc2li.length){ bmFtZXRhZ1Zpc2li=_buffer[*_index..*_index+bmFtZXRhZ1Zpc2li.length].dup; *_index+=bmFtZXRhZ1Zpc2li.length; }; nametagVisibility=cast(string)bmFtZXRhZ1Zpc2li;
			ubyte[] Y29sbGlzaW9uUnVs; Y29sbGlzaW9uUnVs.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y29sbGlzaW9uUnVs.length){ Y29sbGlzaW9uUnVs=_buffer[*_index..*_index+Y29sbGlzaW9uUnVs.length].dup; *_index+=Y29sbGlzaW9uUnVs.length; }; collisionRule=cast(string)Y29sbGlzaW9uUnVs;
			if(_buffer.length>=*_index+ubyte.sizeof){ color=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct AddPlayers {

		public enum typeof(mode) MODE = 3;

		public string[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ ubyte[] Y0d4aGVXVnljdw=cast(ubyte[])cGxheWVycw; _buffer~=varuint.encode(Y0d4aGVXVnljdw.length.to!uint); _buffer~=Y0d4aGVXVnljdw; }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ ubyte[] Y0d4aGVXVnljdw; Y0d4aGVXVnljdw.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y0d4aGVXVnljdw.length){ Y0d4aGVXVnljdw=_buffer[*_index..*_index+Y0d4aGVXVnljdw.length].dup; *_index+=Y0d4aGVXVnljdw.length; }; cGxheWVycw=cast(string)Y0d4aGVXVnljdw; }
			return this;
		}

	}

	public struct RemovePlayers {

		public enum typeof(mode) MODE = 4;

		public string[] players;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer~=varuint.encode(players.length.to!uint); foreach(cGxheWVycw;players){ ubyte[] Y0d4aGVXVnljdw=cast(ubyte[])cGxheWVycw; _buffer~=varuint.encode(Y0d4aGVXVnljdw.length.to!uint); _buffer~=Y0d4aGVXVnljdw; }
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			players.length=varuint.decode(_buffer, *_index); foreach(ref cGxheWVycw;players){ ubyte[] Y0d4aGVXVnljdw; Y0d4aGVXVnljdw.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Y0d4aGVXVnljdw.length){ Y0d4aGVXVnljdw=_buffer[*_index..*_index+Y0d4aGVXVnljdw.length].dup; *_index+=Y0d4aGVXVnljdw.length; }; cGxheWVycw=cast(string)Y0d4aGVXVnljdw; }
			return this;
		}

	}

}

struct UpdateScore {

	public enum uint ID = 66;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte UPDATE = 0;
	public enum ubyte REMOVE = 1;

	public string scoreName;
	public ubyte action;
	public string objectiveName;
	public uint value;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] c2NvcmVOYW1l=cast(ubyte[])scoreName; _buffer~=varuint.encode(c2NvcmVOYW1l.length.to!uint); _buffer~=c2NvcmVOYW1l;
		_buffer~=action;
		ubyte[] b2JqZWN0aXZlTmFt=cast(ubyte[])objectiveName; _buffer~=varuint.encode(b2JqZWN0aXZlTmFt.length.to!uint); _buffer~=b2JqZWN0aXZlTmFt;
		if(action==0){ _buffer~=varuint.encode(value); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] c2NvcmVOYW1l; c2NvcmVOYW1l.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+c2NvcmVOYW1l.length){ c2NvcmVOYW1l=_buffer[*_index..*_index+c2NvcmVOYW1l.length].dup; *_index+=c2NvcmVOYW1l.length; }; scoreName=cast(string)c2NvcmVOYW1l;
		if(_buffer.length>=*_index+ubyte.sizeof){ action=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		ubyte[] b2JqZWN0aXZlTmFt; b2JqZWN0aXZlTmFt.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+b2JqZWN0aXZlTmFt.length){ b2JqZWN0aXZlTmFt=_buffer[*_index..*_index+b2JqZWN0aXZlTmFt.length].dup; *_index+=b2JqZWN0aXZlTmFt.length; }; objectiveName=cast(string)b2JqZWN0aXZlTmFt;
		if(action==0){ value=varuint.decode(_buffer, *_index); }
		return this;
	}

}

struct SpawnPosition {

	public enum uint ID = 67;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct TimeUpdate {

	public enum uint ID = 68;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong worldAge;
	public long time;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, worldAge, _buffer.length-ulong.sizeof);
		_buffer.length+=long.sizeof; write!(long, Endian.bigEndian)(_buffer, time, _buffer.length-long.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ worldAge=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+long.sizeof){ time=peek!(long, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct Title {

	public enum uint ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint action;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(action);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		action=varuint.decode(_buffer, *_index);
		return this;
	}

	public struct SetTitle {

		public enum typeof(action) ACTION = 0;

		public string text;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] dGV4dA=cast(ubyte[])text; _buffer~=varuint.encode(dGV4dA.length.to!uint); _buffer~=dGV4dA;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] dGV4dA; dGV4dA.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dGV4dA.length){ dGV4dA=_buffer[*_index..*_index+dGV4dA.length].dup; *_index+=dGV4dA.length; }; text=cast(string)dGV4dA;
			return this;
		}

	}

	public struct SetSubtitle {

		public enum typeof(action) ACTION = 1;

		public string text;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			ubyte[] dGV4dA=cast(ubyte[])text; _buffer~=varuint.encode(dGV4dA.length.to!uint); _buffer~=dGV4dA;
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			ubyte[] dGV4dA; dGV4dA.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+dGV4dA.length){ dGV4dA=_buffer[*_index..*_index+dGV4dA.length].dup; *_index+=dGV4dA.length; }; text=cast(string)dGV4dA;
			return this;
		}

	}

	public struct SetTimings {

		public enum typeof(action) ACTION = 2;

		public uint fadeIn;
		public uint stay;
		public uint fadeOut;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, fadeIn, _buffer.length-uint.sizeof);
			_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, stay, _buffer.length-uint.sizeof);
			_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, fadeOut, _buffer.length-uint.sizeof);
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			if(_buffer.length>=*_index+uint.sizeof){ fadeIn=peek!(uint, Endian.bigEndian)(_buffer, _index); }
			if(_buffer.length>=*_index+uint.sizeof){ stay=peek!(uint, Endian.bigEndian)(_buffer, _index); }
			if(_buffer.length>=*_index+uint.sizeof){ fadeOut=peek!(uint, Endian.bigEndian)(_buffer, _index); }
			return this;
		}

	}

	public struct Hide {

		public enum typeof(action) ACTION = 3;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			return this;
		}

	}

	public struct Reset {

		public enum typeof(action) ACTION = 4;

		public ubyte[] encode() {
			ubyte[] _buffer;
			this.encode(_buffer);
			return _buffer;
		}

		public ubyte[] encode(ref ubyte[] _buffer) {
			return _buffer;
		}

		public typeof(this) decode(ubyte[] _buffer, size_t* _index) {
			return this;
		}

	}

}

struct UpdateSign {

	public enum uint ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public ulong position;
	public string[4] lines;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer.length+=ulong.sizeof; write!(ulong, Endian.bigEndian)(_buffer, position, _buffer.length-ulong.sizeof);
		foreach(bGluZXM;lines){ ubyte[] YkdsdVpYTQ=cast(ubyte[])bGluZXM; _buffer~=varuint.encode(YkdsdVpYTQ.length.to!uint); _buffer~=YkdsdVpYTQ; }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		if(_buffer.length>=*_index+ulong.sizeof){ position=peek!(ulong, Endian.bigEndian)(_buffer, _index); }
		foreach(ref bGluZXM;lines){ ubyte[] YkdsdVpYTQ; YkdsdVpYTQ.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+YkdsdVpYTQ.length){ YkdsdVpYTQ=_buffer[*_index..*_index+YkdsdVpYTQ.length].dup; *_index+=YkdsdVpYTQ.length; }; bGluZXM=cast(string)YkdsdVpYTQ; }
		return this;
	}

}

struct SoundEffect {

	public enum uint ID = 71;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint soundId;
	public uint category;
	public Tuple!(int, "x", int, "y", int, "z") position;
	public float volume;
	public ubyte pitch;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(soundId);
		_buffer~=varuint.encode(category);
		_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.x, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.y, _buffer.length-int.sizeof);_buffer.length+=int.sizeof; write!(int, Endian.bigEndian)(_buffer, position.z, _buffer.length-int.sizeof);
		_buffer.length+=float.sizeof; write!(float, Endian.bigEndian)(_buffer, volume, _buffer.length-float.sizeof);
		_buffer~=pitch;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		soundId=varuint.decode(_buffer, *_index);
		category=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+int.sizeof){ position.x=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ position.y=peek!(int, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+int.sizeof){ position.z=peek!(int, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+float.sizeof){ volume=peek!(float, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct PlayerListHeaderAndFooter {

	public enum uint ID = 72;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public string header;
	public string footer;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		ubyte[] aGVhZGVy=cast(ubyte[])header; _buffer~=varuint.encode(aGVhZGVy.length.to!uint); _buffer~=aGVhZGVy;
		ubyte[] Zm9vdGVy=cast(ubyte[])footer; _buffer~=varuint.encode(Zm9vdGVy.length.to!uint); _buffer~=Zm9vdGVy;
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		ubyte[] aGVhZGVy; aGVhZGVy.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+aGVhZGVy.length){ aGVhZGVy=_buffer[*_index..*_index+aGVhZGVy.length].dup; *_index+=aGVhZGVy.length; }; header=cast(string)aGVhZGVy;
		ubyte[] Zm9vdGVy; Zm9vdGVy.length=varuint.decode(_buffer, *_index); if(_buffer.length>=*_index+Zm9vdGVy.length){ Zm9vdGVy=_buffer[*_index..*_index+Zm9vdGVy.length].dup; *_index+=Zm9vdGVy.length; }; footer=cast(string)Zm9vdGVy;
		return this;
	}

}

struct CollectItem {

	public enum uint ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint collected;
	public uint collector;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(collected);
		_buffer~=varuint.encode(collector);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		collected=varuint.decode(_buffer, *_index);
		collector=varuint.decode(_buffer, *_index);
		return this;
	}

}

struct EntityTeleport {

	public enum uint ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public Tuple!(double, "x", double, "y", double, "z") position;
	public ubyte yaw;
	public ubyte pitch;
	public bool onGround;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.x, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.y, _buffer.length-double.sizeof);_buffer.length+=double.sizeof; write!(double, Endian.bigEndian)(_buffer, position.z, _buffer.length-double.sizeof);
		_buffer~=yaw;
		_buffer~=pitch;
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, onGround, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+double.sizeof){ position.x=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.y=peek!(double, Endian.bigEndian)(_buffer, _index); }if(_buffer.length>=*_index+double.sizeof){ position.z=peek!(double, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ yaw=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ pitch=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+bool.sizeof){ onGround=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}

struct EntityProperties {

	public enum uint ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public sul.protocol.minecraft107.types.Property[] properties;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer.length+=uint.sizeof; write!(uint, Endian.bigEndian)(_buffer, properties.length.to!uint, _buffer.length-uint.sizeof); foreach(cHJvcGVydGllcw;properties){ cHJvcGVydGllcw.encode(_buffer); }
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+uint.sizeof){ properties.length=peek!(uint, Endian.bigEndian)(_buffer, _index); } foreach(ref cHJvcGVydGllcw;properties){ cHJvcGVydGllcw.decode(_buffer, _index); }
		return this;
	}

}

struct EntityEffect {

	public enum uint ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public uint entityId;
	public ubyte effectId;
	public ubyte amplifier;
	public uint duration;
	public bool hideParticles;

	public ubyte[] encode(bool writeId=true)() {
		ubyte[] _buffer;
		static if(writeId){ _buffer~=varuint.encode(ID); }
		_buffer~=varuint.encode(entityId);
		_buffer~=effectId;
		_buffer~=amplifier;
		_buffer~=varuint.encode(duration);
		_buffer.length+=bool.sizeof; write!(bool, Endian.bigEndian)(_buffer, hideParticles, _buffer.length-bool.sizeof);
		return _buffer;
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t _index=0) {
		return this.decode!readId(_buffer, &_index);
	}

	public typeof(this) decode(bool readId=true)(ubyte[] _buffer, size_t* _index) {
		static if(readId){ typeof(ID) _id; _id=varuint.decode(_buffer, *_index); }
		entityId=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+ubyte.sizeof){ effectId=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		if(_buffer.length>=*_index+ubyte.sizeof){ amplifier=peek!(ubyte, Endian.bigEndian)(_buffer, _index); }
		duration=varuint.decode(_buffer, *_index);
		if(_buffer.length>=*_index+bool.sizeof){ hideParticles=peek!(bool, Endian.bigEndian)(_buffer, _index); }
		return this;
	}

}
