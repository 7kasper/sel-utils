/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
/** @module sul/protocol/raknet8/unconnected */

//import Types from 'types';

const Unconnected = {

	Ping: class {

		static get ID(){ return 1; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(pingId=0, magic=[]) {
			this.pingId = pingId;
			this.magic = magic;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianLong(pingId);
			for(bwfnawm in magic){ this.writeByte(magic[bwfnawm]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Unconnected.Ping().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Ping(pingId: " + this.pingId + ", magic: " + this.magic + ")";
		}

	},

	Pong: class {

		static get ID(){ return 28; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(pingId=0, serverId=0, magic=[], status="") {
			this.pingId = pingId;
			this.serverId = serverId;
			this.magic = magic;
			this.status = status;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianLong(pingId);
			this.writeBigEndianLong(serverId);
			for(bwfnawm in magic){ this.writeByte(magic[bwfnawm]); }
			this.writeString(status);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Unconnected.Pong().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Pong(pingId: " + this.pingId + ", serverId: " + this.serverId + ", magic: " + this.magic + ", status: " + this.status + ")";
		}

	},

	OpenConnectionRequest1: class {

		static get ID(){ return 5; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(magic=[], protocol=0, mtu=null) {
			this.magic = magic;
			this.protocol = protocol;
			this.mtu = mtu;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			for(bwfnawm in magic){ this.writeByte(magic[bwfnawm]); }
			this.writeByte(protocol);
			this.writeBytes(mtu);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Unconnected.OpenConnectionRequest1().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "OpenConnectionRequest1(magic: " + this.magic + ", protocol: " + this.protocol + ", mtu: " + this.mtu + ")";
		}

	},

	OpenConnectionReply1: class {

		static get ID(){ return 6; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(magic=[], serverId=0, security=false, mtuLength=0) {
			this.magic = magic;
			this.serverId = serverId;
			this.security = security;
			this.mtuLength = mtuLength;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			for(bwfnawm in magic){ this.writeByte(magic[bwfnawm]); }
			this.writeBigEndianLong(serverId);
			this.writeBool(security);
			this.writeBigEndianShort(mtuLength);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Unconnected.OpenConnectionReply1().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "OpenConnectionReply1(magic: " + this.magic + ", serverId: " + this.serverId + ", security: " + this.security + ", mtuLength: " + this.mtuLength + ")";
		}

	},

	OpenConnectionRequest2: class {

		static get ID(){ return 7; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(magic=[], serverAddress=null, mtuLength=0, clientId=0) {
			this.magic = magic;
			this.serverAddress = serverAddress;
			this.mtuLength = mtuLength;
			this.clientId = clientId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			for(bwfnawm in magic){ this.writeByte(magic[bwfnawm]); }
			this.writeBytes(serverAddress.encode());
			this.writeBigEndianShort(mtuLength);
			this.writeBigEndianLong(clientId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Unconnected.OpenConnectionRequest2().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "OpenConnectionRequest2(magic: " + this.magic + ", serverAddress: " + this.serverAddress + ", mtuLength: " + this.mtuLength + ", clientId: " + this.clientId + ")";
		}

	},

	OpenConnectionReply2: class {

		static get ID(){ return 8; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(magic=[], serverId=0, clientAddress=null, mtuLength=0, security=false) {
			this.magic = magic;
			this.serverId = serverId;
			this.clientAddress = clientAddress;
			this.mtuLength = mtuLength;
			this.security = security;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			for(bwfnawm in magic){ this.writeByte(magic[bwfnawm]); }
			this.writeBigEndianLong(serverId);
			this.writeBytes(clientAddress.encode());
			this.writeBigEndianShort(mtuLength);
			this.writeBool(security);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Unconnected.OpenConnectionReply2().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "OpenConnectionReply2(magic: " + this.magic + ", serverId: " + this.serverId + ", clientAddress: " + this.clientAddress + ", mtuLength: " + this.mtuLength + ", security: " + this.security + ")";
		}

	},

}

//export { Unconnected };
