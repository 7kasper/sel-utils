/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
/** @module sul/protocol/raknet8/types */

const Types = {

	Address: class {

		constructor(type=0, ipv4=0, ipv6=[], port=0) {
			this.type = type;
			this.ipv4 = ipv4;
			this.ipv6 = ipv6;
			this.port = port;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(type);
			this.writeBigEndianInt(ipv4);
			for(axb2ng in ipv6){ this.writeByte(ipv6[axb2ng]); }
			this.writeBigEndianShort(port);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		/** @return {string} */
		toString() {
			return "Address(type: " + this.type + ", ipv4: " + this.ipv4 + ", ipv6: " + this.ipv6 + ", port: " + this.port + ")";
		}

	},

	Acknowledge: class {

		constructor(unique=false, first=0, last=0) {
			this.unique = unique;
			this.first = first;
			this.last = last;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeBool(unique);
			this.writeLittleEndianTriad(first);
			this.writeLittleEndianTriad(last);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		/** @return {string} */
		toString() {
			return "Acknowledge(unique: " + this.unique + ", first: " + this.first + ", last: " + this.last + ")";
		}

	},

	Encapsulation: class {

		constructor(info=0, length=0, messageIndex=0, orderIndex=0, orderChannel=0, split=null, payload=null) {
			this.info = info;
			this.length = length;
			this.messageIndex = messageIndex;
			this.orderIndex = orderIndex;
			this.orderChannel = orderChannel;
			this.split = split;
			this.payload = payload;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(info);
			this.writeBigEndianShort(length);
			this.writeLittleEndianTriad(messageIndex);
			this.writeLittleEndianTriad(orderIndex);
			this.writeByte(orderChannel);
			this.writeBytes(split.encode());
			this.writeBytes(payload);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		/** @return {string} */
		toString() {
			return "Encapsulation(info: " + this.info + ", length: " + this.length + ", messageIndex: " + this.messageIndex + ", orderIndex: " + this.orderIndex + ", orderChannel: " + this.orderChannel + ", split: " + this.split + ", payload: " + this.payload + ")";
		}

	},

	Split: class {

		constructor(count=0, id=0, order=0) {
			this.count = count;
			this.id = id;
			this.order = order;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeBigEndianInt(count);
			this.writeBigEndianShort(id);
			this.writeBigEndianInt(order);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		/** @return {string} */
		toString() {
			return "Split(count: " + this.count + ", id: " + this.id + ", order: " + this.order + ")";
		}

	}

}

export { Types }
