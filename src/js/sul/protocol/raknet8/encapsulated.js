/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
/** @module sul/protocol/raknet8/encapsulated */

//import Types from 'types';

const Encapsulated = {

	ClientConnect: class {

		static get ID(){ return 9; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(clientId=0, pingId=0) {
			this.clientId = clientId;
			this.pingId = pingId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianLong(clientId);
			this.writeBigEndianLong(pingId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.ClientConnect().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ClientConnect(clientId: " + this.clientId + ", pingId: " + this.pingId + ")";
		}

	},

	ServerHandshake: class {

		static get ID(){ return 16; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(clientAddress=null, mtuLength=0, systemAddresses=[], pingId=0, serverId=0) {
			this.clientAddress = clientAddress;
			this.mtuLength = mtuLength;
			this.systemAddresses = systemAddresses;
			this.pingId = pingId;
			this.serverId = serverId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(clientAddress.encode());
			this.writeBigEndianShort(mtuLength);
			for(c3lzdgvtqwrkcmvz in systemAddresses){ this.writeBytes(systemAddresses[c3lzdgvtqwrkcmvz].encode()); }
			this.writeBigEndianLong(pingId);
			this.writeBigEndianLong(serverId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.ServerHandshake().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ServerHandshake(clientAddress: " + this.clientAddress + ", mtuLength: " + this.mtuLength + ", systemAddresses: " + this.systemAddresses + ", pingId: " + this.pingId + ", serverId: " + this.serverId + ")";
		}

	},

	ClientHandshake: class {

		static get ID(){ return 19; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(clientAddress=null, systemAddresses=[], pingId=0, clientId=0) {
			this.clientAddress = clientAddress;
			this.systemAddresses = systemAddresses;
			this.pingId = pingId;
			this.clientId = clientId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(clientAddress.encode());
			for(c3lzdgvtqwrkcmvz in systemAddresses){ this.writeBytes(systemAddresses[c3lzdgvtqwrkcmvz].encode()); }
			this.writeBigEndianLong(pingId);
			this.writeBigEndianLong(clientId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.ClientHandshake().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ClientHandshake(clientAddress: " + this.clientAddress + ", systemAddresses: " + this.systemAddresses + ", pingId: " + this.pingId + ", clientId: " + this.clientId + ")";
		}

	},

	ClientCancelConnection: class {

		static get ID(){ return 21; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor() {
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.ClientCancelConnection().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ClientCancelConnection()";
		}

	},

	Ping: class {

		static get ID(){ return 0; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(time=0) {
			this.time = time;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianLong(time);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.Ping().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Ping(time: " + this.time + ")";
		}

	},

	Pong: class {

		static get ID(){ return 3; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(time=0) {
			this.time = time;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianLong(time);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.Pong().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Pong(time: " + this.time + ")";
		}

	},

	Mcpe: class {

		static get ID(){ return 254; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(packet=null) {
			this.packet = packet;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(packet);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Encapsulated.Mcpe().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Mcpe(packet: " + this.packet + ")";
		}

	},

}

//export { Encapsulated };
