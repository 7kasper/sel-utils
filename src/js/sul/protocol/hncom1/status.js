/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
/** @module sul/protocol/hncom1/status */

//import Types from 'types';

/**
 * Node-related packets and updates.
 */
const Status = {

	/**
	 * Notifies the node that another node (that is not itelf) has connected to the hub.
	 */
	AddNode: class {

		static get ID(){ return 4; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		/**
		 * @param hubId
		 *        Identifier given by the hub to uniquey identify the node.
		 * @param name
		 *        Node's name used for displaying and identification purposes.
		 * @param main
		 *        Whether the node is a main node (see ConnectionRequest.main).
		 * @param acceptedGames
		 *        Indicates the game accepted by the node.
		 */
		constructor(hubId=0, name="", main=false, acceptedGames=[]) {
			this.hubId = hubId;
			this.name = name;
			this.main = main;
			this.acceptedGames = acceptedGames;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(hubId);
			this.writeString(name);
			this.writeBool(main);
			this.writeVaruint(acceptedGames.length); for(ywnjzxb0zwrhyw1l in acceptedGames){ this.writeBytes(acceptedGames[ywnjzxb0zwrhyw1l].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.AddNode().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddNode(hubId: " + this.hubId + ", name: " + this.name + ", main: " + this.main + ", acceptedGames: " + this.acceptedGames + ")";
		}

	},

	/**
	 * Notifies the node that another node, previously added with AddNode has disconnected
	 * from the hub.
	 */
	RemoveNode: class {

		static get ID(){ return 5; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		/**
		 * @param hubId
		 *        Node's id given by the hub.
		 */
		constructor(hubId=0) {
			this.hubId = hubId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(hubId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.RemoveNode().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "RemoveNode(hubId: " + this.hubId + ")";
		}

	},

	/**
	 * Sends a binary message to some selected nodes or broadcast it.
	 */
	MessageServerbound: class {

		static get ID(){ return 6; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		/**
		 * @param addressees
		 *        Addressees of the message. If the array is empty the message is broadcasted to every connected node.
		 * @param payload
		 *        Bytes to be sent/broadcasted. It may be a serialised packet of a plugin-defined protocol.
		 */
		constructor(addressees=0, payload=[]) {
			this.addressees = addressees;
			this.payload = payload;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(addressees.length); for(ywrkcmvzc2vlcw in addressees){ this.writeVaruint(addressees[ywrkcmvzc2vlcw]); }
			this.writeVaruint(payload.length); for(cgf5bg9hza in payload){ this.writeByte(payload[cgf5bg9hza]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.MessageServerbound().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MessageServerbound(addressees: " + this.addressees + ", payload: " + this.payload + ")";
		}

	},

	/**
	 * Receives a binary message sent by another node using MessageServerbound.
	 */
	MessageClientbound: class {

		static get ID(){ return 7; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		/**
		 * @param sender
		 *        Id of the node that has sent the message.
		 * @param payload
		 *        Bytes received. It could be a serialised packet of a plugin-defined packet.
		 */
		constructor(sender=0, payload=[]) {
			this.sender = sender;
			this.payload = payload;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(sender);
			this.writeVaruint(payload.length); for(cgf5bg9hza in payload){ this.writeByte(payload[cgf5bg9hza]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.MessageClientbound().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MessageClientbound(sender: " + this.sender + ", payload: " + this.payload + ")";
		}

	},

	/**
	 * Updates the number of players on the server.
	 */
	Players: class {

		static get ID(){ return 8; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// max
		static get UNLIMITED(){ return -1; }

		/**
		 * @param online
		 *        Players currently online in the whole server (connected to a node).
		 * @param max
		 *        Maximum number of players that can connect to server.
		 */
		constructor(online=0, max=0) {
			this.online = online;
			this.max = max;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(online);
			this.writeVarint(max);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.Players().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Players(online: " + this.online + ", max: " + this.max + ")";
		}

	},

	/**
	 * Updates the usage of the system's resources of the node.
	 */
	ResourcesUsage: class {

		static get ID(){ return 9; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		/**
		 * @param tps
		 *        Ticks per second of the node, in the range 0 to 20, where a number lower than 20 indicates lag.
		 * @param ram
		 *        RAM used by the node in bytes.
		 * @param cpu
		 *        Percentage of CPU used by the node. It may be higher than 100 if the node has more than 1 CPU.
		 */
		constructor(tps=.0, ram=0, cpu=.0) {
			this.tps = tps;
			this.ram = ram;
			this.cpu = cpu;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianFloat(tps);
			this.writeVarulong(ram);
			this.writeBigEndianFloat(cpu);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.ResourcesUsage().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ResourcesUsage(tps: " + this.tps + ", ram: " + this.ram + ", cpu: " + this.cpu + ")";
		}

	},

	/**
	 * Sends a log to the hub.
	 */
	Log: class {

		static get ID(){ return 10; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		/**
		 * @param timestamp
		 *        Unix time (in milliseconds) that indicates the exact creation time of the log.
		 * @param logger
		 *        Name of the logger (world, plugin or module/packet) thas has generated the log.
		 * @param message
		 *        Logged message. It may contain Minecraft formatting codes.
		 * @param commandId
		 *        Identifier of the command that has generated the output or -1 if the log wasn't generated by a command.
		 */
		constructor(timestamp=0, logger="", message="", commandId=0) {
			this.timestamp = timestamp;
			this.logger = logger;
			this.message = message;
			this.commandId = commandId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarulong(timestamp);
			this.writeString(logger);
			this.writeString(message);
			this.writeVarint(commandId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.Log().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Log(timestamp: " + this.timestamp + ", logger: " + this.logger + ", message: " + this.message + ", commandId: " + this.commandId + ")";
		}

	},

	/**
	 * Executes a command on the node.
	 */
	RemoteCommand: class {

		static get ID(){ return 11; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// origin
		static get HUB(){ return 0; }
		static get EXTERNAL_CONSOLE(){ return 1; }
		static get RCON(){ return 2; }

		/**
		 * @param origin
		 *        Origin of the command. It could be the hub itself or an external source.
		 * @param sender
		 *        Address of the sender if the command has been sent from an external source and not the hub.
		 * @param command
		 *        Commands and arguments that should be executed on the node. For example `say hello world` or `transfer
		 *        steve lobby12`.
		 * @param commandId
		 *        Identifier of the command. It's sent in Log.commandId if the command generates an output.
		 */
		constructor(origin=0, sender=null, command="", commandId=0) {
			this.origin = origin;
			this.sender = sender;
			this.command = command;
			this.commandId = commandId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(origin);
			this.writeBytes(sender.encode());
			this.writeString(command);
			this.writeVarint(commandId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.RemoteCommand().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "RemoteCommand(origin: " + this.origin + ", sender: " + this.sender + ", command: " + this.command + ", commandId: " + this.commandId + ")";
		}

	},

	/**
	 * Updates a list.
	 */
	UpdateList: class {

		static get ID(){ return 12; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// list
		static get WHITELIST(){ return 0; }
		static get BLACKLIST(){ return 1; }

		// action
		static get ADD(){ return 0; }
		static get REMOVE(){ return 1; }

		/**
		 * @param list
		 *        Type of the list to update.
		 */
		constructor(list=0, action=0, type=0) {
			this.list = list;
			this.action = action;
			this.type = type;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(list);
			this.writeByte(action);
			this.writeByte(type);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.UpdateList().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "UpdateList(list: " + this.list + ", action: " + this.action + ", type: " + this.type + ")";
		}

	},

	/**
	 * Notifies the node that the hub's reloadeable settings have been reloaded and that
	 * the node should also reload its resources (for example plugin's settings).
	 */
	Reload: class {

		static get ID(){ return 13; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor() {
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Status.Reload().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Reload()";
		}

	},

}

//export { Status };
