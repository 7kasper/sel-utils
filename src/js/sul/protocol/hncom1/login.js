/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom1.xml
 */
/** @module sul/protocol/hncom1/login */

//import Types from 'types';

/**
 * Packets used during the authentication process to exchange informations.
 */
const Login = {

	/**
	 * First real packet sent by the client with its informations.
	 */
	ConnectionRequest: class {

		static get ID(){ return 0; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		/**
		 * @param protocol
		 *        Version of the protocol used by the client that must match the hub's one
		 * @param password
		 *        Password, if the hub requires one, or an empty string.
		 * @param name
		 *        Name of the node that will be validated by the hub. It should always be lowercase and only contain
		 *        letters, numbers and basic punctuation symbols.
		 * @param main
		 *        Indicates whether the node accepts clients when they first connect to the hub or exclusively when
		 *        they are manually transferred.
		 */
		constructor(protocol=0, password="", name="", main=false) {
			this.protocol = protocol;
			this.password = password;
			this.name = name;
			this.main = main;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(protocol);
			this.writeString(password);
			this.writeString(name);
			this.writeBool(main);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Login.ConnectionRequest().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ConnectionRequest(protocol: " + this.protocol + ", password: " + this.password + ", name: " + this.name + ", main: " + this.main + ")";
		}

	},

	/**
	 * Reply always sent after the ConnectionRequest packet. It indicates the status of
	 * the connection, which is accepted only when every field of the packet is true.
	 */
	ConnectionResponse: class {

		static get ID(){ return 1; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// status
		static get OK(){ return 0; }
		static get OUTDATED_HUB(){ return 1; }
		static get OUTDATED_NODE(){ return 2; }
		static get PASSWORD_REQUIRED(){ return 3; }
		static get WRONG_PASSWORD(){ return 4; }
		static get INVALID_NAME_LENGTH(){ return 5; }
		static get INVALID_NAME_CHARACTERS(){ return 6; }
		static get NAME_ALREADY_USED(){ return 7; }
		static get NAME_RESERVED(){ return 8; }

		/**
		 * @param protocol
		 *        Protocol used by the hub. It must match the node's one otherwise the connection cannot be established.
		 * @param status
		 *        Indicates the status of connection. If not 0, it indicates an error.
		 */
		constructor(protocol=0, status=0) {
			this.protocol = protocol;
			this.status = status;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(protocol);
			this.writeByte(status);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Login.ConnectionResponse().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ConnectionResponse(protocol: " + this.protocol + ", status: " + this.status + ")";
		}

	},

	/**
	 * Informations about the hub.
	 */
	HubInfo: class {

		static get ID(){ return 2; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// max
		static get UNLIMITED(){ return -1; }

		/**
		 * @param time
		 *        Unix time in microseconds precision that indicates the exact moment when this packet was created.
		 *        It's used by the node to calculate the latency.
		 * @param serverId
		 *        Server's id, either given by a snoop system or randomly generated at runtime.
		 * @param reservedUuids
		 *        First number of the 4,294,967,296 (2³²) reserved by the hub to create the node's UUIDs. Every
		 *        UUID generated by the node is formed by the server's id (most signicant) and the next reserved uuid
		 *        (least significant). This way every UUID in the hub and in the connected nodes is always different.
		 * @param displayName
		 *        Unformatted name of the server as indicated in the hub's configuration file.
		 * @param onlineMode
		 *        Indicates whether the player are authenticated using the games' official authentication services
		 *        and their identity should be trusted.
		 * @param gamesInfo
		 *        Informations about the games supported by the hub.
		 * @param online
		 *        Number of players currently online and connected to other nodes.
		 * @param max
		 *        Number of maximum players that can connect to the server. The number may change after this node connects.
		 * @param language
		 *        Default server's language in format (language_COUNTRY, e.g. en_GB) and also the default language
		 *        for players that don't specify their language or for the ones which language is not supported by
		 *        the server.
		 * @param acceptedLanguages
		 *        Languages accepted by the server in the same format as language. The list should always contain
		 *        at least one element (the default language).
		 * @param socialJson
		 *        Optional informations about the server's website and social accounts in the format indicated
		 *        below.```json{   "website": "example.com",   "facebook": "example-official",   "twitter": "example_tweets",
		 *          "youtube": "examplechannel",   "instagram": "example",   "google_plus": "example-plus"}```
		 * @param additionalJson
		 *        Optional informations about the server's software, system and options in the format indicated
		 *        below.```json{   "software": {      "name": "SEL",      "version": "1.0.4",      "stable": true   },   "minecraft":
		 *        {      "edu": false,      "realm": true   },   "system": {      "os": "Ubuntu 16.04",      "cpu": "Intel(R) Core(TM) i5-5200U
		 *        CPU @ 2.20GHz",      "cores": 2,      "ram": 2147483648   }}```
		 */
		constructor(time=0, serverId=0, reservedUuids=0, displayName="", onlineMode=false, gamesInfo=[], online=0, max=0, language="", acceptedLanguages=[], socialJson="", additionalJson="") {
			this.time = time;
			this.serverId = serverId;
			this.reservedUuids = reservedUuids;
			this.displayName = displayName;
			this.onlineMode = onlineMode;
			this.gamesInfo = gamesInfo;
			this.online = online;
			this.max = max;
			this.language = language;
			this.acceptedLanguages = acceptedLanguages;
			this.socialJson = socialJson;
			this.additionalJson = additionalJson;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarulong(time);
			this.writeVarulong(serverId);
			this.writeVarulong(reservedUuids);
			this.writeString(displayName);
			this.writeBool(onlineMode);
			this.writeVaruint(gamesInfo.length); for(z2ftzxnjbmzv in gamesInfo){ this.writeBytes(gamesInfo[z2ftzxnjbmzv].encode()); }
			this.writeVaruint(online);
			this.writeVarint(max);
			this.writeString(language);
			this.writeVaruint(acceptedLanguages.length); for(ywnjzxb0zwrmyw5n in acceptedLanguages){ this.writeString(acceptedLanguages[ywnjzxb0zwrmyw5n]); }
			this.writeString(socialJson);
			this.writeString(additionalJson);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Login.HubInfo().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "HubInfo(time: " + this.time + ", serverId: " + this.serverId + ", reservedUuids: " + this.reservedUuids + ", displayName: " + this.displayName + ", onlineMode: " + this.onlineMode + ", gamesInfo: " + this.gamesInfo + ", online: " + this.online + ", max: " + this.max + ", language: " + this.language + ", acceptedLanguages: " + this.acceptedLanguages + ", socialJson: " + this.socialJson + ", additionalJson: " + this.additionalJson + ")";
		}

	},

	/**
	 * Informations about the node.
	 */
	NodeInfo: class {

		static get ID(){ return 3; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// max
		static get UNLIMITED(){ return 0; }

		/**
		 * @param time
		 *        Unix time in microseconds precision that indicates the exact moment when this packet was created.
		 *        It's used by the hub to calculate the latency.
		 * @param max
		 *        Maximum number of players accepted by node.
		 * @param acceptedGames
		 *        Informations about the games accepted by the node. There should be at least one combination of game/protocol
		 *        that is also accepted by hub as indicated in HubInfo.gamesInfo, otherwise the node will never receive
		 *        any player.
		 * @param plugins
		 *        List of plugins loaded on the node for creating queries on the hub.
		 * @param additionalJson
		 *        Optional informations about the server's software and system, similar to HubInfo.additionalJson.```json{
		 *          "software": {      "name": "SEL",      "version": "1.0.4",      "stable": true   },   "system": {      "os": "Windows
		 *        10",      "cpu": "Intel(R) Core(TM) i7-5700U CPU @ 3.40GHz",      "cores": 4,      "ram": 8589934592   }}```
		 */
		constructor(time=0, max=0, acceptedGames=[], plugins=[], additionalJson="") {
			this.time = time;
			this.max = max;
			this.acceptedGames = acceptedGames;
			this.plugins = plugins;
			this.additionalJson = additionalJson;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarulong(time);
			this.writeVaruint(max);
			this.writeVaruint(acceptedGames.length); for(ywnjzxb0zwrhyw1l in acceptedGames){ this.writeBytes(acceptedGames[ywnjzxb0zwrhyw1l].encode()); }
			this.writeVaruint(plugins.length); for(cgx1z2lucw in plugins){ this.writeBytes(plugins[cgx1z2lucw].encode()); }
			this.writeString(additionalJson);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Login.NodeInfo().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "NodeInfo(time: " + this.time + ", max: " + this.max + ", acceptedGames: " + this.acceptedGames + ", plugins: " + this.plugins + ", additionalJson: " + this.additionalJson + ")";
		}

	},

}

//export { Login };
