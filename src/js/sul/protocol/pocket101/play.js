/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket101.xml
 */
/** @module sul/protocol/pocket101/play */

//import Types from 'types';

const Play = {

	/**
	 * First MCPE packet sent after the establishment of the connection through raknet.
	 * It contains informations about the player.
	 */
	Login: class {

		static get ID(){ return 1; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// edition
		static get CLASSIC(){ return 0; }
		static get EDUCATION(){ return 1; }

		/**
		 * @param protocol
		 *        Version of the protocol used by the player.
		 * @param edition
		 *        Edition that the player is using to join the server. The different editions may have different features
		 *        and servers may block the access from unaccepted editions of the game.
		 * @param body
		 *        Zlib-compressed bytes that contains 2 JWTs with more informations about the player and its account.
		 *        Once uncompressed the resulting payload will contain 2 JWTs which length is indicated by a little-endian
		 *        unsigned integer each.
		 */
		constructor(protocol=0, edition=0, body=[]) {
			this.protocol = protocol;
			this.edition = edition;
			this.body = body;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianInt(protocol);
			this.writeByte(edition);
			this.writeVaruint(body.length); for(ym9keq in body){ this.writeByte(body[ym9keq]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Login().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Login(protocol: " + this.protocol + ", edition: " + this.edition + ", body: " + this.body + ")";
		}

	},

	PlayStatus: class {

		static get ID(){ return 2; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// status
		static get OK(){ return 0; }
		static get OUTDATED_CLIENT(){ return 1; }
		static get OUTDATED_SERVER(){ return 2; }
		static get SPAWNED(){ return 3; }
		static get INVALID_TENANT(){ return 4; }
		static get EDITION_MISMATCH(){ return 5; }

		constructor(status=0) {
			this.status = status;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianInt(status);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.PlayStatus().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "PlayStatus(status: " + this.status + ")";
		}

	},

	ServerHandshake: class {

		static get ID(){ return 3; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(serverPublicKey="", token=[]) {
			this.serverPublicKey = serverPublicKey;
			this.token = token;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(serverPublicKey);
			this.writeVaruint(token.length); for(dg9rzw4 in token){ this.writeByte(token[dg9rzw4]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ServerHandshake().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ServerHandshake(serverPublicKey: " + this.serverPublicKey + ", token: " + this.token + ")";
		}

	},

	ClientMagic: class {

		static get ID(){ return 4; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor() {
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ClientMagic().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ClientMagic()";
		}

	},

	Disconnect: class {

		static get ID(){ return 5; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(hideDisconnectionScreen=false, message="") {
			this.hideDisconnectionScreen = hideDisconnectionScreen;
			this.message = message;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBool(hideDisconnectionScreen);
			this.writeString(message);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Disconnect().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Disconnect(hideDisconnectionScreen: " + this.hideDisconnectionScreen + ", message: " + this.message + ")";
		}

	},

	Batch: class {

		static get ID(){ return 6; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(data=[]) {
			this.data = data;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(data.length); for(zgf0yq in data){ this.writeByte(data[zgf0yq]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Batch().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Batch(data: " + this.data + ")";
		}

	},

	ResourcePacksInfo: class {

		static get ID(){ return 7; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(mustAccept=false, behaviourPacks=[], resourcePacks=[]) {
			this.mustAccept = mustAccept;
			this.behaviourPacks = behaviourPacks;
			this.resourcePacks = resourcePacks;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBool(mustAccept);
			this.writeVaruint(behaviourPacks.length); for(ymvoyxzpb3vyugfj in behaviourPacks){ this.writeBytes(behaviourPacks[ymvoyxzpb3vyugfj].encode()); }
			this.writeVaruint(resourcePacks.length); for(cmvzb3vyy2vqywnr in resourcePacks){ this.writeBytes(resourcePacks[cmvzb3vyy2vqywnr].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ResourcePacksInfo().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ResourcePacksInfo(mustAccept: " + this.mustAccept + ", behaviourPacks: " + this.behaviourPacks + ", resourcePacks: " + this.resourcePacks + ")";
		}

	},

	ResourcePackClientResponse: class {

		static get ID(){ return 9; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(status=0, resourcePackVersion=0) {
			this.status = status;
			this.resourcePackVersion = resourcePackVersion;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(status);
			this.writeBigEndianShort(resourcePackVersion);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ResourcePackClientResponse().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ResourcePackClientResponse(status: " + this.status + ", resourcePackVersion: " + this.resourcePackVersion + ")";
		}

	},

	Text: class {

		static get ID(){ return 10; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(type=0) {
			this.type = type;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(type);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Text().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Text(type: " + this.type + ")";
		}

	},

	SetTime: class {

		static get ID(){ return 11; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(time=0, daylightCycle=false) {
			this.time = time;
			this.daylightCycle = daylightCycle;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(time);
			this.writeBool(daylightCycle);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetTime().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetTime(time: " + this.time + ", daylightCycle: " + this.daylightCycle + ")";
		}

	},

	StartGame: class {

		static get ID(){ return 12; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// dimension
		static get OVERWORLD(){ return 0; }
		static get NETHER(){ return 1; }
		static get END(){ return 2; }

		// generator
		static get OLD(){ return 0; }
		static get INFINITE(){ return 1; }
		static get FLAT(){ return 2; }

		// world gamemode
		static get SURVIVAL(){ return 0; }
		static get CREATIVE(){ return 1; }

		// difficulty
		static get PEACEFUL(){ return 0; }
		static get EASY(){ return 1; }
		static get NORMAL(){ return 2; }
		static get HARD(){ return 3; }

		// edition
		static get CLASSIC(){ return 0; }
		static get EDUCATION(){ return 1; }

		constructor(entityId=0, runtimeId=0, position={x:0,y:0,z:0}, yaw=.0, pitch=.0, seed=0, dimension=0, generator=0, worldGamemode=0, difficulty=0, spawnPosition=0, loadedInCreative=false, time=0, edition=0, rainLevel=.0, lightingLevel=.0, cheatsEnabled=false, textureRequired=false, levelId="", worldName="") {
			this.entityId = entityId;
			this.runtimeId = runtimeId;
			this.position = position;
			this.yaw = yaw;
			this.pitch = pitch;
			this.seed = seed;
			this.dimension = dimension;
			this.generator = generator;
			this.worldGamemode = worldGamemode;
			this.difficulty = difficulty;
			this.spawnPosition = spawnPosition;
			this.loadedInCreative = loadedInCreative;
			this.time = time;
			this.edition = edition;
			this.rainLevel = rainLevel;
			this.lightingLevel = lightingLevel;
			this.cheatsEnabled = cheatsEnabled;
			this.textureRequired = textureRequired;
			this.levelId = levelId;
			this.worldName = worldName;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarlong(runtimeId);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeLittleEndianFloat(yaw);
			this.writeLittleEndianFloat(pitch);
			this.writeVarint(seed);
			this.writeVarint(dimension);
			this.writeVarint(generator);
			this.writeVarint(worldGamemode);
			this.writeVarint(difficulty);
			this.writeVarint(spawnPosition.x); this.writeVarint(spawnPosition.y); this.writeVarint(spawnPosition.z);
			this.writeBool(loadedInCreative);
			this.writeVarint(time);
			this.writeByte(edition);
			this.writeLittleEndianFloat(rainLevel);
			this.writeLittleEndianFloat(lightingLevel);
			this.writeBool(cheatsEnabled);
			this.writeBool(textureRequired);
			this.writeString(levelId);
			this.writeString(worldName);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.StartGame().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "StartGame(entityId: " + this.entityId + ", runtimeId: " + this.runtimeId + ", position: " + this.position + ", yaw: " + this.yaw + ", pitch: " + this.pitch + ", seed: " + this.seed + ", dimension: " + this.dimension + ", generator: " + this.generator + ", worldGamemode: " + this.worldGamemode + ", difficulty: " + this.difficulty + ", spawnPosition: " + this.spawnPosition + ", loadedInCreative: " + this.loadedInCreative + ", time: " + this.time + ", edition: " + this.edition + ", rainLevel: " + this.rainLevel + ", lightingLevel: " + this.lightingLevel + ", cheatsEnabled: " + this.cheatsEnabled + ", textureRequired: " + this.textureRequired + ", levelId: " + this.levelId + ", worldName: " + this.worldName + ")";
		}

	},

	AddPlayer: class {

		static get ID(){ return 13; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(uuid=new Uint8Array(16), username="", entityId=0, runtimeId=0, position={x:0,y:0,z:0}, motion={x:0,y:0,z:0}, pitch=.0, headYaw=.0, yaw=.0, heldItem=null, metadata=null) {
			this.uuid = uuid;
			this.username = username;
			this.entityId = entityId;
			this.runtimeId = runtimeId;
			this.position = position;
			this.motion = motion;
			this.pitch = pitch;
			this.headYaw = headYaw;
			this.yaw = yaw;
			this.heldItem = heldItem;
			this.metadata = metadata;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBigEndianLong(uuid.getLeastSignificantBits()); this.writeBigEndianLong(uuid.getMostSignificantBits());
			this.writeString(username);
			this.writeVarlong(entityId);
			this.writeVarlong(runtimeId);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeLittleEndianFloat(motion.x); this.writeLittleEndianFloat(motion.y); this.writeLittleEndianFloat(motion.z);
			this.writeLittleEndianFloat(pitch);
			this.writeLittleEndianFloat(headYaw);
			this.writeLittleEndianFloat(yaw);
			this.writeBytes(heldItem.encode());
			this.writeBytes(metadata.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AddPlayer().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddPlayer(uuid: " + this.uuid + ", username: " + this.username + ", entityId: " + this.entityId + ", runtimeId: " + this.runtimeId + ", position: " + this.position + ", motion: " + this.motion + ", pitch: " + this.pitch + ", headYaw: " + this.headYaw + ", yaw: " + this.yaw + ", heldItem: " + this.heldItem + ", metadata: " + this.metadata + ")";
		}

	},

	AddEntity: class {

		static get ID(){ return 14; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, runtimeId=0, type=0, position={x:0,y:0,z:0}, motion={x:0,y:0,z:0}, pitch=.0, yaw=.0, attributes=[], metadata=null, links=0) {
			this.entityId = entityId;
			this.runtimeId = runtimeId;
			this.type = type;
			this.position = position;
			this.motion = motion;
			this.pitch = pitch;
			this.yaw = yaw;
			this.attributes = attributes;
			this.metadata = metadata;
			this.links = links;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarlong(runtimeId);
			this.writeVaruint(type);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeLittleEndianFloat(motion.x); this.writeLittleEndianFloat(motion.y); this.writeLittleEndianFloat(motion.z);
			this.writeLittleEndianFloat(pitch);
			this.writeLittleEndianFloat(yaw);
			this.writeVaruint(attributes.length); for(yxr0cmlidxrlcw in attributes){ this.writeBytes(attributes[yxr0cmlidxrlcw].encode()); }
			this.writeBytes(metadata.encode());
			this.writeVaruint(links.length); for(bglua3m in links){ this.writeVarlong(links[bglua3m]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AddEntity().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddEntity(entityId: " + this.entityId + ", runtimeId: " + this.runtimeId + ", type: " + this.type + ", position: " + this.position + ", motion: " + this.motion + ", pitch: " + this.pitch + ", yaw: " + this.yaw + ", attributes: " + this.attributes + ", metadata: " + this.metadata + ", links: " + this.links + ")";
		}

	},

	RemoveEntity: class {

		static get ID(){ return 15; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0) {
			this.entityId = entityId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.RemoveEntity().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "RemoveEntity(entityId: " + this.entityId + ")";
		}

	},

	AddItemEntity: class {

		static get ID(){ return 16; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, runtimeId=0, item=null, position={x:0,y:0,z:0}, motion={x:0,y:0,z:0}) {
			this.entityId = entityId;
			this.runtimeId = runtimeId;
			this.item = item;
			this.position = position;
			this.motion = motion;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarlong(runtimeId);
			this.writeBytes(item.encode());
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeLittleEndianFloat(motion.x); this.writeLittleEndianFloat(motion.y); this.writeLittleEndianFloat(motion.z);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AddItemEntity().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddItemEntity(entityId: " + this.entityId + ", runtimeId: " + this.runtimeId + ", item: " + this.item + ", position: " + this.position + ", motion: " + this.motion + ")";
		}

	},

	AddHangingEntity: class {

		static get ID(){ return 17; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, runtimeId=0, position=null, unknown3=0) {
			this.entityId = entityId;
			this.runtimeId = runtimeId;
			this.position = position;
			this.unknown3 = unknown3;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarlong(runtimeId);
			this.writeBytes(position.encode());
			this.writeVarint(unknown3);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AddHangingEntity().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddHangingEntity(entityId: " + this.entityId + ", runtimeId: " + this.runtimeId + ", position: " + this.position + ", unknown3: " + this.unknown3 + ")";
		}

	},

	TakeItemEntity: class {

		static get ID(){ return 18; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(taken=0, collector=0) {
			this.taken = taken;
			this.collector = collector;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(taken);
			this.writeVarlong(collector);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.TakeItemEntity().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "TakeItemEntity(taken: " + this.taken + ", collector: " + this.collector + ")";
		}

	},

	MoveEntity: class {

		static get ID(){ return 19; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, position={x:0,y:0,z:0}, pitch=0, headYaw=0, yaw=0) {
			this.entityId = entityId;
			this.position = position;
			this.pitch = pitch;
			this.headYaw = headYaw;
			this.yaw = yaw;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeByte(pitch);
			this.writeByte(headYaw);
			this.writeByte(yaw);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.MoveEntity().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MoveEntity(entityId: " + this.entityId + ", position: " + this.position + ", pitch: " + this.pitch + ", headYaw: " + this.headYaw + ", yaw: " + this.yaw + ")";
		}

	},

	MovePlayer: class {

		static get ID(){ return 20; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		// animation
		static get FULL(){ return 0; }
		static get NONE(){ return 1; }
		static get ROTATION(){ return 2; }

		constructor(entityId=0, position={x:0,y:0,z:0}, pitch=.0, headYaw=.0, yaw=.0, animation=0, onGround=false) {
			this.entityId = entityId;
			this.position = position;
			this.pitch = pitch;
			this.headYaw = headYaw;
			this.yaw = yaw;
			this.animation = animation;
			this.onGround = onGround;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeLittleEndianFloat(pitch);
			this.writeLittleEndianFloat(headYaw);
			this.writeLittleEndianFloat(yaw);
			this.writeByte(animation);
			this.writeBool(onGround);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.MovePlayer().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MovePlayer(entityId: " + this.entityId + ", position: " + this.position + ", pitch: " + this.pitch + ", headYaw: " + this.headYaw + ", yaw: " + this.yaw + ", animation: " + this.animation + ", onGround: " + this.onGround + ")";
		}

	},

	RiderJump: class {

		static get ID(){ return 21; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(rider=0) {
			this.rider = rider;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(rider);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.RiderJump().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "RiderJump(rider: " + this.rider + ")";
		}

	},

	RemoveBlock: class {

		static get ID(){ return 22; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(position=null) {
			this.position = position;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(position.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.RemoveBlock().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "RemoveBlock(position: " + this.position + ")";
		}

	},

	UpdateBlock: class {

		static get ID(){ return 23; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// flags and meta
		static get NEIGHBORS(){ return 1; }
		static get NETWORK(){ return 2; }
		static get NO_GRAPHIC(){ return 4; }
		static get PRIORITY(){ return 8; }

		constructor(position=null, block=0, flagsAndMeta=0) {
			this.position = position;
			this.block = block;
			this.flagsAndMeta = flagsAndMeta;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(position.encode());
			this.writeVaruint(block);
			this.writeVaruint(flagsAndMeta);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.UpdateBlock().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "UpdateBlock(position: " + this.position + ", block: " + this.block + ", flagsAndMeta: " + this.flagsAndMeta + ")";
		}

	},

	AddPainting: class {

		static get ID(){ return 24; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, runtimeId=0, position=null, direction=0, title="") {
			this.entityId = entityId;
			this.runtimeId = runtimeId;
			this.position = position;
			this.direction = direction;
			this.title = title;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarlong(runtimeId);
			this.writeBytes(position.encode());
			this.writeVarint(direction);
			this.writeString(title);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AddPainting().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddPainting(entityId: " + this.entityId + ", runtimeId: " + this.runtimeId + ", position: " + this.position + ", direction: " + this.direction + ", title: " + this.title + ")";
		}

	},

	Explode: class {

		static get ID(){ return 25; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position={x:0,y:0,z:0}, radius=.0, destroyedBlocks=[]) {
			this.position = position;
			this.radius = radius;
			this.destroyedBlocks = destroyedBlocks;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeLittleEndianFloat(radius);
			this.writeVaruint(destroyedBlocks.length); for(zgvzdhjvewvkqmxv in destroyedBlocks){ this.writeBytes(destroyedBlocks[zgvzdhjvewvkqmxv].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Explode().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Explode(position: " + this.position + ", radius: " + this.radius + ", destroyedBlocks: " + this.destroyedBlocks + ")";
		}

	},

	LevelSoundEvent: class {

		static get ID(){ return 26; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		// sound
		static get ITEM_USE_ON(){ return 0; }
		static get HIT(){ return 1; }
		static get STEP(){ return 2; }
		static get JUMP(){ return 3; }
		static get BREAK(){ return 4; }
		static get PLACE(){ return 5; }
		static get HEAVY_STEP(){ return 6; }
		static get GALLOP(){ return 7; }
		static get FALL(){ return 8; }
		static get AMBIENT(){ return 9; }
		static get AMBIENT_BABY(){ return 10; }
		static get AMBIENT_IN_WATER(){ return 11; }
		static get BREATHE(){ return 12; }
		static get DEATH(){ return 13; }
		static get DEATH_IN_WATER(){ return 14; }
		static get DEATH_TO_ZOMBIE(){ return 15; }
		static get HURT(){ return 16; }
		static get HURT_IN_WATER(){ return 17; }
		static get MAD(){ return 18; }
		static get BOOST(){ return 19; }
		static get BOW(){ return 20; }
		static get SQUISH_BIG(){ return 21; }
		static get SQUISH_SMALL(){ return 22; }
		static get FALL_BIG(){ return 23; }
		static get FALL_SMALL(){ return 24; }
		static get SPLASH(){ return 25; }
		static get FIZZ(){ return 26; }
		static get FLAP(){ return 27; }
		static get SWIM(){ return 28; }
		static get DRINK(){ return 29; }
		static get EAT(){ return 30; }
		static get TAKEOFF(){ return 31; }
		static get SHAKE(){ return 32; }
		static get PLOP(){ return 33; }
		static get LAND(){ return 34; }
		static get SADDLE(){ return 35; }
		static get ARMOR(){ return 36; }
		static get ADD_CHEST(){ return 37; }
		static get THROW(){ return 38; }
		static get ATTACK(){ return 39; }
		static get ATTACK_NODAMAGE(){ return 40; }
		static get WARN(){ return 41; }
		static get SHEAR(){ return 42; }
		static get MILK(){ return 43; }
		static get THUNDER(){ return 44; }
		static get EXPLODE(){ return 45; }
		static get FIRE(){ return 46; }
		static get IGNITE(){ return 47; }
		static get FUSE(){ return 48; }
		static get STARE(){ return 49; }
		static get SPAWN(){ return 50; }
		static get SHOOT(){ return 51; }
		static get BREAK_BLOCK(){ return 52; }
		static get REMEDY(){ return 53; }
		static get UNFECT(){ return 54; }
		static get LEVELUP(){ return 55; }
		static get BOW_HIT(){ return 56; }
		static get BULLET_HIT(){ return 57; }
		static get EXTINGUISH_FIRE(){ return 58; }
		static get ITEM_FIZZ(){ return 59; }
		static get CHEST_OPEN(){ return 60; }
		static get CHEST_CLOSED(){ return 61; }
		static get POWER_ON(){ return 62; }
		static get POWER_OFF(){ return 63; }
		static get ATTACH(){ return 64; }
		static get DETACH(){ return 65; }
		static get DENY(){ return 66; }
		static get TRIPOD(){ return 67; }
		static get POP(){ return 68; }
		static get DROP_SLOT(){ return 69; }
		static get NOTE(){ return 70; }
		static get THORNS(){ return 71; }
		static get PISTON_IN(){ return 72; }
		static get PISTON_OUT(){ return 73; }
		static get PORTAL(){ return 74; }
		static get WATER(){ return 75; }
		static get LAVA_POP(){ return 76; }
		static get LAVA(){ return 77; }
		static get BURP(){ return 78; }
		static get BUCKET_FILL_WATER(){ return 79; }
		static get BUCKET_FILL_LAVA(){ return 80; }
		static get BUCKET_EMPTY_WATER(){ return 81; }
		static get BUCKET_EMPTY_LAVA(){ return 82; }
		static get GUARDIAN_FLOP(){ return 83; }
		static get ELDERGUARDIAN_CURSE(){ return 84; }
		static get MOB_WARNING(){ return 85; }
		static get MOB_WARNING_BABY(){ return 86; }
		static get TELEPORT(){ return 87; }
		static get SHULKER_OPEN(){ return 88; }
		static get SHULKER_CLOSE(){ return 89; }
		static get DEFAULT(){ return 90; }
		static get UNDEFINED(){ return 91; }

		constructor(sound=0, position={x:0,y:0,z:0}, volume=0, pitch=0, unknown4=false) {
			this.sound = sound;
			this.position = position;
			this.volume = volume;
			this.pitch = pitch;
			this.unknown4 = unknown4;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(sound);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeVaruint(volume);
			this.writeVarint(pitch);
			this.writeBool(unknown4);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.LevelSoundEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "LevelSoundEvent(sound: " + this.sound + ", position: " + this.position + ", volume: " + this.volume + ", pitch: " + this.pitch + ", unknown4: " + this.unknown4 + ")";
		}

	},

	LevelEvent: class {

		static get ID(){ return 27; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// event id
		static get START_RAIN(){ return 3001; }
		static get START_THUNDER(){ return 3002; }
		static get STOP_RAIN(){ return 3003; }
		static get STOP_THUNDER(){ return 3004; }
		static get SET_DATA(){ return 4000; }
		static get PLAYERS_SLEEPING(){ return 9800; }
		static get BUBBLE(){ return 16385; }
		static get CRITICAL(){ return 16386; }
		static get BLOCK_FORCE_FIELD(){ return 16387; }
		static get SMOKE(){ return 16388; }
		static get EXPLODE(){ return 16389; }
		static get EVAPORATION(){ return 16390; }
		static get FLAME(){ return 16391; }
		static get LAVA(){ return 16392; }
		static get LARGE_SMOKE(){ return 16393; }
		static get REDSTONE(){ return 16394; }
		static get RISING_RED_DUST(){ return 16395; }
		static get ITEM_BREAK(){ return 16396; }
		static get SNOWBALL_POOF(){ return 16397; }
		static get HUGE_EXPLODE(){ return 16398; }
		static get HUGE_EXPLODE_SEED(){ return 16399; }
		static get MOB_FLAME(){ return 16400; }
		static get HEART(){ return 16401; }
		static get TERRAIN(){ return 16402; }
		static get TOWN_AURA(){ return 16403; }
		static get PORTAL(){ return 16404; }
		static get WATER_SPLASH(){ return 16405; }
		static get WATER_WAKE(){ return 16406; }
		static get DRIP_WATER(){ return 16407; }
		static get DRIP_LAVA(){ return 16408; }
		static get FALLING_DUST(){ return 16409; }
		static get MOB_SPELL(){ return 16410; }
		static get MOB_SPELL_AMBIENT(){ return 16411; }
		static get MOB_SPELL_INSTANTANEOUS(){ return 16412; }
		static get INK(){ return 16413; }
		static get SLIME(){ return 16414; }
		static get RAIN_SPLASH(){ return 16415; }
		static get VILLAGER_ANGRY(){ return 16416; }
		static get VILLAGER_HAPPY(){ return 16417; }
		static get ENCHANTMENT_TABLE(){ return 16418; }
		static get TRACKING_EMITTER(){ return 16419; }
		static get NOTE(){ return 16420; }
		static get WITCH_SPELL(){ return 16421; }
		static get CARROT(){ return 16422; }
		static get END_ROD(){ return 16424; }
		static get DRAGON_BREATH(){ return 16425; }
		static get SHOOT(){ return 2000; }
		static get DESTROY(){ return 2001; }

		constructor(eventId=0, position={x:0,y:0,z:0}, data=0) {
			this.eventId = eventId;
			this.position = position;
			this.data = data;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(eventId);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeVarint(data);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.LevelEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "LevelEvent(eventId: " + this.eventId + ", position: " + this.position + ", data: " + this.data + ")";
		}

	},

	BlockEvent: class {

		static get ID(){ return 28; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position=null, data=0) {
			this.position = position;
			this.data = data;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(position.encode());
			for(zgf0yq in data){ this.writeVarint(data[zgf0yq]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.BlockEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "BlockEvent(position: " + this.position + ", data: " + this.data + ")";
		}

	},

	EntityEvent: class {

		static get ID(){ return 29; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		// event id
		static get HURT_ANIMATION(){ return 2; }
		static get DEATH_ANIMATION(){ return 3; }
		static get TAME_FAIL(){ return 6; }
		static get TAME_SUCCESS(){ return 7; }
		static get SHAKE_WET(){ return 8; }
		static get USE_ITEM(){ return 9; }
		static get EAT_GRASS_ANIMATION(){ return 10; }
		static get FISH_HOOK_BUBBLES(){ return 11; }
		static get FISH_HOOK_POSITION(){ return 12; }
		static get FISH_HOOK_HOOK(){ return 13; }
		static get FISH_HOOK_TEASE(){ return 14; }
		static get SQUID_INK_CLOUD(){ return 15; }
		static get AMBIENT_SOUND(){ return 16; }
		static get RESPAWN(){ return 17; }

		constructor(entityId=0, eventId=0, unknown2=0) {
			this.entityId = entityId;
			this.eventId = eventId;
			this.unknown2 = unknown2;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeByte(eventId);
			this.writeVarint(unknown2);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.EntityEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "EntityEvent(entityId: " + this.entityId + ", eventId: " + this.eventId + ", unknown2: " + this.unknown2 + ")";
		}

	},

	MobEffect: class {

		static get ID(){ return 30; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// event id
		static get ADD(){ return 1; }
		static get MODIFY(){ return 2; }
		static get REMOVE(){ return 3; }

		constructor(entityId=0, eventId=0, effect=0, amplifier=0, particles=false, duration=0) {
			this.entityId = entityId;
			this.eventId = eventId;
			this.effect = effect;
			this.amplifier = amplifier;
			this.particles = particles;
			this.duration = duration;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeByte(eventId);
			this.writeVarint(effect);
			this.writeVarint(amplifier);
			this.writeBool(particles);
			this.writeVarint(duration);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.MobEffect().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MobEffect(entityId: " + this.entityId + ", eventId: " + this.eventId + ", effect: " + this.effect + ", amplifier: " + this.amplifier + ", particles: " + this.particles + ", duration: " + this.duration + ")";
		}

	},

	UpdateAttributes: class {

		static get ID(){ return 31; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, attributes=[]) {
			this.entityId = entityId;
			this.attributes = attributes;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVaruint(attributes.length); for(yxr0cmlidxrlcw in attributes){ this.writeBytes(attributes[yxr0cmlidxrlcw].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.UpdateAttributes().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "UpdateAttributes(entityId: " + this.entityId + ", attributes: " + this.attributes + ")";
		}

	},

	/**
	 * Sent when the client puts an item in its hotbar or selects a new hotbar slot.
	 */
	MobEquipment: class {

		static get ID(){ return 32; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		/**
		 * @param inventorySlot
		 *        Slot of the inventory where the item is. The hotbat slots (0-8) are not counted. 255 means that a generic
		 *        empty slot has been selected.
		 * @param hotbarSlot
		 *        Slot of the hotbar where the item is being moved.
		 */
		constructor(entityId=0, item=null, inventorySlot=0, hotbarSlot=0, unknown4=0) {
			this.entityId = entityId;
			this.item = item;
			this.inventorySlot = inventorySlot;
			this.hotbarSlot = hotbarSlot;
			this.unknown4 = unknown4;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeBytes(item.encode());
			this.writeByte(inventorySlot);
			this.writeByte(hotbarSlot);
			this.writeByte(unknown4);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.MobEquipment().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MobEquipment(entityId: " + this.entityId + ", item: " + this.item + ", inventorySlot: " + this.inventorySlot + ", hotbarSlot: " + this.hotbarSlot + ", unknown4: " + this.unknown4 + ")";
		}

	},

	MobArmorEquipment: class {

		static get ID(){ return 33; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(entityId=0, armor=[]) {
			this.entityId = entityId;
			this.armor = armor;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			for(yxjtb3i in armor){ this.writeBytes(armor[yxjtb3i].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.MobArmorEquipment().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MobArmorEquipment(entityId: " + this.entityId + ", armor: " + this.armor + ")";
		}

	},

	Interact: class {

		static get ID(){ return 34; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// action
		static get ATTACK(){ return 1; }
		static get INTERACT(){ return 2; }
		static get LEAVE_VEHICLE(){ return 3; }
		static get HOVER(){ return 4; }

		constructor(action=0, target=0) {
			this.action = action;
			this.target = target;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(action);
			this.writeVarlong(target);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Interact().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Interact(action: " + this.action + ", target: " + this.target + ")";
		}

	},

	UseItem: class {

		static get ID(){ return 35; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(blockPosition=null, hotbarSlot=0, face=0, facePosition={x:0,y:0,z:0}, position={x:0,y:0,z:0}, slot=0, item=null) {
			this.blockPosition = blockPosition;
			this.hotbarSlot = hotbarSlot;
			this.face = face;
			this.facePosition = facePosition;
			this.position = position;
			this.slot = slot;
			this.item = item;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(blockPosition.encode());
			this.writeVaruint(hotbarSlot);
			this.writeVarint(face);
			this.writeLittleEndianFloat(facePosition.x); this.writeLittleEndianFloat(facePosition.y); this.writeLittleEndianFloat(facePosition.z);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeVarint(slot);
			this.writeBytes(item.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.UseItem().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "UseItem(blockPosition: " + this.blockPosition + ", hotbarSlot: " + this.hotbarSlot + ", face: " + this.face + ", facePosition: " + this.facePosition + ", position: " + this.position + ", slot: " + this.slot + ", item: " + this.item + ")";
		}

	},

	PlayerAction: class {

		static get ID(){ return 36; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// action
		static get START_BREAK(){ return 0; }
		static get ABORT_BREAK(){ return 1; }
		static get STOP_BREAK(){ return 2; }
		static get RELEASE_ITEM(){ return 5; }
		static get STOP_SLEEPING(){ return 6; }
		static get RESPAWN(){ return 7; }
		static get JUMP(){ return 8; }
		static get START_SPRINT(){ return 9; }
		static get STOP_SPRINT(){ return 10; }
		static get START_SNEAK(){ return 11; }
		static get STOP_SNEAK(){ return 12; }
		static get START_GLIDING(){ return 15; }
		static get STOP_GLIDING(){ return 16; }

		constructor(entityId=0, action=0, position=null, face=0) {
			this.entityId = entityId;
			this.action = action;
			this.position = position;
			this.face = face;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarint(action);
			this.writeBytes(position.encode());
			this.writeVarint(face);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.PlayerAction().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "PlayerAction(entityId: " + this.entityId + ", action: " + this.action + ", position: " + this.position + ", face: " + this.face + ")";
		}

	},

	PlayerFall: class {

		static get ID(){ return 37; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(distance=.0) {
			this.distance = distance;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeLittleEndianFloat(distance);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.PlayerFall().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "PlayerFall(distance: " + this.distance + ")";
		}

	},

	HurtArmor: class {

		static get ID(){ return 38; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(health=0) {
			this.health = health;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(health);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.HurtArmor().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "HurtArmor(health: " + this.health + ")";
		}

	},

	SetEntityData: class {

		static get ID(){ return 39; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, metadata=null) {
			this.entityId = entityId;
			this.metadata = metadata;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeBytes(metadata.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetEntityData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetEntityData(entityId: " + this.entityId + ", metadata: " + this.metadata + ")";
		}

	},

	SetEntityMotion: class {

		static get ID(){ return 40; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, motion={x:0,y:0,z:0}) {
			this.entityId = entityId;
			this.motion = motion;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeLittleEndianFloat(motion.x); this.writeLittleEndianFloat(motion.y); this.writeLittleEndianFloat(motion.z);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetEntityMotion().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetEntityMotion(entityId: " + this.entityId + ", motion: " + this.motion + ")";
		}

	},

	SetEntityLink: class {

		static get ID(){ return 41; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// action
		static get ADD(){ return 0; }
		static get REMOVE(){ return 1; }

		constructor(from=0, to=0, action=0) {
			this.from = from;
			this.to = to;
			this.action = action;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(from);
			this.writeVarlong(to);
			this.writeByte(action);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetEntityLink().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetEntityLink(from: " + this.from + ", to: " + this.to + ", action: " + this.action + ")";
		}

	},

	SetHealth: class {

		static get ID(){ return 42; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(health=0) {
			this.health = health;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(health);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetHealth().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetHealth(health: " + this.health + ")";
		}

	},

	SetSpawnPosition: class {

		static get ID(){ return 43; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(unknown0=0, position=null, unknown2=false) {
			this.unknown0 = unknown0;
			this.position = position;
			this.unknown2 = unknown2;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(unknown0);
			this.writeBytes(position.encode());
			this.writeBool(unknown2);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetSpawnPosition().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetSpawnPosition(unknown0: " + this.unknown0 + ", position: " + this.position + ", unknown2: " + this.unknown2 + ")";
		}

	},

	Animate: class {

		static get ID(){ return 44; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		// action
		static get BREAKING(){ return 1; }
		static get WAKE_UP(){ return 3; }

		constructor(action=0, entityId=0) {
			this.action = action;
			this.entityId = entityId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(action);
			this.writeVarlong(entityId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Animate().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Animate(action: " + this.action + ", entityId: " + this.entityId + ")";
		}

	},

	Respawn: class {

		static get ID(){ return 45; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position={x:0,y:0,z:0}) {
			this.position = position;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Respawn().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Respawn(position: " + this.position + ")";
		}

	},

	DropItem: class {

		static get ID(){ return 46; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		// action
		static get DROP(){ return 0; }

		constructor(action=0, item=null) {
			this.action = action;
			this.item = item;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(action);
			this.writeBytes(item.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.DropItem().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "DropItem(action: " + this.action + ", item: " + this.item + ")";
		}

	},

	InventoryAction: class {

		static get ID(){ return 47; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(action=0, item=null) {
			this.action = action;
			this.item = item;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(action);
			this.writeBytes(item.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.InventoryAction().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "InventoryAction(action: " + this.action + ", item: " + this.item + ")";
		}

	},

	ContainerOpen: class {

		static get ID(){ return 48; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(window=0, type=0, slotCount=0, position=null, entityId=0) {
			this.window = window;
			this.type = type;
			this.slotCount = slotCount;
			this.position = position;
			this.entityId = entityId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(window);
			this.writeByte(type);
			this.writeVarint(slotCount);
			this.writeBytes(position.encode());
			this.writeVarlong(entityId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ContainerOpen().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ContainerOpen(window: " + this.window + ", type: " + this.type + ", slotCount: " + this.slotCount + ", position: " + this.position + ", entityId: " + this.entityId + ")";
		}

	},

	ContainerClose: class {

		static get ID(){ return 49; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(window=0) {
			this.window = window;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(window);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ContainerClose().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ContainerClose(window: " + this.window + ")";
		}

	},

	ContainerSetSlot: class {

		static get ID(){ return 50; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor(window=0, slot=0, hotbarSlot=0, item=null, unknown4=0) {
			this.window = window;
			this.slot = slot;
			this.hotbarSlot = hotbarSlot;
			this.item = item;
			this.unknown4 = unknown4;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(window);
			this.writeVarint(slot);
			this.writeVarint(hotbarSlot);
			this.writeBytes(item.encode());
			this.writeByte(unknown4);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ContainerSetSlot().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ContainerSetSlot(window: " + this.window + ", slot: " + this.slot + ", hotbarSlot: " + this.hotbarSlot + ", item: " + this.item + ", unknown4: " + this.unknown4 + ")";
		}

	},

	ContainerSetData: class {

		static get ID(){ return 51; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(window=0, property=0, value=0) {
			this.window = window;
			this.property = property;
			this.value = value;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(window);
			this.writeVarint(property);
			this.writeVarint(value);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ContainerSetData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ContainerSetData(window: " + this.window + ", property: " + this.property + ", value: " + this.value + ")";
		}

	},

	ContainerSetContent: class {

		static get ID(){ return 52; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(window=0, slots=[], hotbar=0) {
			this.window = window;
			this.slots = slots;
			this.hotbar = hotbar;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(window);
			this.writeVaruint(slots.length); for(c2xvdhm in slots){ this.writeBytes(slots[c2xvdhm].encode()); }
			this.writeVaruint(hotbar.length); for(ag90ymfy in hotbar){ this.writeVarint(hotbar[ag90ymfy]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ContainerSetContent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ContainerSetContent(window: " + this.window + ", slots: " + this.slots + ", hotbar: " + this.hotbar + ")";
		}

	},

	CraftingData: class {

		static get ID(){ return 53; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(recipes=[]) {
			this.recipes = recipes;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(recipes.length); for(cmvjaxblcw in recipes){ this.writeBytes(recipes[cmvjaxblcw].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.CraftingData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "CraftingData(recipes: " + this.recipes + ")";
		}

	},

	CraftingEvent: class {

		static get ID(){ return 54; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(window=0, type=0, uuid=new Uint8Array(16), input=[], output=[]) {
			this.window = window;
			this.type = type;
			this.uuid = uuid;
			this.input = input;
			this.output = output;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(window);
			this.writeVarint(type);
			this.writeBigEndianLong(uuid.getLeastSignificantBits()); this.writeBigEndianLong(uuid.getMostSignificantBits());
			this.writeVaruint(input.length); for(aw5wdxq in input){ this.writeBytes(input[aw5wdxq].encode()); }
			this.writeVaruint(output.length); for(b3v0chv0 in output){ this.writeBytes(output[b3v0chv0].encode()); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.CraftingEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "CraftingEvent(window: " + this.window + ", type: " + this.type + ", uuid: " + this.uuid + ", input: " + this.input + ", output: " + this.output + ")";
		}

	},

	AdventureSettings: class {

		static get ID(){ return 55; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		// flags
		static get IMMUTABLE_WORLD(){ return 1; }
		static get PVP_DISABLED(){ return 2; }
		static get PVM_DISABLED(){ return 4; }
		static get MVP_DISBALED(){ return 8; }
		static get EVP_DISABLED(){ return 16; }
		static get AUTO_JUMP(){ return 32; }
		static get ALLOW_FLIGHT(){ return 64; }
		static get NO_CLIP(){ return 128; }
		static get FLYING(){ return 256; }

		// permissions
		static get USER(){ return 0; }
		static get OPERATOR(){ return 1; }
		static get HOST(){ return 2; }
		static get AUTOMATION(){ return 3; }
		static get ADMIN(){ return 4; }

		constructor(flags=0, permissions=0) {
			this.flags = flags;
			this.permissions = permissions;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(flags);
			this.writeVaruint(permissions);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AdventureSettings().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AdventureSettings(flags: " + this.flags + ", permissions: " + this.permissions + ")";
		}

	},

	BlockEntityData: class {

		static get ID(){ return 56; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position=null, nbt=null) {
			this.position = position;
			this.nbt = nbt;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(position.encode());
			this.writeBytes(nbt);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.BlockEntityData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "BlockEntityData(position: " + this.position + ", nbt: " + this.nbt + ")";
		}

	},

	PlayerInput: class {

		static get ID(){ return 57; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(motion={x:0,y:0,z:0}, flags=0, unknown2=false) {
			this.motion = motion;
			this.flags = flags;
			this.unknown2 = unknown2;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeLittleEndianFloat(motion.x); this.writeLittleEndianFloat(motion.y); this.writeLittleEndianFloat(motion.z);
			this.writeByte(flags);
			this.writeBool(unknown2);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.PlayerInput().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "PlayerInput(motion: " + this.motion + ", flags: " + this.flags + ", unknown2: " + this.unknown2 + ")";
		}

	},

	FullChunkData: class {

		static get ID(){ return 58; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position=0, data=[], tiles=[]) {
			this.position = position;
			this.data = data;
			this.tiles = tiles;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(position.x); this.writeVarint(position.z);
			this.writeVaruint(data.length); for(zgf0yq in data){ this.writeByte(data[zgf0yq]); }
			this.writeVaruint(tiles.length); for(dglszxm in tiles){ this.writeByte(tiles[dglszxm]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.FullChunkData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "FullChunkData(position: " + this.position + ", data: " + this.data + ", tiles: " + this.tiles + ")";
		}

	},

	SetCheatsEnabled: class {

		static get ID(){ return 59; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(enabled=false) {
			this.enabled = enabled;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBool(enabled);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetCheatsEnabled().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetCheatsEnabled(enabled: " + this.enabled + ")";
		}

	},

	SetDifficulty: class {

		static get ID(){ return 60; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// difficulty
		static get PEACEFUL(){ return 0; }
		static get EASY(){ return 1; }
		static get NORMAL(){ return 2; }
		static get HARD(){ return 3; }

		constructor(difficulty=0) {
			this.difficulty = difficulty;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVaruint(difficulty);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetDifficulty().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetDifficulty(difficulty: " + this.difficulty + ")";
		}

	},

	ChangeDimension: class {

		static get ID(){ return 61; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// dimension
		static get OVERWORLD(){ return 0; }
		static get NETHER(){ return 1; }
		static get END(){ return 2; }

		constructor(dimension=0, position={x:0,y:0,z:0}, unknown2=false) {
			this.dimension = dimension;
			this.position = position;
			this.unknown2 = unknown2;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(dimension);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeBool(unknown2);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ChangeDimension().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ChangeDimension(dimension: " + this.dimension + ", position: " + this.position + ", unknown2: " + this.unknown2 + ")";
		}

	},

	SetPlayerGametype: class {

		static get ID(){ return 62; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		// gametype
		static get SURVIVAL(){ return 0; }
		static get CREATIVE(){ return 1; }

		constructor(gametype=0) {
			this.gametype = gametype;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(gametype);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SetPlayerGametype().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SetPlayerGametype(gametype: " + this.gametype + ")";
		}

	},

	PlayerList: class {

		static get ID(){ return 63; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(action=0) {
			this.action = action;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeByte(action);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.PlayerList().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "PlayerList(action: " + this.action + ")";
		}

	},

	TelemetryEvent: class {

		static get ID(){ return 64; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(entityId=0, eventId=0) {
			this.entityId = entityId;
			this.eventId = eventId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVarint(eventId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.TelemetryEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "TelemetryEvent(entityId: " + this.entityId + ", eventId: " + this.eventId + ")";
		}

	},

	SpawnExperienceOrb: class {

		static get ID(){ return 65; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position={x:0,y:0,z:0}, count=0) {
			this.position = position;
			this.count = count;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeLittleEndianFloat(position.x); this.writeLittleEndianFloat(position.y); this.writeLittleEndianFloat(position.z);
			this.writeVarint(count);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.SpawnExperienceOrb().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "SpawnExperienceOrb(position: " + this.position + ", count: " + this.count + ")";
		}

	},

	ClientboundMapItemData: class {

		static get ID(){ return 66; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// action
		static get UPDATE(){ return 4; }
		static get FULL(){ return 6; }

		constructor(mapId=0, unknown1=0, unknown2=0, unknown3=0, action=0, unknown5=0, unknown6=0, unknown7=0, unknown8=0, showIcons=false, icons=0, direction=0, position=0, columns=0, rows=0, offset=0, data=[]) {
			this.mapId = mapId;
			this.unknown1 = unknown1;
			this.unknown2 = unknown2;
			this.unknown3 = unknown3;
			this.action = action;
			this.unknown5 = unknown5;
			this.unknown6 = unknown6;
			this.unknown7 = unknown7;
			this.unknown8 = unknown8;
			this.showIcons = showIcons;
			this.icons = icons;
			this.direction = direction;
			this.position = position;
			this.columns = columns;
			this.rows = rows;
			this.offset = offset;
			this.data = data;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(mapId);
			this.writeVaruint(unknown1);
			this.writeVaruint(unknown2);
			this.writeVarlong(unknown3);
			this.writeByte(action);
			this.writeVaruint(unknown5);
			this.writeVarint(unknown6);
			this.writeByte(unknown7);
			this.writeByte(unknown8);
			this.writeBool(showIcons);
			this.writeVaruint(icons.length); for(awnvbnm in icons){ this.writeVarint(icons[awnvbnm].x); this.writeVarint(icons[awnvbnm].z); }
			this.writeVarint(direction);
			this.writeVarint(position.x); this.writeVarint(position.z);
			this.writeVarint(columns);
			this.writeVarint(rows);
			this.writeVarint(offset.x); this.writeVarint(offset.z);
			this.writeVaruint(data.length); for(zgf0yq in data){ this.writeByte(data[zgf0yq]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ClientboundMapItemData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ClientboundMapItemData(mapId: " + this.mapId + ", unknown1: " + this.unknown1 + ", unknown2: " + this.unknown2 + ", unknown3: " + this.unknown3 + ", action: " + this.action + ", unknown5: " + this.unknown5 + ", unknown6: " + this.unknown6 + ", unknown7: " + this.unknown7 + ", unknown8: " + this.unknown8 + ", showIcons: " + this.showIcons + ", icons: " + this.icons + ", direction: " + this.direction + ", position: " + this.position + ", columns: " + this.columns + ", rows: " + this.rows + ", offset: " + this.offset + ", data: " + this.data + ")";
		}

	},

	MapInfoRequest: class {

		static get ID(){ return 67; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(mapId=0) {
			this.mapId = mapId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(mapId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.MapInfoRequest().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "MapInfoRequest(mapId: " + this.mapId + ")";
		}

	},

	RequestChunkRadius: class {

		static get ID(){ return 68; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(radius=0) {
			this.radius = radius;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(radius);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.RequestChunkRadius().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "RequestChunkRadius(radius: " + this.radius + ")";
		}

	},

	ChunkRadiusUpdated: class {

		static get ID(){ return 69; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(radius=0) {
			this.radius = radius;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarint(radius);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ChunkRadiusUpdated().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ChunkRadiusUpdated(radius: " + this.radius + ")";
		}

	},

	ItemFrameDropItem: class {

		static get ID(){ return 70; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(position=null, item=null) {
			this.position = position;
			this.item = item;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(position.encode());
			this.writeBytes(item.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ItemFrameDropItem().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ItemFrameDropItem(position: " + this.position + ", item: " + this.item + ")";
		}

	},

	ReplaceSelectedItem: class {

		static get ID(){ return 71; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(item=null) {
			this.item = item;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(item.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ReplaceSelectedItem().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ReplaceSelectedItem(item: " + this.item + ")";
		}

	},

	Camera: class {

		static get ID(){ return 73; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(unknown0=0, unknown1=0) {
			this.unknown0 = unknown0;
			this.unknown1 = unknown1;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(unknown0);
			this.writeVarlong(unknown1);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Camera().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Camera(unknown0: " + this.unknown0 + ", unknown1: " + this.unknown1 + ")";
		}

	},

	AddItem: class {

		static get ID(){ return 74; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(item=null) {
			this.item = item;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeBytes(item.encode());
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AddItem().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AddItem(item: " + this.item + ")";
		}

	},

	BossEvent: class {

		static get ID(){ return 75; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		// event id
		static get ADD(){ return 0; }
		static get UPDATE(){ return 1; }
		static get REMOVE(){ return 2; }

		constructor(entityId=0, eventId=0) {
			this.entityId = entityId;
			this.eventId = eventId;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeVarlong(entityId);
			this.writeVaruint(eventId);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.BossEvent().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "BossEvent(entityId: " + this.entityId + ", eventId: " + this.eventId + ")";
		}

	},

	/**
	 * Shows the end credits to the player. They are always skippable client-side and a
	 * packet of this type is sent back by the client when the credits are skipped or finished.
	 */
	ShowCredits: class {

		static get ID(){ return 76; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return true; }

		constructor() {
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ShowCredits().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ShowCredits()";
		}

	},

	/**
	 * Sends a list of the commands that the player can use through the CommandStep packet.
	 */
	AvailableCommands: class {

		static get ID(){ return 77; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(commands="", unknown1="") {
			this.commands = commands;
			this.unknown1 = unknown1;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(commands);
			this.writeString(unknown1);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.AvailableCommands().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "AvailableCommands(commands: " + this.commands + ", unknown1: " + this.unknown1 + ")";
		}

	},

	CommandStep: class {

		static get ID(){ return 78; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(command="", overload="", unknown2=0, unknown3=0, isOutput=false, unknown5=0, input="", output="") {
			this.command = command;
			this.overload = overload;
			this.unknown2 = unknown2;
			this.unknown3 = unknown3;
			this.isOutput = isOutput;
			this.unknown5 = unknown5;
			this.input = input;
			this.output = output;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(command);
			this.writeString(overload);
			this.writeVaruint(unknown2);
			this.writeVaruint(unknown3);
			this.writeBool(isOutput);
			this.writeVarulong(unknown5);
			this.writeString(input);
			this.writeString(output);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.CommandStep().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "CommandStep(command: " + this.command + ", overload: " + this.overload + ", unknown2: " + this.unknown2 + ", unknown3: " + this.unknown3 + ", isOutput: " + this.isOutput + ", unknown5: " + this.unknown5 + ", input: " + this.input + ", output: " + this.output + ")";
		}

	},

	ResourcePackDataInfo: class {

		static get ID(){ return 79; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(id="", unknown1=0, unknown2=0, unknown3=0, unknown4="") {
			this.id = id;
			this.unknown1 = unknown1;
			this.unknown2 = unknown2;
			this.unknown3 = unknown3;
			this.unknown4 = unknown4;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(id);
			this.writeBigEndianInt(unknown1);
			this.writeBigEndianInt(unknown2);
			this.writeBigEndianLong(unknown3);
			this.writeString(unknown4);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ResourcePackDataInfo().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ResourcePackDataInfo(id: " + this.id + ", unknown1: " + this.unknown1 + ", unknown2: " + this.unknown2 + ", unknown3: " + this.unknown3 + ", unknown4: " + this.unknown4 + ")";
		}

	},

	ResourcePackChunkData: class {

		static get ID(){ return 80; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		constructor(id="", unknown1=0, unknown2=0, data=[]) {
			this.id = id;
			this.unknown1 = unknown1;
			this.unknown2 = unknown2;
			this.data = data;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(id);
			this.writeBigEndianInt(unknown1);
			this.writeBigEndianLong(unknown2);
			this.writeVaruint(data.length); for(zgf0yq in data){ this.writeByte(data[zgf0yq]); }
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ResourcePackChunkData().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ResourcePackChunkData(id: " + this.id + ", unknown1: " + this.unknown1 + ", unknown2: " + this.unknown2 + ", data: " + this.data + ")";
		}

	},

	ResourcePackChunkRequest: class {

		static get ID(){ return 81; }

		static get CLIENTBOUND(){ return false; }
		static get SERVERBOUND(){ return true; }

		constructor(id="", index=0) {
			this.id = id;
			this.index = index;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(id);
			this.writeBigEndianInt(index);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.ResourcePackChunkRequest().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "ResourcePackChunkRequest(id: " + this.id + ", index: " + this.index + ")";
		}

	},

	/**
	 * Transfers the player to another server. Once transferred the player will immediately
	 * close the connection with the transferring server, try to resolve the ip and join
	 * the new server starting a new raknet session.
	 */
	Transfer: class {

		static get ID(){ return 82; }

		static get CLIENTBOUND(){ return true; }
		static get SERVERBOUND(){ return false; }

		/**
		 * @param ip
		 *        Address of the new server. It can be an dotted ip (for example `127.0.0.1`) or an URI (for example
		 *        `localhost` or `play.example.com`). Only IP of version 4 are currently allowed.
		 * @param port
		 *        Port of the new server. If 0 the server will try to connect to the default port.
		 */
		constructor(ip="", port=0) {
			this.ip = ip;
			this.port = port;
		}

		/** @return {Uint8Array} */
		encode() {
			this.writeByte(this.ID);
			this.writeString(ip);
			this.writeLittleEndianShort(port);
		}

		/** @param {Uint8Array} buffer */
		decode(buffer) {
			if(!(buffer instanceof Uint8Array)) throw new TypeError('buffer is not a Uint8Array');
			return this;
		}

		static fromBuffer(buffer) {
			return new Play.Transfer().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Transfer(ip: " + this.ip + ", port: " + this.port + ")";
		}

	},

}

//export { Play };
